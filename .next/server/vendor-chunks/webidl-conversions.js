"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/webidl-conversions";
exports.ids = ["vendor-chunks/webidl-conversions"];
exports.modules = {

/***/ "(ssr)/./node_modules/webidl-conversions/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/webidl-conversions/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nfunction makeException(ErrorType, message, options) {\n    if (options.globals) {\n        ErrorType = options.globals[ErrorType.name];\n    }\n    return new ErrorType(`${options.context ? options.context : \"Value\"} ${message}.`);\n}\nfunction toNumber(value, options) {\n    if (typeof value === \"bigint\") {\n        throw makeException(TypeError, \"is a BigInt which cannot be converted to a number\", options);\n    }\n    if (!options.globals) {\n        return Number(value);\n    }\n    return options.globals.Number(value);\n}\n// Round x to the nearest integer, choosing the even integer if it lies halfway between two.\nfunction evenRound(x) {\n    // There are four cases for numbers with fractional part being .5:\n    //\n    // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n    //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n    //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n    //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n    //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n    // (where n is a non-negative integer)\n    //\n    // Branch here for cases 1 and 4\n    if (x > 0 && x % 1 === +0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {\n        return censorNegativeZero(Math.floor(x));\n    }\n    return censorNegativeZero(Math.round(x));\n}\nfunction integerPart(n) {\n    return censorNegativeZero(Math.trunc(n));\n}\nfunction sign(x) {\n    return x < 0 ? -1 : 1;\n}\nfunction modulo(x, y) {\n    // https://tc39.github.io/ecma262/#eqn-modulo\n    // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos\n    const signMightNotMatch = x % y;\n    if (sign(y) !== sign(signMightNotMatch)) {\n        return signMightNotMatch + y;\n    }\n    return signMightNotMatch;\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction createIntegerConversion(bitLength, { unsigned }) {\n    let lowerBound, upperBound;\n    if (unsigned) {\n        lowerBound = 0;\n        upperBound = 2 ** bitLength - 1;\n    } else {\n        lowerBound = -(2 ** (bitLength - 1));\n        upperBound = 2 ** (bitLength - 1) - 1;\n    }\n    const twoToTheBitLength = 2 ** bitLength;\n    const twoToOneLessThanTheBitLength = 2 ** (bitLength - 1);\n    return (value, options = {})=>{\n        let x = toNumber(value, options);\n        x = censorNegativeZero(x);\n        if (options.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw makeException(TypeError, \"is not a finite number\", options);\n            }\n            x = integerPart(x);\n            if (x < lowerBound || x > upperBound) {\n                throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);\n            }\n            return x;\n        }\n        if (!Number.isNaN(x) && options.clamp) {\n            x = Math.min(Math.max(x, lowerBound), upperBound);\n            x = evenRound(x);\n            return x;\n        }\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n        x = integerPart(x);\n        // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if\n        // possible. Hopefully it's an optimization for the non-64-bitLength cases too.\n        if (x >= lowerBound && x <= upperBound) {\n            return x;\n        }\n        // These will not work great for bitLength of 64, but oh well. See the README for more details.\n        x = modulo(x, twoToTheBitLength);\n        if (!unsigned && x >= twoToOneLessThanTheBitLength) {\n            return x - twoToTheBitLength;\n        }\n        return x;\n    };\n}\nfunction createLongLongConversion(bitLength, { unsigned }) {\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    const lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;\n    const asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;\n    return (value, options = {})=>{\n        let x = toNumber(value, options);\n        x = censorNegativeZero(x);\n        if (options.enforceRange) {\n            if (!Number.isFinite(x)) {\n                throw makeException(TypeError, \"is not a finite number\", options);\n            }\n            x = integerPart(x);\n            if (x < lowerBound || x > upperBound) {\n                throw makeException(TypeError, `is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`, options);\n            }\n            return x;\n        }\n        if (!Number.isNaN(x) && options.clamp) {\n            x = Math.min(Math.max(x, lowerBound), upperBound);\n            x = evenRound(x);\n            return x;\n        }\n        if (!Number.isFinite(x) || x === 0) {\n            return 0;\n        }\n        let xBigInt = BigInt(integerPart(x));\n        xBigInt = asBigIntN(bitLength, xBigInt);\n        return Number(xBigInt);\n    };\n}\nexports.any = (value)=>{\n    return value;\n};\nexports.undefined = ()=>{\n    return undefined;\n};\nexports.boolean = (value)=>{\n    return Boolean(value);\n};\nexports.byte = createIntegerConversion(8, {\n    unsigned: false\n});\nexports.octet = createIntegerConversion(8, {\n    unsigned: true\n});\nexports.short = createIntegerConversion(16, {\n    unsigned: false\n});\nexports[\"unsigned short\"] = createIntegerConversion(16, {\n    unsigned: true\n});\nexports.long = createIntegerConversion(32, {\n    unsigned: false\n});\nexports[\"unsigned long\"] = createIntegerConversion(32, {\n    unsigned: true\n});\nexports[\"long long\"] = createLongLongConversion(64, {\n    unsigned: false\n});\nexports[\"unsigned long long\"] = createLongLongConversion(64, {\n    unsigned: true\n});\nexports.double = (value, options = {})=>{\n    const x = toNumber(value, options);\n    if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite floating-point value\", options);\n    }\n    return x;\n};\nexports[\"unrestricted double\"] = (value, options = {})=>{\n    const x = toNumber(value, options);\n    return x;\n};\nexports.float = (value, options = {})=>{\n    const x = toNumber(value, options);\n    if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite floating-point value\", options);\n    }\n    if (Object.is(x, -0)) {\n        return x;\n    }\n    const y = Math.fround(x);\n    if (!Number.isFinite(y)) {\n        throw makeException(TypeError, \"is outside the range of a single-precision floating-point value\", options);\n    }\n    return y;\n};\nexports[\"unrestricted float\"] = (value, options = {})=>{\n    const x = toNumber(value, options);\n    if (isNaN(x)) {\n        return x;\n    }\n    if (Object.is(x, -0)) {\n        return x;\n    }\n    return Math.fround(x);\n};\nexports.DOMString = (value, options = {})=>{\n    if (options.treatNullAsEmptyString && value === null) {\n        return \"\";\n    }\n    if (typeof value === \"symbol\") {\n        throw makeException(TypeError, \"is a symbol, which cannot be converted to a string\", options);\n    }\n    const StringCtor = options.globals ? options.globals.String : String;\n    return StringCtor(value);\n};\nexports.ByteString = (value, options = {})=>{\n    const x = exports.DOMString(value, options);\n    let c;\n    for(let i = 0; (c = x.codePointAt(i)) !== undefined; ++i){\n        if (c > 255) {\n            throw makeException(TypeError, \"is not a valid ByteString\", options);\n        }\n    }\n    return x;\n};\nexports.USVString = (value, options = {})=>{\n    const S = exports.DOMString(value, options);\n    const n = S.length;\n    const U = [];\n    for(let i = 0; i < n; ++i){\n        const c = S.charCodeAt(i);\n        if (c < 0xD800 || c > 0xDFFF) {\n            U.push(String.fromCodePoint(c));\n        } else if (0xDC00 <= c && c <= 0xDFFF) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else if (i === n - 1) {\n            U.push(String.fromCodePoint(0xFFFD));\n        } else {\n            const d = S.charCodeAt(i + 1);\n            if (0xDC00 <= d && d <= 0xDFFF) {\n                const a = c & 0x3FF;\n                const b = d & 0x3FF;\n                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n                ++i;\n            } else {\n                U.push(String.fromCodePoint(0xFFFD));\n            }\n        }\n    }\n    return U.join(\"\");\n};\nexports.object = (value, options = {})=>{\n    if (value === null || typeof value !== \"object\" && typeof value !== \"function\") {\n        throw makeException(TypeError, \"is not an object\", options);\n    }\n    return value;\n};\nconst abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get;\nconst sabByteLengthGetter = typeof SharedArrayBuffer === \"function\" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, \"byteLength\").get : null;\nfunction isNonSharedArrayBuffer(value) {\n    try {\n        // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.\n        // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)\n        abByteLengthGetter.call(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction isSharedArrayBuffer(value) {\n    try {\n        sabByteLengthGetter.call(value);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction isArrayBufferDetached(value) {\n    try {\n        // eslint-disable-next-line no-new\n        new Uint8Array(value);\n        return false;\n    } catch  {\n        return true;\n    }\n}\nexports.ArrayBuffer = (value, options = {})=>{\n    if (!isNonSharedArrayBuffer(value)) {\n        if (options.allowShared && !isSharedArrayBuffer(value)) {\n            throw makeException(TypeError, \"is not an ArrayBuffer or SharedArrayBuffer\", options);\n        }\n        throw makeException(TypeError, \"is not an ArrayBuffer\", options);\n    }\n    if (isArrayBufferDetached(value)) {\n        throw makeException(TypeError, \"is a detached ArrayBuffer\", options);\n    }\n    return value;\n};\nconst dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, \"byteLength\").get;\nexports.DataView = (value, options = {})=>{\n    try {\n        dvByteLengthGetter.call(value);\n    } catch (e) {\n        throw makeException(TypeError, \"is not a DataView\", options);\n    }\n    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n        throw makeException(TypeError, \"is backed by a SharedArrayBuffer, which is not allowed\", options);\n    }\n    if (isArrayBufferDetached(value.buffer)) {\n        throw makeException(TypeError, \"is backed by a detached ArrayBuffer\", options);\n    }\n    return value;\n};\n// Returns the unforgeable `TypedArray` constructor name or `undefined`,\n// if the `this` value isn't a valid `TypedArray` object.\n//\n// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag\nconst typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;\n[\n    Int8Array,\n    Int16Array,\n    Int32Array,\n    Uint8Array,\n    Uint16Array,\n    Uint32Array,\n    Uint8ClampedArray,\n    Float32Array,\n    Float64Array\n].forEach((func)=>{\n    const { name } = func;\n    const article = /^[AEIOU]/u.test(name) ? \"an\" : \"a\";\n    exports[name] = (value, options = {})=>{\n        if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {\n            throw makeException(TypeError, `is not ${article} ${name} object`, options);\n        }\n        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n            throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n        }\n        if (isArrayBufferDetached(value.buffer)) {\n            throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n        }\n        return value;\n    };\n});\n// Common definitions\nexports.ArrayBufferView = (value, options = {})=>{\n    if (!ArrayBuffer.isView(value)) {\n        throw makeException(TypeError, \"is not a view on an ArrayBuffer or SharedArrayBuffer\", options);\n    }\n    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n        throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n    }\n    if (isArrayBufferDetached(value.buffer)) {\n        throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n    }\n    return value;\n};\nexports.BufferSource = (value, options = {})=>{\n    if (ArrayBuffer.isView(value)) {\n        if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n            throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n        }\n        if (isArrayBufferDetached(value.buffer)) {\n            throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n        }\n        return value;\n    }\n    if (!options.allowShared && !isNonSharedArrayBuffer(value)) {\n        throw makeException(TypeError, \"is not an ArrayBuffer or a view on one\", options);\n    }\n    if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {\n        throw makeException(TypeError, \"is not an ArrayBuffer, SharedArrayBuffer, or a view on one\", options);\n    }\n    if (isArrayBufferDetached(value)) {\n        throw makeException(TypeError, \"is a detached ArrayBuffer\", options);\n    }\n    return value;\n};\nexports.DOMTimeStamp = exports[\"unsigned long long\"];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvd2ViaWRsLWNvbnZlcnNpb25zL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViLFNBQVNBLGNBQWNDLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxPQUFPO0lBQ2hELElBQUlBLFFBQVFDLE9BQU8sRUFBRTtRQUNuQkgsWUFBWUUsUUFBUUMsT0FBTyxDQUFDSCxVQUFVSSxJQUFJLENBQUM7SUFDN0M7SUFDQSxPQUFPLElBQUlKLFVBQVUsQ0FBQyxFQUFFRSxRQUFRRyxPQUFPLEdBQUdILFFBQVFHLE9BQU8sR0FBRyxRQUFRLENBQUMsRUFBRUosUUFBUSxDQUFDLENBQUM7QUFDbkY7QUFFQSxTQUFTSyxTQUFTQyxLQUFLLEVBQUVMLE9BQU87SUFDOUIsSUFBSSxPQUFPSyxVQUFVLFVBQVU7UUFDN0IsTUFBTVIsY0FBY1MsV0FBVyxxREFBcUROO0lBQ3RGO0lBQ0EsSUFBSSxDQUFDQSxRQUFRQyxPQUFPLEVBQUU7UUFDcEIsT0FBT00sT0FBT0Y7SUFDaEI7SUFDQSxPQUFPTCxRQUFRQyxPQUFPLENBQUNNLE1BQU0sQ0FBQ0Y7QUFDaEM7QUFFQSw0RkFBNEY7QUFDNUYsU0FBU0csVUFBVUMsQ0FBQztJQUNsQixrRUFBa0U7SUFDbEUsRUFBRTtJQUNGLHlGQUF5RjtJQUN6RiwwRkFBMEY7SUFDMUYsMEZBQTBGO0lBQzFGLDBGQUEwRjtJQUMxRiwwRkFBMEY7SUFDMUYsc0NBQXNDO0lBQ3RDLEVBQUU7SUFDRixnQ0FBZ0M7SUFDaEMsSUFBSSxJQUFLLEtBQUssSUFBSyxNQUFPLENBQUMsT0FBTyxDQUFDQSxJQUFJLE9BQU8sS0FDdkNBLElBQUksS0FBSyxJQUFLLE1BQU8sQ0FBQyxPQUFPLENBQUNBLElBQUksT0FBTyxHQUFJO1FBQ2xELE9BQU9DLG1CQUFtQkMsS0FBS0MsS0FBSyxDQUFDSDtJQUN2QztJQUVBLE9BQU9DLG1CQUFtQkMsS0FBS0UsS0FBSyxDQUFDSjtBQUN2QztBQUVBLFNBQVNLLFlBQVlDLENBQUM7SUFD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RjtJQUVBLElBQUlzRixzQkFBc0JqRixNQUFNdUYsTUFBTSxHQUFHO1FBQ3ZDLE1BQU0vRixjQUFjUyxXQUFXLHVDQUF1Q047SUFDeEU7SUFDQSxPQUFPSztBQUNUO0FBRUFxQyxvQkFBb0IsR0FBRyxDQUFDckMsT0FBT0wsVUFBVSxDQUFDLENBQUM7SUFDekMsSUFBSThFLFlBQVkrQixNQUFNLENBQUN4RyxRQUFRO1FBQzdCLElBQUksQ0FBQ0wsUUFBUXdGLFdBQVcsSUFBSUgsb0JBQW9CaEYsTUFBTXVGLE1BQU0sR0FBRztZQUM3RCxNQUFNL0YsY0FBY1MsV0FBVywwREFBMEROO1FBQzNGO1FBRUEsSUFBSXNGLHNCQUFzQmpGLE1BQU11RixNQUFNLEdBQUc7WUFDdkMsTUFBTS9GLGNBQWNTLFdBQVcsdUNBQXVDTjtRQUN4RTtRQUNBLE9BQU9LO0lBQ1Q7SUFFQSxJQUFJLENBQUNMLFFBQVF3RixXQUFXLElBQUksQ0FBQ0wsdUJBQXVCOUUsUUFBUTtRQUMxRCxNQUFNUixjQUFjUyxXQUFXLDBDQUEwQ047SUFDM0U7SUFDQSxJQUFJQSxRQUFRd0YsV0FBVyxJQUFJLENBQUNILG9CQUFvQmhGLFVBQVUsQ0FBQzhFLHVCQUF1QjlFLFFBQVE7UUFDeEYsTUFBTVIsY0FBY1MsV0FBVyw4REFBOEROO0lBQy9GO0lBQ0EsSUFBSXNGLHNCQUFzQmpGLFFBQVE7UUFDaEMsTUFBTVIsY0FBY1MsV0FBVyw2QkFBNkJOO0lBQzlEO0lBRUEsT0FBT0s7QUFDVDtBQUVBcUMsb0JBQW9CLEdBQUdBLE9BQU8sQ0FBQyxxQkFBcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW9uZXotbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3dlYmlkbC1jb252ZXJzaW9ucy9saWIvaW5kZXguanM/MGY3NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZnVuY3Rpb24gbWFrZUV4Y2VwdGlvbihFcnJvclR5cGUsIG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuZ2xvYmFscykge1xuICAgIEVycm9yVHlwZSA9IG9wdGlvbnMuZ2xvYmFsc1tFcnJvclR5cGUubmFtZV07XG4gIH1cbiAgcmV0dXJuIG5ldyBFcnJvclR5cGUoYCR7b3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogXCJWYWx1ZVwifSAke21lc3NhZ2V9LmApO1xufVxuXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSBCaWdJbnQgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlclwiLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoIW9wdGlvbnMuZ2xvYmFscykge1xuICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICB9XG4gIHJldHVybiBvcHRpb25zLmdsb2JhbHMuTnVtYmVyKHZhbHVlKTtcbn1cblxuLy8gUm91bmQgeCB0byB0aGUgbmVhcmVzdCBpbnRlZ2VyLCBjaG9vc2luZyB0aGUgZXZlbiBpbnRlZ2VyIGlmIGl0IGxpZXMgaGFsZndheSBiZXR3ZWVuIHR3by5cbmZ1bmN0aW9uIGV2ZW5Sb3VuZCh4KSB7XG4gIC8vIFRoZXJlIGFyZSBmb3VyIGNhc2VzIGZvciBudW1iZXJzIHdpdGggZnJhY3Rpb25hbCBwYXJ0IGJlaW5nIC41OlxuICAvL1xuICAvLyBjYXNlIHwgICAgIHggICAgIHwgZmxvb3IoeCkgfCByb3VuZCh4KSB8IGV4cGVjdGVkIHwgeCA8PiAwIHwgeCAlIDEgfCB4ICYgMSB8ICAgZXhhbXBsZVxuICAvLyAgIDEgIHwgIDJuICsgMC41IHwgIDJuICAgICAgfCAgMm4gKyAxICB8ICAybiAgICAgIHwgICA+ICAgIHwgIDAuNSAgfCAgIDAgICB8ICAwLjUgLT4gIDBcbiAgLy8gICAyICB8ICAybiArIDEuNSB8ICAybiArIDEgIHwgIDJuICsgMiAgfCAgMm4gKyAyICB8ICAgPiAgICB8ICAwLjUgIHwgICAxICAgfCAgMS41IC0+ICAyXG4gIC8vICAgMyAgfCAtMm4gLSAwLjUgfCAtMm4gLSAxICB8IC0ybiAgICAgIHwgLTJuICAgICAgfCAgIDwgICAgfCAtMC41ICB8ICAgMCAgIHwgLTAuNSAtPiAgMFxuICAvLyAgIDQgIHwgLTJuIC0gMS41IHwgLTJuIC0gMiAgfCAtMm4gLSAxICB8IC0ybiAtIDIgIHwgICA8ICAgIHwgLTAuNSAgfCAgIDEgICB8IC0xLjUgLT4gLTJcbiAgLy8gKHdoZXJlIG4gaXMgYSBub24tbmVnYXRpdmUgaW50ZWdlcilcbiAgLy9cbiAgLy8gQnJhbmNoIGhlcmUgZm9yIGNhc2VzIDEgYW5kIDRcbiAgaWYgKCh4ID4gMCAmJiAoeCAlIDEpID09PSArMC41ICYmICh4ICYgMSkgPT09IDApIHx8XG4gICAgICAgICh4IDwgMCAmJiAoeCAlIDEpID09PSAtMC41ICYmICh4ICYgMSkgPT09IDEpKSB7XG4gICAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoLmZsb29yKHgpKTtcbiAgfVxuXG4gIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aC5yb3VuZCh4KSk7XG59XG5cbmZ1bmN0aW9uIGludGVnZXJQYXJ0KG4pIHtcbiAgcmV0dXJuIGNlbnNvck5lZ2F0aXZlWmVybyhNYXRoLnRydW5jKG4pKTtcbn1cblxuZnVuY3Rpb24gc2lnbih4KSB7XG4gIHJldHVybiB4IDwgMCA/IC0xIDogMTtcbn1cblxuZnVuY3Rpb24gbW9kdWxvKHgsIHkpIHtcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNlcW4tbW9kdWxvXG4gIC8vIE5vdGUgdGhhdCBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NDY3NTU5LzMxOTEgZG9lcyBOT1Qgd29yayBmb3IgbGFyZ2UgbW9kdWxvc1xuICBjb25zdCBzaWduTWlnaHROb3RNYXRjaCA9IHggJSB5O1xuICBpZiAoc2lnbih5KSAhPT0gc2lnbihzaWduTWlnaHROb3RNYXRjaCkpIHtcbiAgICByZXR1cm4gc2lnbk1pZ2h0Tm90TWF0Y2ggKyB5O1xuICB9XG4gIHJldHVybiBzaWduTWlnaHROb3RNYXRjaDtcbn1cblxuZnVuY3Rpb24gY2Vuc29yTmVnYXRpdmVaZXJvKHgpIHtcbiAgcmV0dXJuIHggPT09IDAgPyAwIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50ZWdlckNvbnZlcnNpb24oYml0TGVuZ3RoLCB7IHVuc2lnbmVkIH0pIHtcbiAgbGV0IGxvd2VyQm91bmQsIHVwcGVyQm91bmQ7XG4gIGlmICh1bnNpZ25lZCkge1xuICAgIGxvd2VyQm91bmQgPSAwO1xuICAgIHVwcGVyQm91bmQgPSAyICoqIGJpdExlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgbG93ZXJCb3VuZCA9IC0oMiAqKiAoYml0TGVuZ3RoIC0gMSkpO1xuICAgIHVwcGVyQm91bmQgPSAyICoqIChiaXRMZW5ndGggLSAxKSAtIDE7XG4gIH1cblxuICBjb25zdCB0d29Ub1RoZUJpdExlbmd0aCA9IDIgKiogYml0TGVuZ3RoO1xuICBjb25zdCB0d29Ub09uZUxlc3NUaGFuVGhlQml0TGVuZ3RoID0gMiAqKiAoYml0TGVuZ3RoIC0gMSk7XG5cbiAgcmV0dXJuICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgbGV0IHggPSB0b051bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgeCA9IGNlbnNvck5lZ2F0aXZlWmVybyh4KTtcblxuICAgIGlmIChvcHRpb25zLmVuZm9yY2VSYW5nZSkge1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGEgZmluaXRlIG51bWJlclwiLCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgeCA9IGludGVnZXJQYXJ0KHgpO1xuXG4gICAgICBpZiAoeCA8IGxvd2VyQm91bmQgfHwgeCA+IHVwcGVyQm91bmQpIHtcbiAgICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihcbiAgICAgICAgICBUeXBlRXJyb3IsXG4gICAgICAgICAgYGlzIG91dHNpZGUgdGhlIGFjY2VwdGVkIHJhbmdlIG9mICR7bG93ZXJCb3VuZH0gdG8gJHt1cHBlckJvdW5kfSwgaW5jbHVzaXZlYCxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGlmICghTnVtYmVyLmlzTmFOKHgpICYmIG9wdGlvbnMuY2xhbXApIHtcbiAgICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCBsb3dlckJvdW5kKSwgdXBwZXJCb3VuZCk7XG4gICAgICB4ID0gZXZlblJvdW5kKHgpO1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkgfHwgeCA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHggPSBpbnRlZ2VyUGFydCh4KTtcblxuICAgIC8vIE1hdGgucG93KDIsIDY0KSBpcyBub3QgYWNjdXJhdGVseSByZXByZXNlbnRhYmxlIGluIEphdmFTY3JpcHQsIHNvIHRyeSB0byBhdm9pZCB0aGVzZSBwZXItc3BlYyBvcGVyYXRpb25zIGlmXG4gICAgLy8gcG9zc2libGUuIEhvcGVmdWxseSBpdCdzIGFuIG9wdGltaXphdGlvbiBmb3IgdGhlIG5vbi02NC1iaXRMZW5ndGggY2FzZXMgdG9vLlxuICAgIGlmICh4ID49IGxvd2VyQm91bmQgJiYgeCA8PSB1cHBlckJvdW5kKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICAvLyBUaGVzZSB3aWxsIG5vdCB3b3JrIGdyZWF0IGZvciBiaXRMZW5ndGggb2YgNjQsIGJ1dCBvaCB3ZWxsLiBTZWUgdGhlIFJFQURNRSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIHggPSBtb2R1bG8oeCwgdHdvVG9UaGVCaXRMZW5ndGgpO1xuICAgIGlmICghdW5zaWduZWQgJiYgeCA+PSB0d29Ub09uZUxlc3NUaGFuVGhlQml0TGVuZ3RoKSB7XG4gICAgICByZXR1cm4geCAtIHR3b1RvVGhlQml0TGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTG9uZ0xvbmdDb252ZXJzaW9uKGJpdExlbmd0aCwgeyB1bnNpZ25lZCB9KSB7XG4gIGNvbnN0IHVwcGVyQm91bmQgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgY29uc3QgbG93ZXJCb3VuZCA9IHVuc2lnbmVkID8gMCA6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xuICBjb25zdCBhc0JpZ0ludE4gPSB1bnNpZ25lZCA/IEJpZ0ludC5hc1VpbnROIDogQmlnSW50LmFzSW50TjtcblxuICByZXR1cm4gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBsZXQgeCA9IHRvTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICB4ID0gY2Vuc29yTmVnYXRpdmVaZXJvKHgpO1xuXG4gICAgaWYgKG9wdGlvbnMuZW5mb3JjZVJhbmdlKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYSBmaW5pdGUgbnVtYmVyXCIsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB4ID0gaW50ZWdlclBhcnQoeCk7XG5cbiAgICAgIGlmICh4IDwgbG93ZXJCb3VuZCB8fCB4ID4gdXBwZXJCb3VuZCkge1xuICAgICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFxuICAgICAgICAgIFR5cGVFcnJvcixcbiAgICAgICAgICBgaXMgb3V0c2lkZSB0aGUgYWNjZXB0ZWQgcmFuZ2Ugb2YgJHtsb3dlckJvdW5kfSB0byAke3VwcGVyQm91bmR9LCBpbmNsdXNpdmVgLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4oeCkgJiYgb3B0aW9ucy5jbGFtcCkge1xuICAgICAgeCA9IE1hdGgubWluKE1hdGgubWF4KHgsIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbiAgICAgIHggPSBldmVuUm91bmQoeCk7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG5cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBsZXQgeEJpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCh4KSk7XG4gICAgeEJpZ0ludCA9IGFzQmlnSW50TihiaXRMZW5ndGgsIHhCaWdJbnQpO1xuICAgIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG4gIH07XG59XG5cbmV4cG9ydHMuYW55ID0gdmFsdWUgPT4ge1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG5leHBvcnRzLnVuZGVmaW5lZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydHMuYm9vbGVhbiA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xufTtcblxuZXhwb3J0cy5ieXRlID0gY3JlYXRlSW50ZWdlckNvbnZlcnNpb24oOCwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XG5leHBvcnRzLm9jdGV0ID0gY3JlYXRlSW50ZWdlckNvbnZlcnNpb24oOCwgeyB1bnNpZ25lZDogdHJ1ZSB9KTtcblxuZXhwb3J0cy5zaG9ydCA9IGNyZWF0ZUludGVnZXJDb252ZXJzaW9uKDE2LCB7IHVuc2lnbmVkOiBmYWxzZSB9KTtcbmV4cG9ydHNbXCJ1bnNpZ25lZCBzaG9ydFwiXSA9IGNyZWF0ZUludGVnZXJDb252ZXJzaW9uKDE2LCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xuXG5leHBvcnRzLmxvbmcgPSBjcmVhdGVJbnRlZ2VyQ29udmVyc2lvbigzMiwgeyB1bnNpZ25lZDogZmFsc2UgfSk7XG5leHBvcnRzW1widW5zaWduZWQgbG9uZ1wiXSA9IGNyZWF0ZUludGVnZXJDb252ZXJzaW9uKDMyLCB7IHVuc2lnbmVkOiB0cnVlIH0pO1xuXG5leHBvcnRzW1wibG9uZyBsb25nXCJdID0gY3JlYXRlTG9uZ0xvbmdDb252ZXJzaW9uKDY0LCB7IHVuc2lnbmVkOiBmYWxzZSB9KTtcbmV4cG9ydHNbXCJ1bnNpZ25lZCBsb25nIGxvbmdcIl0gPSBjcmVhdGVMb25nTG9uZ0NvbnZlcnNpb24oNjQsIHsgdW5zaWduZWQ6IHRydWUgfSk7XG5cbmV4cG9ydHMuZG91YmxlID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeCA9IHRvTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcblxuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhIGZpbml0ZSBmbG9hdGluZy1wb2ludCB2YWx1ZVwiLCBvcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiB4O1xufTtcblxuZXhwb3J0c1tcInVucmVzdHJpY3RlZCBkb3VibGVcIl0gPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB4ID0gdG9OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuXG4gIHJldHVybiB4O1xufTtcblxuZXhwb3J0cy5mbG9hdCA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHggPSB0b051bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG5cbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeCkpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYSBmaW5pdGUgZmxvYXRpbmctcG9pbnQgdmFsdWVcIiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmlzKHgsIC0wKSkge1xuICAgIHJldHVybiB4O1xuICB9XG5cbiAgY29uc3QgeSA9IE1hdGguZnJvdW5kKHgpO1xuXG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgb3V0c2lkZSB0aGUgcmFuZ2Ugb2YgYSBzaW5nbGUtcHJlY2lzaW9uIGZsb2F0aW5nLXBvaW50IHZhbHVlXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHk7XG59O1xuXG5leHBvcnRzW1widW5yZXN0cmljdGVkIGZsb2F0XCJdID0gKHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeCA9IHRvTnVtYmVyKHZhbHVlLCBvcHRpb25zKTtcblxuICBpZiAoaXNOYU4oeCkpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuXG4gIGlmIChPYmplY3QuaXMoeCwgLTApKSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICByZXR1cm4gTWF0aC5mcm91bmQoeCk7XG59O1xuXG5leHBvcnRzLkRPTVN0cmluZyA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmIChvcHRpb25zLnRyZWF0TnVsbEFzRW1wdHlTdHJpbmcgJiYgdmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBhIHN5bWJvbCwgd2hpY2ggY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZ1wiLCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN0IFN0cmluZ0N0b3IgPSBvcHRpb25zLmdsb2JhbHMgPyBvcHRpb25zLmdsb2JhbHMuU3RyaW5nIDogU3RyaW5nO1xuICByZXR1cm4gU3RyaW5nQ3Rvcih2YWx1ZSk7XG59O1xuXG5leHBvcnRzLkJ5dGVTdHJpbmcgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB4ID0gZXhwb3J0cy5ET01TdHJpbmcodmFsdWUsIG9wdGlvbnMpO1xuICBsZXQgYztcbiAgZm9yIChsZXQgaSA9IDA7IChjID0geC5jb2RlUG9pbnRBdChpKSkgIT09IHVuZGVmaW5lZDsgKytpKSB7XG4gICAgaWYgKGMgPiAyNTUpIHtcbiAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhIHZhbGlkIEJ5dGVTdHJpbmdcIiwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHg7XG59O1xuXG5leHBvcnRzLlVTVlN0cmluZyA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IFMgPSBleHBvcnRzLkRPTVN0cmluZyh2YWx1ZSwgb3B0aW9ucyk7XG4gIGNvbnN0IG4gPSBTLmxlbmd0aDtcbiAgY29uc3QgVSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGMgPSBTLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGMgPCAweEQ4MDAgfHwgYyA+IDB4REZGRikge1xuICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KGMpKTtcbiAgICB9IGVsc2UgaWYgKDB4REMwMCA8PSBjICYmIGMgPD0gMHhERkZGKSB7XG4gICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoMHhGRkZEKSk7XG4gICAgfSBlbHNlIGlmIChpID09PSBuIC0gMSkge1xuICAgICAgVS5wdXNoKFN0cmluZy5mcm9tQ29kZVBvaW50KDB4RkZGRCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkID0gUy5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgIGlmICgweERDMDAgPD0gZCAmJiBkIDw9IDB4REZGRikge1xuICAgICAgICBjb25zdCBhID0gYyAmIDB4M0ZGO1xuICAgICAgICBjb25zdCBiID0gZCAmIDB4M0ZGO1xuICAgICAgICBVLnB1c2goU3RyaW5nLmZyb21Db2RlUG9pbnQoKDIgPDwgMTUpICsgKCgyIDw8IDkpICogYSkgKyBiKSk7XG4gICAgICAgICsraTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFUucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCgweEZGRkQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gVS5qb2luKFwiXCIpO1xufTtcblxuZXhwb3J0cy5vYmplY3QgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUgIT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYW4gb2JqZWN0XCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuY29uc3QgYWJCeXRlTGVuZ3RoR2V0dGVyID1cbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEFycmF5QnVmZmVyLnByb3RvdHlwZSwgXCJieXRlTGVuZ3RoXCIpLmdldDtcbmNvbnN0IHNhYkJ5dGVMZW5ndGhHZXR0ZXIgPVxuICAgIHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiID9cbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoU2hhcmVkQXJyYXlCdWZmZXIucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIikuZ2V0IDpcbiAgICAgIG51bGw7XG5cbmZ1bmN0aW9uIGlzTm9uU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgb24gU2hhcmVkQXJyYXlCdWZmZXJzLCBidXQgbm90IGRldGFjaGVkIEFycmF5QnVmZmVycy5cbiAgICAvLyAoVGhlIHNwZWMgc2F5cyBpdCBzaG91bGQgdGhyb3csIGJ1dCB0aGUgc3BlYyBjb25mbGljdHMgd2l0aCBpbXBsZW1lbnRhdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWEyNjIvaXNzdWVzLzY3OClcbiAgICBhYkJ5dGVMZW5ndGhHZXR0ZXIuY2FsbCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBzYWJCeXRlTGVuZ3RoR2V0dGVyLmNhbGwodmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlckRldGFjaGVkKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ld1xuICAgIG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmV4cG9ydHMuQXJyYXlCdWZmZXIgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoIWlzTm9uU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgIWlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBub3QgYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXJcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhbiBBcnJheUJ1ZmZlclwiLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlckRldGFjaGVkKHZhbHVlKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgZGV0YWNoZWQgQXJyYXlCdWZmZXJcIiwgb3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5jb25zdCBkdkJ5dGVMZW5ndGhHZXR0ZXIgPVxuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRGF0YVZpZXcucHJvdG90eXBlLCBcImJ5dGVMZW5ndGhcIikuZ2V0O1xuZXhwb3J0cy5EYXRhVmlldyA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHRyeSB7XG4gICAgZHZCeXRlTGVuZ3RoR2V0dGVyLmNhbGwodmFsdWUpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGEgRGF0YVZpZXdcIiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYmFja2VkIGJ5IGEgU2hhcmVkQXJyYXlCdWZmZXIsIHdoaWNoIGlzIG5vdCBhbGxvd2VkXCIsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChpc0FycmF5QnVmZmVyRGV0YWNoZWQodmFsdWUuYnVmZmVyKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGJhY2tlZCBieSBhIGRldGFjaGVkIEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gUmV0dXJucyB0aGUgdW5mb3JnZWFibGUgYFR5cGVkQXJyYXlgIGNvbnN0cnVjdG9yIG5hbWUgb3IgYHVuZGVmaW5lZGAsXG4vLyBpZiB0aGUgYHRoaXNgIHZhbHVlIGlzbid0IGEgdmFsaWQgYFR5cGVkQXJyYXlgIG9iamVjdC5cbi8vXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldC0ldHlwZWRhcnJheSUucHJvdG90eXBlLUBAdG9zdHJpbmd0YWdcbmNvbnN0IHR5cGVkQXJyYXlOYW1lR2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgT2JqZWN0LmdldFByb3RvdHlwZU9mKFVpbnQ4QXJyYXkpLnByb3RvdHlwZSxcbiAgU3ltYm9sLnRvU3RyaW5nVGFnXG4pLmdldDtcbltcbiAgSW50OEFycmF5LFxuICBJbnQxNkFycmF5LFxuICBJbnQzMkFycmF5LFxuICBVaW50OEFycmF5LFxuICBVaW50MTZBcnJheSxcbiAgVWludDMyQXJyYXksXG4gIFVpbnQ4Q2xhbXBlZEFycmF5LFxuICBGbG9hdDMyQXJyYXksXG4gIEZsb2F0NjRBcnJheVxuXS5mb3JFYWNoKGZ1bmMgPT4ge1xuICBjb25zdCB7IG5hbWUgfSA9IGZ1bmM7XG4gIGNvbnN0IGFydGljbGUgPSAvXltBRUlPVV0vdS50ZXN0KG5hbWUpID8gXCJhblwiIDogXCJhXCI7XG4gIGV4cG9ydHNbbmFtZV0gPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSB8fCB0eXBlZEFycmF5TmFtZUdldHRlci5jYWxsKHZhbHVlKSAhPT0gbmFtZSkge1xuICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIGBpcyBub3QgJHthcnRpY2xlfSAke25hbWV9IG9iamVjdGAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSB7XG4gICAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBhIHZpZXcgb24gYSBTaGFyZWRBcnJheUJ1ZmZlciwgd2hpY2ggaXMgbm90IGFsbG93ZWRcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5QnVmZmVyRGV0YWNoZWQodmFsdWUuYnVmZmVyKSkge1xuICAgICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSB2aWV3IG9uIGEgZGV0YWNoZWQgQXJyYXlCdWZmZXJcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSk7XG5cbi8vIENvbW1vbiBkZWZpbml0aW9uc1xuXG5leHBvcnRzLkFycmF5QnVmZmVyVmlldyA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGlmICghQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIgb3IgU2hhcmVkQXJyYXlCdWZmZXJcIiwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgaXNTaGFyZWRBcnJheUJ1ZmZlcih2YWx1ZS5idWZmZXIpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSB2aWV3IG9uIGEgU2hhcmVkQXJyYXlCdWZmZXIsIHdoaWNoIGlzIG5vdCBhbGxvd2VkXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXJEZXRhY2hlZCh2YWx1ZS5idWZmZXIpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgYSB2aWV3IG9uIGEgZGV0YWNoZWQgQXJyYXlCdWZmZXJcIiwgb3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0cy5CdWZmZXJTb3VyY2UgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIGlmICghb3B0aW9ucy5hbGxvd1NoYXJlZCAmJiBpc1NoYXJlZEFycmF5QnVmZmVyKHZhbHVlLmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgdmlldyBvbiBhIFNoYXJlZEFycmF5QnVmZmVyLCB3aGljaCBpcyBub3QgYWxsb3dlZFwiLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheUJ1ZmZlckRldGFjaGVkKHZhbHVlLmJ1ZmZlcikpIHtcbiAgICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIGEgdmlldyBvbiBhIGRldGFjaGVkIEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgIWlzTm9uU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgdGhyb3cgbWFrZUV4Y2VwdGlvbihUeXBlRXJyb3IsIFwiaXMgbm90IGFuIEFycmF5QnVmZmVyIG9yIGEgdmlldyBvbiBvbmVcIiwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWxsb3dTaGFyZWQgJiYgIWlzU2hhcmVkQXJyYXlCdWZmZXIodmFsdWUpICYmICFpc05vblNoYXJlZEFycmF5QnVmZmVyKHZhbHVlKSkge1xuICAgIHRocm93IG1ha2VFeGNlcHRpb24oVHlwZUVycm9yLCBcImlzIG5vdCBhbiBBcnJheUJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIsIG9yIGEgdmlldyBvbiBvbmVcIiwgb3B0aW9ucyk7XG4gIH1cbiAgaWYgKGlzQXJyYXlCdWZmZXJEZXRhY2hlZCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBtYWtlRXhjZXB0aW9uKFR5cGVFcnJvciwgXCJpcyBhIGRldGFjaGVkIEFycmF5QnVmZmVyXCIsIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuZXhwb3J0cy5ET01UaW1lU3RhbXAgPSBleHBvcnRzW1widW5zaWduZWQgbG9uZyBsb25nXCJdO1xuIl0sIm5hbWVzIjpbIm1ha2VFeGNlcHRpb24iLCJFcnJvclR5cGUiLCJtZXNzYWdlIiwib3B0aW9ucyIsImdsb2JhbHMiLCJuYW1lIiwiY29udGV4dCIsInRvTnVtYmVyIiwidmFsdWUiLCJUeXBlRXJyb3IiLCJOdW1iZXIiLCJldmVuUm91bmQiLCJ4IiwiY2Vuc29yTmVnYXRpdmVaZXJvIiwiTWF0aCIsImZsb29yIiwicm91bmQiLCJpbnRlZ2VyUGFydCIsIm4iLCJ0cnVuYyIsInNpZ24iLCJtb2R1bG8iLCJ5Iiwic2lnbk1pZ2h0Tm90TWF0Y2giLCJjcmVhdGVJbnRlZ2VyQ29udmVyc2lvbiIsImJpdExlbmd0aCIsInVuc2lnbmVkIiwibG93ZXJCb3VuZCIsInVwcGVyQm91bmQiLCJ0d29Ub1RoZUJpdExlbmd0aCIsInR3b1RvT25lTGVzc1RoYW5UaGVCaXRMZW5ndGgiLCJlbmZvcmNlUmFuZ2UiLCJpc0Zpbml0ZSIsImlzTmFOIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJjcmVhdGVMb25nTG9uZ0NvbnZlcnNpb24iLCJNQVhfU0FGRV9JTlRFR0VSIiwiTUlOX1NBRkVfSU5URUdFUiIsImFzQmlnSW50TiIsIkJpZ0ludCIsImFzVWludE4iLCJhc0ludE4iLCJ4QmlnSW50IiwiZXhwb3J0cyIsImFueSIsInVuZGVmaW5lZCIsImJvb2xlYW4iLCJCb29sZWFuIiwiYnl0ZSIsIm9jdGV0Iiwic2hvcnQiLCJsb25nIiwiZG91YmxlIiwiZmxvYXQiLCJPYmplY3QiLCJpcyIsImZyb3VuZCIsIkRPTVN0cmluZyIsInRyZWF0TnVsbEFzRW1wdHlTdHJpbmciLCJTdHJpbmdDdG9yIiwiU3RyaW5nIiwiQnl0ZVN0cmluZyIsImMiLCJpIiwiY29kZVBvaW50QXQiLCJVU1ZTdHJpbmciLCJTIiwibGVuZ3RoIiwiVSIsImNoYXJDb2RlQXQiLCJwdXNoIiwiZnJvbUNvZGVQb2ludCIsImQiLCJhIiwiYiIsImpvaW4iLCJvYmplY3QiLCJhYkJ5dGVMZW5ndGhHZXR0ZXIiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJBcnJheUJ1ZmZlciIsInByb3RvdHlwZSIsImdldCIsInNhYkJ5dGVMZW5ndGhHZXR0ZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsImlzTm9uU2hhcmVkQXJyYXlCdWZmZXIiLCJjYWxsIiwiaXNTaGFyZWRBcnJheUJ1ZmZlciIsImlzQXJyYXlCdWZmZXJEZXRhY2hlZCIsIlVpbnQ4QXJyYXkiLCJhbGxvd1NoYXJlZCIsImR2Qnl0ZUxlbmd0aEdldHRlciIsIkRhdGFWaWV3IiwiZSIsImJ1ZmZlciIsInR5cGVkQXJyYXlOYW1lR2V0dGVyIiwiZ2V0UHJvdG90eXBlT2YiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJJbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiZm9yRWFjaCIsImZ1bmMiLCJhcnRpY2xlIiwidGVzdCIsImlzVmlldyIsIkFycmF5QnVmZmVyVmlldyIsIkJ1ZmZlclNvdXJjZSIsIkRPTVRpbWVTdGFtcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/webidl-conversions/lib/index.js\n");

/***/ })

};
;