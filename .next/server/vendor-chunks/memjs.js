/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/memjs";
exports.ids = ["vendor-chunks/memjs"];
exports.modules = {

/***/ "(ssr)/./node_modules/memjs/lib/memjs/header.js":
/*!************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/header.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// # MemJS Memcache binary protocol header\n// fromBuffer converts a serialized header to a JS object.\nexports.fromBuffer = function(headerBuf) {\n    if (!headerBuf) {\n        return {};\n    }\n    return {\n        magic: headerBuf.readUInt8(0),\n        opcode: headerBuf.readUInt8(1),\n        keyLength: headerBuf.readUInt16BE(2),\n        extrasLength: headerBuf.readUInt8(4),\n        dataType: headerBuf.readUInt8(5),\n        status: headerBuf.readUInt16BE(6),\n        totalBodyLength: headerBuf.readUInt32BE(8),\n        opaque: headerBuf.readUInt32BE(12),\n        cas: headerBuf.slice(16, 24)\n    };\n};\n// toBuffer converts a JS memcache header object to a binary memcache header\nexports.toBuffer = function(header) {\n    var headerBuf = Buffer.alloc(24);\n    headerBuf.fill();\n    headerBuf.writeUInt8(header.magic, 0);\n    headerBuf.writeUInt8(header.opcode, 1);\n    headerBuf.writeUInt16BE(header.keyLength, 2);\n    headerBuf.writeUInt8(header.extrasLength, 4);\n    headerBuf.writeUInt8(header.dataType || 0, 5);\n    headerBuf.writeUInt16BE(header.status || 0, 6);\n    headerBuf.writeUInt32BE(header.totalBodyLength, 8);\n    headerBuf.writeUInt32BE(header.opaque || 0, 12);\n    if (header.cas) {\n        header.cas.copy(headerBuf, 16);\n    } else {\n        headerBuf.fill(\"\\x00\", 16);\n    }\n    return headerBuf;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL2hlYWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSwwQ0FBMEM7QUFFMUMsMERBQTBEO0FBQzFEQSxrQkFBa0IsR0FBRyxTQUFTRSxTQUFTO0lBQ3JDLElBQUksQ0FBQ0EsV0FBVztRQUNkLE9BQU8sQ0FBQztJQUNWO0lBQ0EsT0FBTztRQUNMQyxPQUFpQkQsVUFBVUUsU0FBUyxDQUFDO1FBQ3JDQyxRQUFpQkgsVUFBVUUsU0FBUyxDQUFDO1FBQ3JDRSxXQUFpQkosVUFBVUssWUFBWSxDQUFDO1FBQ3hDQyxjQUFpQk4sVUFBVUUsU0FBUyxDQUFDO1FBQ3JDSyxVQUFpQlAsVUFBVUUsU0FBUyxDQUFDO1FBQ3JDTSxRQUFpQlIsVUFBVUssWUFBWSxDQUFDO1FBQ3hDSSxpQkFBaUJULFVBQVVVLFlBQVksQ0FBQztRQUN4Q0MsUUFBaUJYLFVBQVVVLFlBQVksQ0FBQztRQUN4Q0UsS0FBaUJaLFVBQVVhLEtBQUssQ0FBQyxJQUFJO0lBQ3ZDO0FBQ0Y7QUFFQSw0RUFBNEU7QUFDNUVmLGdCQUFnQixHQUFHLFNBQVNpQixNQUFNO0lBQ2hDLElBQUlmLFlBQVlnQixPQUFPQyxLQUFLLENBQUM7SUFDN0JqQixVQUFVa0IsSUFBSTtJQUNkbEIsVUFBVW1CLFVBQVUsQ0FBQ0osT0FBT2QsS0FBSyxFQUFFO0lBQ25DRCxVQUFVbUIsVUFBVSxDQUFDSixPQUFPWixNQUFNLEVBQUU7SUFDcENILFVBQVVvQixhQUFhLENBQUNMLE9BQU9YLFNBQVMsRUFBRTtJQUMxQ0osVUFBVW1CLFVBQVUsQ0FBQ0osT0FBT1QsWUFBWSxFQUFFO0lBQzFDTixVQUFVbUIsVUFBVSxDQUFDSixPQUFPUixRQUFRLElBQUksR0FBRztJQUMzQ1AsVUFBVW9CLGFBQWEsQ0FBQ0wsT0FBT1AsTUFBTSxJQUFJLEdBQUc7SUFDNUNSLFVBQVVxQixhQUFhLENBQUNOLE9BQU9OLGVBQWUsRUFBRTtJQUNoRFQsVUFBVXFCLGFBQWEsQ0FBQ04sT0FBT0osTUFBTSxJQUFJLEdBQUc7SUFDNUMsSUFBSUksT0FBT0gsR0FBRyxFQUFFO1FBQ2RHLE9BQU9ILEdBQUcsQ0FBQ1UsSUFBSSxDQUFDdEIsV0FBVztJQUM3QixPQUFPO1FBQ0xBLFVBQVVrQixJQUFJLENBQUMsUUFBUTtJQUN6QjtJQUNBLE9BQU9sQjtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9tZW1qcy9saWIvbWVtanMvaGVhZGVyLmpzPzZmZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gIyBNZW1KUyBNZW1jYWNoZSBiaW5hcnkgcHJvdG9jb2wgaGVhZGVyXG5cbi8vIGZyb21CdWZmZXIgY29udmVydHMgYSBzZXJpYWxpemVkIGhlYWRlciB0byBhIEpTIG9iamVjdC5cbmV4cG9ydHMuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uKGhlYWRlckJ1Zikge1xuICBpZiAoIWhlYWRlckJ1Zikge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG1hZ2ljOiAgICAgICAgICAgaGVhZGVyQnVmLnJlYWRVSW50OCgwKSxcbiAgICBvcGNvZGU6ICAgICAgICAgIGhlYWRlckJ1Zi5yZWFkVUludDgoMSksXG4gICAga2V5TGVuZ3RoOiAgICAgICBoZWFkZXJCdWYucmVhZFVJbnQxNkJFKDIpLFxuICAgIGV4dHJhc0xlbmd0aDogICAgaGVhZGVyQnVmLnJlYWRVSW50OCg0KSxcbiAgICBkYXRhVHlwZTogICAgICAgIGhlYWRlckJ1Zi5yZWFkVUludDgoNSksXG4gICAgc3RhdHVzOiAgICAgICAgICBoZWFkZXJCdWYucmVhZFVJbnQxNkJFKDYpLFxuICAgIHRvdGFsQm9keUxlbmd0aDogaGVhZGVyQnVmLnJlYWRVSW50MzJCRSg4KSxcbiAgICBvcGFxdWU6ICAgICAgICAgIGhlYWRlckJ1Zi5yZWFkVUludDMyQkUoMTIpLFxuICAgIGNhczogICAgICAgICAgICAgaGVhZGVyQnVmLnNsaWNlKDE2LCAyNClcbiAgfTtcbn07XG5cbi8vIHRvQnVmZmVyIGNvbnZlcnRzIGEgSlMgbWVtY2FjaGUgaGVhZGVyIG9iamVjdCB0byBhIGJpbmFyeSBtZW1jYWNoZSBoZWFkZXJcbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbihoZWFkZXIpIHtcbiAgdmFyIGhlYWRlckJ1ZiA9IEJ1ZmZlci5hbGxvYygyNCk7XG4gIGhlYWRlckJ1Zi5maWxsKCk7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQ4KGhlYWRlci5tYWdpYywgMCk7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQ4KGhlYWRlci5vcGNvZGUsIDEpO1xuICBoZWFkZXJCdWYud3JpdGVVSW50MTZCRShoZWFkZXIua2V5TGVuZ3RoLCAyKTtcbiAgaGVhZGVyQnVmLndyaXRlVUludDgoaGVhZGVyLmV4dHJhc0xlbmd0aCwgNCk7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQ4KGhlYWRlci5kYXRhVHlwZSB8fCAwLCA1KTtcbiAgaGVhZGVyQnVmLndyaXRlVUludDE2QkUoaGVhZGVyLnN0YXR1cyB8fCAwLCA2KTtcbiAgaGVhZGVyQnVmLndyaXRlVUludDMyQkUoaGVhZGVyLnRvdGFsQm9keUxlbmd0aCwgOCk7XG4gIGhlYWRlckJ1Zi53cml0ZVVJbnQzMkJFKGhlYWRlci5vcGFxdWUgfHwgMCwgMTIpO1xuICBpZiAoaGVhZGVyLmNhcykge1xuICAgIGhlYWRlci5jYXMuY29weShoZWFkZXJCdWYsIDE2KTtcbiAgfSBlbHNlIHtcbiAgICBoZWFkZXJCdWYuZmlsbCgnXFx4MDAnLCAxNik7XG4gIH1cbiAgcmV0dXJuIGhlYWRlckJ1Zjtcbn07XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsImZyb21CdWZmZXIiLCJoZWFkZXJCdWYiLCJtYWdpYyIsInJlYWRVSW50OCIsIm9wY29kZSIsImtleUxlbmd0aCIsInJlYWRVSW50MTZCRSIsImV4dHJhc0xlbmd0aCIsImRhdGFUeXBlIiwic3RhdHVzIiwidG90YWxCb2R5TGVuZ3RoIiwicmVhZFVJbnQzMkJFIiwib3BhcXVlIiwiY2FzIiwic2xpY2UiLCJ0b0J1ZmZlciIsImhlYWRlciIsIkJ1ZmZlciIsImFsbG9jIiwiZmlsbCIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJCRSIsImNvcHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/memjs/lib/memjs/header.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/memjs/lib/memjs/memjs.js":
/*!***********************************************!*\
  !*** ./node_modules/memjs/lib/memjs/memjs.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// # MemJS Memcache Client\nvar errors = (__webpack_require__(/*! ./protocol */ \"(ssr)/./node_modules/memjs/lib/memjs/protocol.js\").errors);\nvar Server = (__webpack_require__(/*! ./server */ \"(ssr)/./node_modules/memjs/lib/memjs/server.js\").Server);\nvar noopSerializer = (__webpack_require__(/*! ./noop-serializer */ \"(ssr)/./node_modules/memjs/lib/memjs/noop-serializer.js\").noopSerializer);\nvar makeRequestBuffer = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").makeRequestBuffer);\nvar hashCode = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").hashCode);\nvar merge = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").merge);\nvar makeExpiration = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").makeExpiration);\nvar makeAmountInitialAndExpiration = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").makeAmountInitialAndExpiration);\n// Client initializer takes a list of `Server`s and an `options` dictionary.\n// See `Client.create` for details.\nvar Client = function(servers, options) {\n    this.servers = servers;\n    this.seq = 0;\n    this.options = merge(options || {}, {\n        failoverTime: 60,\n        retries: 2,\n        retry_delay: 0.2,\n        expires: 0,\n        logger: console\n    });\n    this.serializer = this.options.serializer || noopSerializer;\n};\n// Creates a new client given an optional config string and optional hash of\n// options. The config string should be of the form:\n//\n//     \"[user:pass@]server1[:11211],[user:pass@]server2[:11211],...\"\n//\n// If the argument is not given, fallback on the `MEMCACHIER_SERVERS` environment\n// variable, `MEMCACHE_SERVERS` environment variable or `\"localhost:11211\"`.\n//\n// The options hash may contain the options:\n//\n// * `retries` - the number of times to retry an operation in lieu of failures\n// (default 2)\n// * `expires` - the default expiration in seconds to use (default 0 - never\n// expire). If `expires` is greater than 30 days (60 x 60 x 24 x 30), it is\n// treated as a UNIX time (number of seconds since January 1, 1970).\n// * `logger` - a logger object that responds to `log(string)` method calls.\n// * `failover` - whether to failover to next server. Defaults to false.\n// * `failoverTime` - how much to wait until retring a failed server. Default\n//                    is 60 seconds.\n//\n//   ~~~~\n//     log(msg1[, msg2[, msg3[...]]])\n//   ~~~~\n//\n//   Defaults to `console`.\n// * `serializer` - the object which will (de)serialize the data. It needs\n//   two public methods: serialize and deserialize. It defaults to the \n//   noopSerializer:\n//\n//   ~~~~\n//   var noopSerializer = {\n//     serialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     },\n//     deserialize: function (opcode, value, extras) {\n//       return { value: value, extras: extras };\n//     }\n//   };\n//   ~~~~\n//\n// Or options for the servers including:\n// * `username` and `password` for fallback SASL authentication credentials.\n// * `timeout` in seconds to determine failure for operations. Default is 0.5\n//             seconds.\n// * 'conntimeout' in seconds to connection failure. Default is twice the value\n//                 of `timeout`.\n// * `keepAlive` whether to enable keep-alive functionality. Defaults to false.\n// * `keepAliveDelay` in seconds to the initial delay before the first keepalive\n//                    probe is sent on an idle socket. Defaults is 30 seconds.\nClient.create = function(serversStr, options) {\n    serversStr = serversStr || process.env.MEMCACHIER_SERVERS || process.env.MEMCACHE_SERVERS || \"localhost:11211\";\n    var serverUris = serversStr.split(\",\");\n    var servers = serverUris.map(function(uri) {\n        var uriParts = uri.split(\"@\");\n        var hostPort = uriParts[uriParts.length - 1].split(\":\");\n        var userPass = (uriParts[uriParts.length - 2] || \"\").split(\":\");\n        return new Server(hostPort[0], parseInt(hostPort[1] || 11211, 10), userPass[0], userPass[1], options);\n    });\n    return new Client(servers, options);\n};\n// An overridable method you can use for determing\n// server selection. Should return the server index\n// in the list of servers on Client#servers.\n// \n//   Example using node-hashring:\n//   ~~~~\n//   const memjs = require('memjs');\n//   const HashRing = require('node-hashring');\n//   const servers = ['localhost:11211', 'localhost:11212'];\n//   // build a map of server addresses to their index in the server list\n//   const serverMap = {};\n//   servers.forEach((server, index) => serverMap[server] = index);\n//   const client = memjs.Client.create(servers.join(','));\n//   // build the hashring\n//   const hashRing = new HashRing(servers);\n//   // override the getServer method\n//   client.getServer = (key) => serverMap[hashRing.findNode(key)];\n//   ~~~~\nClient.prototype.getServer = function(key) {\n    return hashCode(key) % this.servers.length;\n};\n// Chooses the server to talk to by hashing the given key.\nClient.prototype.server = function(key) {\n    // mechanisms\n    var total = this.servers.length;\n    var origIdx = total > 1 ? this.getServer(key) : 0;\n    var idx = origIdx;\n    var serv = this.servers[idx];\n    while(serv.wakeupAt && serv.wakeupAt > Date.now()){\n        idx = (idx + 1) % total;\n        if (idx === origIdx) {\n            return null;\n        }\n        serv = this.servers[idx];\n    }\n    return serv;\n};\n// converts a call into a promise-returning one\nvar promisify = function(command) {\n    return new Promise(function(resolve, reject) {\n        command(function(err, result) {\n            err ? reject(err) : resolve(result);\n        });\n    });\n};\n// ## Memcache Commands\n//\n// All commands return their results through a callback passed as the last\n// required argument (some commands, like `Client#set`, take optional arguments\n// after the callback).\n//\n// The callback signature always follows:\n//\n//     callback(err, [arg1[, arg2[, arg3[...]]]])\n//\n// In case of an error the _err_ argument will be non-null and contain the\n// `Error`. A notable exception includes a `Client#get` on a key that doesn't\n// exist. In this case, _err_ will be null, as will the _value and _extras_\n// arguments.\n// GET\n//\n// Retrieves the value at the given key in memcache.\n//\n// The callback signature is:\n//\n//     callback(err, value, flags)\n//\n// _value_ and _flags_ are both `Buffer`s. If the key is not found, the\n// callback is invoked with null for both arguments and no error.\nClient.prototype.get = function(key, callback) {\n    var self = this;\n    if (callback === undefined) {\n        return promisify(function(callback) {\n            self.get(key, function(err, value, flags) {\n                callback(err, {\n                    value: value,\n                    flags: flags\n                });\n            });\n        });\n    }\n    var logger = this.options.logger;\n    this.incrSeq();\n    var request = makeRequestBuffer(0, key, \"\", \"\", this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    var deserialized = self.serializer.deserialize(response.header.opcode, response.val, response.extras);\n                    callback(null, deserialized.value, deserialized.extras);\n                }\n                break;\n            case 1:\n                if (callback) {\n                    callback(null, null, null);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS GET: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null, null);\n                }\n        }\n    });\n};\n// SET\n//\n// Sets the given _key_ and _value_ in memcache.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.set = function(key, value, options, callback) {\n    if (callback === undefined && typeof options !== \"function\") {\n        var self = this;\n        if (!options) options = {};\n        return promisify(function(callback) {\n            self.set(key, value, options, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    var logger = this.options.logger;\n    var expires;\n    if (typeof options === \"function\" || typeof callback === \"number\") {\n        // OLD: function(key, value, callback, expires)\n        logger.log(\"MemJS SET: using deprecated call - arguments have changed\");\n        expires = callback;\n        callback = options;\n        options = {};\n    }\n    logger = this.options.logger;\n    expires = options.expires;\n    // TODO: support flags, support version (CAS)\n    this.incrSeq();\n    var expiration = makeExpiration(expires || this.options.expires);\n    var extras = Buffer.concat([\n        Buffer.from(\"00000000\", \"hex\"),\n        expiration\n    ]);\n    var opcode = 1;\n    var serialized = this.serializer.serialize(opcode, value, extras);\n    var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS SET: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null, null);\n                }\n        }\n    });\n};\n// ADD\n//\n// Adds the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is not already set.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.add = function(key, value, options, callback) {\n    if (callback === undefined && typeof options !== \"function\") {\n        var self = this;\n        if (!options) options = {};\n        return promisify(function(callback) {\n            self.add(key, value, options, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    var logger = this.options.logger;\n    var expires;\n    if (typeof options === \"function\") {\n        // OLD: function(key, value, callback, expires)\n        logger.log(\"MemJS ADD: using deprecated call - arguments have changed\");\n        expires = callback;\n        callback = options;\n        options = {};\n    }\n    logger = this.options.logger;\n    expires = options.expires;\n    // TODO: support flags, support version (CAS)\n    this.incrSeq();\n    var expiration = makeExpiration(expires || this.options.expires);\n    var extras = Buffer.concat([\n        Buffer.from(\"00000000\", \"hex\"),\n        expiration\n    ]);\n    var opcode = 2;\n    var serialized = this.serializer.serialize(opcode, value, extras);\n    var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            case 2:\n                if (callback) {\n                    callback(null, false);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS ADD: \" + errors[response.header.status];\n                logger.log(errorMessage, false);\n                if (callback) {\n                    callback(new Error(errorMessage), null, null);\n                }\n        }\n    });\n};\n// REPLACE\n//\n// Replaces the given _key_ and _value_ to memcache. The operation only succeeds\n// if the key is already present.\n//\n// The options dictionary takes:\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.replace = function(key, value, options, callback) {\n    if (callback === undefined && typeof options !== \"function\") {\n        var self = this;\n        if (!options) options = {};\n        return promisify(function(callback) {\n            self.replace(key, value, options, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    var logger = this.options.logger;\n    var expires;\n    if (typeof options === \"function\") {\n        // OLD: function(key, value, callback, expires)\n        logger.log(\"MemJS REPLACE: using deprecated call - arguments have changed\");\n        expires = callback;\n        callback = options;\n        options = {};\n    }\n    logger = this.options.logger;\n    expires = options.expires;\n    // TODO: support flags, support version (CAS)\n    this.incrSeq();\n    var expiration = makeExpiration(expires || this.options.expires);\n    var extras = Buffer.concat([\n        Buffer.from(\"00000000\", \"hex\"),\n        expiration\n    ]);\n    var opcode = 3;\n    var serialized = this.serializer.serialize(opcode, value, extras);\n    var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            case 1:\n                if (callback) {\n                    callback(null, false);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS REPLACE: \" + errors[response.header.status];\n                logger.log(errorMessage, false);\n                if (callback) {\n                    callback(new Error(errorMessage), null, null);\n                }\n        }\n    });\n};\n// DELETE\n//\n// Deletes the given _key_ from memcache. The operation only succeeds\n// if the key is already present.\n//\n// The callback signature is:\n//\n//     callback(err, success)\nClient.prototype.delete = function(key, callback) {\n    if (callback === undefined) {\n        var self = this;\n        return promisify(function(callback) {\n            self.delete(key, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    // TODO: Support version (CAS)\n    var logger = this.options.logger;\n    this.incrSeq();\n    var request = makeRequestBuffer(4, key, \"\", \"\", this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            case 1:\n                if (callback) {\n                    callback(null, false);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS DELETE: \" + errors[response.header.status];\n                logger.log(errorMessage, false);\n                if (callback) {\n                    callback(new Error(errorMessage), null);\n                }\n        }\n    });\n};\n// INCREMENT\n//\n// Increments the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.increment = function(key, amount, options, callback) {\n    if (callback === undefined && typeof options !== \"function\") {\n        var self = this;\n        return promisify(function(callback) {\n            if (!options) options = {};\n            self.increment(key, amount, options, function(err, success, value) {\n                callback(err, {\n                    success: success,\n                    value: value\n                });\n            });\n        });\n    }\n    var logger = this.options.logger;\n    var initial;\n    var expires;\n    if (typeof options === \"function\") {\n        // OLD: function(key, amount, callback, expires, initial)\n        logger.log(\"MemJS INCREMENT: using deprecated call - arguments have changed\");\n        initial = arguments[4];\n        expires = callback;\n        callback = options;\n        options = {};\n    }\n    logger = this.options.logger;\n    initial = options.initial;\n    expires = options.expires;\n    // TODO: support version (CAS)\n    this.incrSeq();\n    initial = initial || 0;\n    expires = expires || this.options.expires;\n    var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n    var request = makeRequestBuffer(5, key, extras, \"\", this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n                if (callback) {\n                    callback(null, true, bufInt);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS INCREMENT: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null, null);\n                }\n        }\n    });\n};\n// DECREMENT\n//\n// Decrements the given _key_ in memcache.\n//\n// The options dictionary takes:\n// * _initial_: the value for the key if not already present, defaults to 0.\n// * _expires_: overrides the default expiration (see `Client.create`) for this\n//              particular key-value pair.\n//\n// The callback signature is:\n//\n//     callback(err, success, value)\nClient.prototype.decrement = function(key, amount, options, callback) {\n    if (callback === undefined && typeof options !== \"function\") {\n        var self = this;\n        return promisify(function(callback) {\n            self.decrement(key, amount, options, function(err, success, value) {\n                callback(err, {\n                    success: success,\n                    value: value\n                });\n            });\n        });\n    }\n    // TODO: support version (CAS)\n    var logger = this.options.logger;\n    var initial;\n    var expires;\n    if (typeof options === \"function\") {\n        // OLD: function(key, amount, callback, expires, initial)\n        logger.log(\"MemJS DECREMENT: using deprecated call - arguments have changed\");\n        initial = arguments[4];\n        expires = callback;\n        callback = options;\n        options = {};\n    }\n    // TODO: support version (CAS)\n    logger = this.options.logger;\n    initial = options.initial;\n    expires = options.expires;\n    this.incrSeq();\n    initial = initial || 0;\n    expires = expires || this.options.expires;\n    var extras = makeAmountInitialAndExpiration(amount, initial, expires);\n    var request = makeRequestBuffer(6, key, extras, \"\", this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                var bufInt = (response.val.readUInt32BE(0) << 8) + response.val.readUInt32BE(4);\n                if (callback) {\n                    callback(null, true, bufInt);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS DECREMENT: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null, null);\n                }\n        }\n    });\n};\n// APPEND\n//\n// Append the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.append = function(key, value, callback) {\n    if (callback === undefined) {\n        var self = this;\n        return promisify(function(callback) {\n            self.append(key, value, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    // TODO: support version (CAS)\n    var logger = this.options.logger;\n    this.incrSeq();\n    var opcode = 0x0E;\n    var serialized = this.serializer.serialize(opcode, value, \"\");\n    var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            case 1:\n                if (callback) {\n                    callback(null, false);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS APPEND: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null);\n                }\n        }\n    });\n};\n// PREPEND\n//\n// Prepend the given _value_ to the value associated with the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.prepend = function(key, value, callback) {\n    if (callback === undefined) {\n        var self = this;\n        return promisify(function(callback) {\n            self.prepend(key, value, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    // TODO: support version (CAS)\n    var logger = this.options.logger;\n    this.incrSeq();\n    var opcode = 0x0E;\n    var serialized = this.serializer.serialize(opcode, value, \"\");\n    var request = makeRequestBuffer(opcode, key, serialized.extras, serialized.value, this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            case 1:\n                if (callback) {\n                    callback(null, false);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS PREPEND: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null);\n                }\n        }\n    });\n};\n// TOUCH\n//\n// Touch sets an expiration value, given by _expires_, on the given _key_ in\n// memcache. The operation only succeeds if the key is already present. The\n// callback signature is:\n//\n//     callback(err, success)\nClient.prototype.touch = function(key, expires, callback) {\n    if (callback === undefined) {\n        var self = this;\n        return promisify(function(callback) {\n            self.touch(key, expires, function(err, success) {\n                callback(err, success);\n            });\n        });\n    }\n    // TODO: support version (CAS)\n    var logger = this.options.logger;\n    this.incrSeq();\n    var extras = makeExpiration(expires || this.options.expires);\n    var request = makeRequestBuffer(0x1C, key, extras, \"\", this.seq);\n    this.perform(key, request, this.seq, function(err, response) {\n        if (err) {\n            if (callback) {\n                callback(err, null);\n            }\n            return;\n        }\n        switch(response.header.status){\n            case 0:\n                if (callback) {\n                    callback(null, true);\n                }\n                break;\n            case 1:\n                if (callback) {\n                    callback(null, false);\n                }\n                break;\n            default:\n                var errorMessage = \"MemJS TOUCH: \" + errors[response.header.status];\n                logger.log(errorMessage);\n                if (callback) {\n                    callback(new Error(errorMessage), null);\n                }\n        }\n    });\n};\n// FLUSH\n//\n// Flushes the cache on each connected server. The callback signature is:\n//\n//     callback(lastErr, results)\n//\n// where _lastErr_ is the last error encountered (or null, in the common case\n// of no errors). _results_ is a dictionary mapping `\"hostname:port\"` to either\n// `true` (if the operation was successful), or an error.\nClient.prototype.flush = function(callback) {\n    if (callback === undefined) {\n        var self = this;\n        return promisify(function(callback) {\n            self.flush(function(err, results) {\n                callback(err, results);\n            });\n        });\n    }\n    // TODO: support expiration\n    this.incrSeq();\n    var request = makeRequestBuffer(0x08, \"\", \"\", \"\", this.seq);\n    var count = this.servers.length;\n    var result = {};\n    var lastErr = null;\n    var i;\n    var handleFlush = function(seq, serv) {\n        serv.onResponse(seq, function() {\n            count -= 1;\n            result[serv.host + \":\" + serv.port] = true;\n            if (callback && count === 0) {\n                callback(lastErr, result);\n            }\n        });\n        serv.onError(seq, function(err) {\n            count -= 1;\n            lastErr = err;\n            result[serv.host + \":\" + serv.port] = err;\n            if (callback && count === 0) {\n                callback(lastErr, result);\n            }\n        });\n        serv.write(request);\n    };\n    for(i = 0; i < this.servers.length; i++){\n        handleFlush(this.seq, this.servers[i]);\n    }\n};\n// STATS_WITH_KEY\n//\n// Sends a memcache stats command with a key to each connected server. The\n// callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a dictionary\n// mapping the stat name to the value of the statistic as a string.\nClient.prototype.statsWithKey = function(key, callback) {\n    var logger = this.options.logger;\n    this.incrSeq();\n    var request = makeRequestBuffer(0x10, key, \"\", \"\", this.seq);\n    var i;\n    var handleStats = function(seq, serv) {\n        var result = {};\n        var handle = function(response) {\n            // end of stat responses\n            if (response.header.totalBodyLength === 0) {\n                if (callback) {\n                    callback(null, serv.host + \":\" + serv.port, result);\n                }\n                return;\n            }\n            // process single stat line response\n            switch(response.header.status){\n                case 0:\n                    result[response.key.toString()] = response.val.toString();\n                    break;\n                default:\n                    var errorMessage = \"MemJS STATS (\" + key + \"): \" + errors[response.header.status];\n                    logger.log(errorMessage, false);\n                    if (callback) {\n                        callback(new Error(errorMessage), serv.host + \":\" + serv.port, null);\n                    }\n            }\n        };\n        handle.quiet = true;\n        serv.onResponse(seq, handle);\n        serv.onError(seq, function(err) {\n            if (callback) {\n                callback(err, serv.host + \":\" + serv.port, null);\n            }\n        });\n        serv.write(request);\n    };\n    for(i = 0; i < this.servers.length; i++){\n        handleStats(this.seq, this.servers[i]);\n    }\n};\n// STATS\n//\n// Fetches memcache stats from each connected server. The callback is invoked\n// **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server, stats)\n//\n// _server_ is the `\"hostname:port\"` of the server, and _stats_ is a\n// dictionary mapping the stat name to the value of the statistic as a string.\nClient.prototype.stats = function(callback) {\n    this.statsWithKey(\"\", callback);\n};\n// RESET_STATS\n//\n// Reset the statistics each server is keeping back to zero. This doesn't clear\n// stats such as item count, but temporary stats such as total number of\n// connections over time.\n//\n// The callback is invoked **ONCE PER SERVER** and has the signature:\n//\n//     callback(err, server)\n//\n// _server_ is the `\"hostname:port\"` of the server.\nClient.prototype.resetStats = function(callback) {\n    this.statsWithKey(\"reset\", callback);\n};\n// QUIT\n//\n// Closes the connection to each server, notifying them of this intention. Note\n// that quit can race against already outstanding requests when those requests\n// fail and are retried, leading to the quit command winning and closing the\n// connection before the retries complete.\nClient.prototype.quit = function() {\n    this.incrSeq();\n    // TODO: Nicer perhaps to do QUITQ (0x17) but need a new callback for when\n    // write is done.\n    var request = makeRequestBuffer(0x07, \"\", \"\", \"\", this.seq); // QUIT\n    var serv;\n    var i;\n    var handleQuit = function(seq, serv) {\n        serv.onResponse(seq, function() {\n            serv.close();\n        });\n        serv.onError(seq, function() {\n            serv.close();\n        });\n        serv.write(request);\n    };\n    for(i = 0; i < this.servers.length; i++){\n        serv = this.servers[i];\n        handleQuit(this.seq, serv);\n    }\n};\n// CLOSE\n//\n// Closes (abruptly) connections to all the servers.\nClient.prototype.close = function() {\n    var i;\n    for(i = 0; i < this.servers.length; i++){\n        this.servers[i].close();\n    }\n};\n// Perform a generic single response operation (get, set etc) on a server\n// serv: the server to perform the operation on\n// request: a buffer containing the request\n// seq: the sequence number of the operation. It is used to pin the callbacks\n//      to a specific operation and should never change during a `perform`.\n// callback: a callback invoked when a response is received or the request\n//           fails\n// retries: number of times to retry request on failure\nClient.prototype.perform = function(key, request, seq, callback, retries) {\n    var _this = this;\n    var serv = this.server(key);\n    if (!serv) {\n        if (callback) {\n            callback(new Error(\"No servers available\"), null);\n        }\n        return;\n    }\n    retries = retries || this.options.retries;\n    var failover = this.options.failover;\n    var failoverTime = this.options.failoverTime;\n    var origRetries = this.options.retries;\n    var logger = this.options.logger;\n    var retry_delay = this.options.retry_delay;\n    var responseHandler = function(response) {\n        if (callback) {\n            callback(null, response);\n        }\n    };\n    var errorHandler = function(error) {\n        if (--retries > 0) {\n            // Wait for retry_delay\n            setTimeout(function() {\n                _this.perform(key, request, seq, callback, retries);\n            }, 1000 * retry_delay);\n        } else {\n            logger.log(\"MemJS: Server <\" + serv.host + \":\" + serv.port + \"> failed after (\" + origRetries + \") retries with error - \" + error.message);\n            if (failover) {\n                serv.wakeupAt = Date.now() + failoverTime * 1000;\n                _this.perform(key, request, seq, callback, origRetries);\n            } else {\n                if (callback) {\n                    callback(error, null);\n                }\n            }\n        }\n    };\n    serv.onResponse(seq, responseHandler);\n    serv.onError(seq, errorHandler);\n    serv.write(request);\n};\n// Increment the seq value\nClient.prototype.incrSeq = function() {\n    this.seq++;\n    // Wrap `this.seq` to 32-bits since the field we fit it into is only 32-bits.\n    this.seq &= 0xffffffff;\n};\nexports.Client = Client;\nexports.Server = Server;\nexports.Utils = __webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\");\nexports.Header = __webpack_require__(/*! ./header */ \"(ssr)/./node_modules/memjs/lib/memjs/header.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL21lbWpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBCQUEwQjtBQUUxQixJQUFJQSxTQUFTQyxrR0FBNEI7QUFDekMsSUFBSUMsU0FBU0QsOEZBQTBCO0FBQ3ZDLElBQUlFLGlCQUFpQkYsd0hBQTJDO0FBQ2hFLElBQUlHLG9CQUFvQkgsdUdBQW9DO0FBQzVELElBQUlJLFdBQVdKLDhGQUEyQjtBQUMxQyxJQUFJSyxRQUFRTCwyRkFBd0I7QUFDcEMsSUFBSU0saUJBQWlCTixvR0FBaUM7QUFDdEQsSUFBSU8saUNBQWlDUCxvSEFBaUQ7QUFFdEYsNEVBQTRFO0FBQzVFLG1DQUFtQztBQUNuQyxJQUFJUSxTQUFTLFNBQVNDLE9BQU8sRUFBRUMsT0FBTztJQUNwQyxJQUFJLENBQUNELE9BQU8sR0FBR0E7SUFDZixJQUFJLENBQUNFLEdBQUcsR0FBRztJQUNYLElBQUksQ0FBQ0QsT0FBTyxHQUFHTCxNQUFNSyxXQUFXLENBQUMsR0FDL0I7UUFBQ0UsY0FBYztRQUFJQyxTQUFTO1FBQUdDLGFBQWE7UUFBS0MsU0FBUztRQUFHQyxRQUFRQztJQUFPO0lBRTlFLElBQUksQ0FBQ0MsVUFBVSxHQUFHLElBQUksQ0FBQ1IsT0FBTyxDQUFDUSxVQUFVLElBQUloQjtBQUMvQztBQUVBLDRFQUE0RTtBQUM1RSxvREFBb0Q7QUFDcEQsRUFBRTtBQUNGLG9FQUFvRTtBQUNwRSxFQUFFO0FBQ0YsaUZBQWlGO0FBQ2pGLDRFQUE0RTtBQUM1RSxFQUFFO0FBQ0YsNENBQTRDO0FBQzVDLEVBQUU7QUFDRiw4RUFBOEU7QUFDOUUsY0FBYztBQUNkLDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usb0VBQW9FO0FBQ3BFLDRFQUE0RTtBQUM1RSx3RUFBd0U7QUFDeEUsNkVBQTZFO0FBQzdFLG9DQUFvQztBQUNwQyxFQUFFO0FBQ0YsU0FBUztBQUNULHFDQUFxQztBQUNyQyxTQUFTO0FBQ1QsRUFBRTtBQUNGLDJCQUEyQjtBQUMzQiww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QUFVLEdBQUc7WUFDakIsdUJBQXVCO1lBQ3ZCNEcsV0FBVztnQkFDVE4sTUFBTXZELE9BQU8sQ0FBQ3hCLEtBQUt1QixTQUFTaEQsS0FBSzBDLFVBQVV4QztZQUM3QyxHQUFHLE9BQU9DO1FBQ1osT0FBTztZQUNMRSxPQUFPc0QsR0FBRyxDQUFDLG9CQUFvQjdCLEtBQUsyRCxJQUFJLEdBQUcsTUFBTTNELEtBQUs0RCxJQUFJLEdBQzlDLHFCQUFxQmdCLGNBQ3JCLDRCQUE0QkcsTUFBTUUsT0FBTztZQUNyRCxJQUFJTixVQUFVO2dCQUNaM0UsS0FBS0MsUUFBUSxHQUFHQyxLQUFLQyxHQUFHLEtBQUtoQyxlQUFlO2dCQUM1Q3VHLE1BQU12RCxPQUFPLENBQUN4QixLQUFLdUIsU0FBU2hELEtBQUswQyxVQUFVZ0U7WUFDN0MsT0FBTztnQkFDTCxJQUFJaEUsVUFBVTtvQkFBRUEsU0FBU21FLE9BQU87Z0JBQU87WUFDekM7UUFDRjtJQUNGO0lBRUEvRSxLQUFLMEQsVUFBVSxDQUFDeEYsS0FBSzJHO0lBQ3JCN0UsS0FBSzZELE9BQU8sQ0FBQzNGLEtBQUs0RztJQUNsQjlFLEtBQUs4RCxLQUFLLENBQUM1QztBQUNiO0FBRUEsMEJBQTBCO0FBQzFCbkQsT0FBTzBCLFNBQVMsQ0FBQ3dCLE9BQU8sR0FBRztJQUN6QixJQUFJLENBQUMvQyxHQUFHO0lBRVIsNkVBQTZFO0lBQzdFLElBQUksQ0FBQ0EsR0FBRyxJQUFJO0FBQ2Q7QUFFQWdILGNBQWMsR0FBR25IO0FBQ2pCbUgsY0FBYyxHQUFHMUg7QUFDakIwSCxtR0FBd0I7QUFDeEJBLHNHQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpb25lei1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL21lbWpzLmpzP2I1MmMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gIyBNZW1KUyBNZW1jYWNoZSBDbGllbnRcblxudmFyIGVycm9ycyA9IHJlcXVpcmUoJy4vcHJvdG9jb2wnKS5lcnJvcnM7XG52YXIgU2VydmVyID0gcmVxdWlyZSgnLi9zZXJ2ZXInKS5TZXJ2ZXI7XG52YXIgbm9vcFNlcmlhbGl6ZXIgPSByZXF1aXJlKCcuL25vb3Atc2VyaWFsaXplcicpLm5vb3BTZXJpYWxpemVyO1xudmFyIG1ha2VSZXF1ZXN0QnVmZmVyID0gcmVxdWlyZSgnLi91dGlscycpLm1ha2VSZXF1ZXN0QnVmZmVyO1xudmFyIGhhc2hDb2RlID0gcmVxdWlyZSgnLi91dGlscycpLmhhc2hDb2RlO1xudmFyIG1lcmdlID0gcmVxdWlyZSgnLi91dGlscycpLm1lcmdlO1xudmFyIG1ha2VFeHBpcmF0aW9uID0gcmVxdWlyZSgnLi91dGlscycpLm1ha2VFeHBpcmF0aW9uO1xudmFyIG1ha2VBbW91bnRJbml0aWFsQW5kRXhwaXJhdGlvbiA9IHJlcXVpcmUoJy4vdXRpbHMnKS5tYWtlQW1vdW50SW5pdGlhbEFuZEV4cGlyYXRpb247XG5cbi8vIENsaWVudCBpbml0aWFsaXplciB0YWtlcyBhIGxpc3Qgb2YgYFNlcnZlcmBzIGFuZCBhbiBgb3B0aW9uc2AgZGljdGlvbmFyeS5cbi8vIFNlZSBgQ2xpZW50LmNyZWF0ZWAgZm9yIGRldGFpbHMuXG52YXIgQ2xpZW50ID0gZnVuY3Rpb24oc2VydmVycywgb3B0aW9ucykge1xuICB0aGlzLnNlcnZlcnMgPSBzZXJ2ZXJzO1xuICB0aGlzLnNlcSA9IDA7XG4gIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMgfHwge30sXG4gICAge2ZhaWxvdmVyVGltZTogNjAsIHJldHJpZXM6IDIsIHJldHJ5X2RlbGF5OiAwLjIsIGV4cGlyZXM6IDAsIGxvZ2dlcjogY29uc29sZX0pO1xuXG4gIHRoaXMuc2VyaWFsaXplciA9IHRoaXMub3B0aW9ucy5zZXJpYWxpemVyIHx8IG5vb3BTZXJpYWxpemVyO1xufTtcblxuLy8gQ3JlYXRlcyBhIG5ldyBjbGllbnQgZ2l2ZW4gYW4gb3B0aW9uYWwgY29uZmlnIHN0cmluZyBhbmQgb3B0aW9uYWwgaGFzaCBvZlxuLy8gb3B0aW9ucy4gVGhlIGNvbmZpZyBzdHJpbmcgc2hvdWxkIGJlIG9mIHRoZSBmb3JtOlxuLy9cbi8vICAgICBcIlt1c2VyOnBhc3NAXXNlcnZlcjFbOjExMjExXSxbdXNlcjpwYXNzQF1zZXJ2ZXIyWzoxMTIxMV0sLi4uXCJcbi8vXG4vLyBJZiB0aGUgYXJndW1lbnQgaXMgbm90IGdpdmVuLCBmYWxsYmFjayBvbiB0aGUgYE1FTUNBQ0hJRVJfU0VSVkVSU2AgZW52aXJvbm1lbnRcbi8vIHZhcmlhYmxlLCBgTUVNQ0FDSEVfU0VSVkVSU2AgZW52aXJvbm1lbnQgdmFyaWFibGUgb3IgYFwibG9jYWxob3N0OjExMjExXCJgLlxuLy9cbi8vIFRoZSBvcHRpb25zIGhhc2ggbWF5IGNvbnRhaW4gdGhlIG9wdGlvbnM6XG4vL1xuLy8gKiBgcmV0cmllc2AgLSB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGFuIG9wZXJhdGlvbiBpbiBsaWV1IG9mIGZhaWx1cmVzXG4vLyAoZGVmYXVsdCAyKVxuLy8gKiBgZXhwaXJlc2AgLSB0aGUgZGVmYXVsdCBleHBpcmF0aW9uIGluIHNlY29uZHMgdG8gdXNlIChkZWZhdWx0IDAgLSBuZXZlclxuLy8gZXhwaXJlKS4gSWYgYGV4cGlyZXNgIGlzIGdyZWF0ZXIgdGhhbiAzMCBkYXlzICg2MCB4IDYwIHggMjQgeCAzMCksIGl0IGlzXG4vLyB0cmVhdGVkIGFzIGEgVU5JWCB0aW1lIChudW1iZXIgb2Ygc2Vjb25kcyBzaW5jZSBKYW51YXJ5IDEsIDE5NzApLlxuLy8gKiBgbG9nZ2VyYCAtIGEgbG9nZ2VyIG9iamVjdCB0aGF0IHJlc3BvbmRzIHRvIGBsb2coc3RyaW5nKWAgbWV0aG9kIGNhbGxzLlxuLy8gKiBgZmFpbG92ZXJgIC0gd2hldGhlciB0byBmYWlsb3ZlciB0byBuZXh0IHNlcnZlci4gRGVmYXVsdHMgdG8gZmFsc2UuXG4vLyAqIGBmYWlsb3ZlclRpbWVgIC0gaG93IG11Y2ggdG8gd2FpdCB1bnRpbCByZXRyaW5nIGEgZmFpbGVkIHNlcnZlci4gRGVmYXVsdFxuLy8gICAgICAgICAgICAgICAgICAgIGlzIDYwIHNlY29uZHMuXG4vL1xuLy8gICB+fn5+XG4vLyAgICAgbG9nKG1zZzFbLCBtc2cyWywgbXNnM1suLi5dXV0pXG4vLyAgIH5+fn5cbi8vXG4vLyAgIERlZmF1bHRzIHRvIGBjb25zb2xlYC5cbi8vICogYHNlcmlhbGl6ZXJgIC0gdGhlIG9iamVjdCB3aGljaCB3aWxsIChkZSlzZXJpYWxpemUgdGhlIGRhdGEuIEl0IG5lZWRzXG4vLyAgIHR3byBwdWJsaWMgbWV0aG9kczogc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZS4gSXQgZGVmYXVsdHMgdG8gdGhlIFxuLy8gICBub29wU2VyaWFsaXplcjpcbi8vXG4vLyAgIH5+fn5cbi8vICAgdmFyIG5vb3BTZXJpYWxpemVyID0ge1xuLy8gICAgIHNlcmlhbGl6ZTogZnVuY3Rpb24gKG9wY29kZSwgdmFsdWUsIGV4dHJhcykge1xuLy8gICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBleHRyYXM6IGV4dHJhcyB9O1xuLy8gICAgIH0sXG4vLyAgICAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIChvcGNvZGUsIHZhbHVlLCBleHRyYXMpIHtcbi8vICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZXh0cmFzOiBleHRyYXMgfTtcbi8vICAgICB9XG4vLyAgIH07XG4vLyAgIH5+fn5cbi8vXG4vLyBPciBvcHRpb25zIGZvciB0aGUgc2VydmVycyBpbmNsdWRpbmc6XG4vLyAqIGB1c2VybmFtZWAgYW5kIGBwYXNzd29yZGAgZm9yIGZhbGxiYWNrIFNBU0wgYXV0aGVudGljYXRpb24gY3JlZGVudGlhbHMuXG4vLyAqIGB0aW1lb3V0YCBpbiBzZWNvbmRzIHRvIGRldGVybWluZSBmYWlsdXJlIGZvciBvcGVyYXRpb25zLiBEZWZhdWx0IGlzIDAuNVxuLy8gICAgICAgICAgICAgc2Vjb25kcy5cbi8vICogJ2Nvbm50aW1lb3V0JyBpbiBzZWNvbmRzIHRvIGNvbm5lY3Rpb24gZmFpbHVyZS4gRGVmYXVsdCBpcyB0d2ljZSB0aGUgdmFsdWVcbi8vICAgICAgICAgICAgICAgICBvZiBgdGltZW91dGAuXG4vLyAqIGBrZWVwQWxpdmVgIHdoZXRoZXIgdG8gZW5hYmxlIGtlZXAtYWxpdmUgZnVuY3Rpb25hbGl0eS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4vLyAqIGBrZWVwQWxpdmVEZWxheWAgaW4gc2Vjb25kcyB0byB0aGUgaW5pdGlhbCBkZWxheSBiZWZvcmUgdGhlIGZpcnN0IGtlZXBhbGl2ZVxuLy8gICAgICAgICAgICAgICAgICAgIHByb2JlIGlzIHNlbnQgb24gYW4gaWRsZSBzb2NrZXQuIERlZmF1bHRzIGlzIDMwIHNlY29uZHMuXG5DbGllbnQuY3JlYXRlID0gZnVuY3Rpb24oc2VydmVyc1N0ciwgb3B0aW9ucykge1xuICBzZXJ2ZXJzU3RyID0gc2VydmVyc1N0ciB8fCBwcm9jZXNzLmVudi5NRU1DQUNISUVSX1NFUlZFUlMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTUVNQ0FDSEVfU0VSVkVSUyB8fCAnbG9jYWxob3N0OjExMjExJztcbiAgdmFyIHNlcnZlclVyaXMgPSBzZXJ2ZXJzU3RyLnNwbGl0KCcsJyk7XG4gIHZhciBzZXJ2ZXJzID0gc2VydmVyVXJpcy5tYXAoZnVuY3Rpb24odXJpKSB7XG4gICAgdmFyIHVyaVBhcnRzID0gdXJpLnNwbGl0KCdAJyk7XG4gICAgdmFyIGhvc3RQb3J0ID0gdXJpUGFydHNbdXJpUGFydHMubGVuZ3RoIC0gMV0uc3BsaXQoJzonKTtcbiAgICB2YXIgdXNlclBhc3MgPSAodXJpUGFydHNbdXJpUGFydHMubGVuZ3RoIC0gMl0gfHwgJycpLnNwbGl0KCc6Jyk7XG4gICAgcmV0dXJuIG5ldyBTZXJ2ZXIoaG9zdFBvcnRbMF0sIHBhcnNlSW50KGhvc3RQb3J0WzFdIHx8IDExMjExLCAxMCksIHVzZXJQYXNzWzBdLCB1c2VyUGFzc1sxXSwgb3B0aW9ucyk7XG4gIH0pO1xuICByZXR1cm4gbmV3IENsaWVudChzZXJ2ZXJzLCBvcHRpb25zKTtcbn07XG5cbi8vIEFuIG92ZXJyaWRhYmxlIG1ldGhvZCB5b3UgY2FuIHVzZSBmb3IgZGV0ZXJtaW5nXG4vLyBzZXJ2ZXIgc2VsZWN0aW9uLiBTaG91bGQgcmV0dXJuIHRoZSBzZXJ2ZXIgaW5kZXhcbi8vIGluIHRoZSBsaXN0IG9mIHNlcnZlcnMgb24gQ2xpZW50I3NlcnZlcnMuXG4vLyBcbi8vICAgRXhhbXBsZSB1c2luZyBub2RlLWhhc2hyaW5nOlxuLy8gICB+fn5+XG4vLyAgIGNvbnN0IG1lbWpzID0gcmVxdWlyZSgnbWVtanMnKTtcbi8vICAgY29uc3QgSGFzaFJpbmcgPSByZXF1aXJlKCdub2RlLWhhc2hyaW5nJyk7XG4vLyAgIGNvbnN0IHNlcnZlcnMgPSBbJ2xvY2FsaG9zdDoxMTIxMScsICdsb2NhbGhvc3Q6MTEyMTInXTtcbi8vICAgLy8gYnVpbGQgYSBtYXAgb2Ygc2VydmVyIGFkZHJlc3NlcyB0byB0aGVpciBpbmRleCBpbiB0aGUgc2VydmVyIGxpc3Rcbi8vICAgY29uc3Qgc2VydmVyTWFwID0ge307XG4vLyAgIHNlcnZlcnMuZm9yRWFjaCgoc2VydmVyLCBpbmRleCkgPT4gc2VydmVyTWFwW3NlcnZlcl0gPSBpbmRleCk7XG4vLyAgIGNvbnN0IGNsaWVudCA9IG1lbWpzLkNsaWVudC5jcmVhdGUoc2VydmVycy5qb2luKCcsJykpO1xuLy8gICAvLyBidWlsZCB0aGUgaGFzaHJpbmdcbi8vICAgY29uc3QgaGFzaFJpbmcgPSBuZXcgSGFzaFJpbmcoc2VydmVycyk7XG4vLyAgIC8vIG92ZXJyaWRlIHRoZSBnZXRTZXJ2ZXIgbWV0aG9kXG4vLyAgIGNsaWVudC5nZXRTZXJ2ZXIgPSAoa2V5KSA9PiBzZXJ2ZXJNYXBbaGFzaFJpbmcuZmluZE5vZGUoa2V5KV07XG4vLyAgIH5+fn5cbkNsaWVudC5wcm90b3R5cGUuZ2V0U2VydmVyID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiBoYXNoQ29kZShrZXkpICUgdGhpcy5zZXJ2ZXJzLmxlbmd0aDtcbn07XG5cbi8vIENob29zZXMgdGhlIHNlcnZlciB0byB0YWxrIHRvIGJ5IGhhc2hpbmcgdGhlIGdpdmVuIGtleS5cbkNsaWVudC5wcm90b3R5cGUuc2VydmVyID0gZnVuY3Rpb24oa2V5KSB7XG4gIC8vIG1lY2hhbmlzbXNcbiAgdmFyIHRvdGFsID0gdGhpcy5zZXJ2ZXJzLmxlbmd0aDtcbiAgdmFyIG9yaWdJZHggPSB0b3RhbCA+IDEgPyB0aGlzLmdldFNlcnZlcihrZXkpIDogMDtcbiAgdmFyIGlkeCA9IG9yaWdJZHg7XG4gIHZhciBzZXJ2ID0gdGhpcy5zZXJ2ZXJzW2lkeF07XG4gIHdoaWxlIChzZXJ2Lndha2V1cEF0ICYmXG4gICAgICBzZXJ2Lndha2V1cEF0ID4gRGF0ZS5ub3coKSkge1xuICAgIGlkeCA9IChpZHggKyAxKSAlIHRvdGFsO1xuICAgIGlmIChpZHggPT09IG9yaWdJZHgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzZXJ2ID0gdGhpcy5zZXJ2ZXJzW2lkeF07XG4gIH1cbiAgcmV0dXJuIHNlcnY7XG59O1xuXG4vLyBjb252ZXJ0cyBhIGNhbGwgaW50byBhIHByb21pc2UtcmV0dXJuaW5nIG9uZVxudmFyIHByb21pc2lmeSA9IGZ1bmN0aW9uKGNvbW1hbmQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNvbW1hbmQoZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAgICAgIGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8vICMjIE1lbWNhY2hlIENvbW1hbmRzXG4vL1xuLy8gQWxsIGNvbW1hbmRzIHJldHVybiB0aGVpciByZXN1bHRzIHRocm91Z2ggYSBjYWxsYmFjayBwYXNzZWQgYXMgdGhlIGxhc3Rcbi8vIHJlcXVpcmVkIGFyZ3VtZW50IChzb21lIGNvbW1hbmRzLCBsaWtlIGBDbGllbnQjc2V0YCwgdGFrZSBvcHRpb25hbCBhcmd1bWVudHNcbi8vIGFmdGVyIHRoZSBjYWxsYmFjaykuXG4vL1xuLy8gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBhbHdheXMgZm9sbG93czpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBbYXJnMVssIGFyZzJbLCBhcmczWy4uLl1dXV0pXG4vL1xuLy8gSW4gY2FzZSBvZiBhbiBlcnJvciB0aGUgX2Vycl8gYXJndW1lbnQgd2lsbCBiZSBub24tbnVsbCBhbmQgY29udGFpbiB0aGVcbi8vIGBFcnJvcmAuIEEgbm90YWJsZSBleGNlcHRpb24gaW5jbHVkZXMgYSBgQ2xpZW50I2dldGAgb24gYSBrZXkgdGhhdCBkb2Vzbid0XG4vLyBleGlzdC4gSW4gdGhpcyBjYXNlLCBfZXJyXyB3aWxsIGJlIG51bGwsIGFzIHdpbGwgdGhlIF92YWx1ZSBhbmQgX2V4dHJhc19cbi8vIGFyZ3VtZW50cy5cblxuLy8gR0VUXG4vL1xuLy8gUmV0cmlldmVzIHRoZSB2YWx1ZSBhdCB0aGUgZ2l2ZW4ga2V5IGluIG1lbWNhY2hlLlxuLy9cbi8vIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgdmFsdWUsIGZsYWdzKVxuLy9cbi8vIF92YWx1ZV8gYW5kIF9mbGFnc18gYXJlIGJvdGggYEJ1ZmZlcmBzLiBJZiB0aGUga2V5IGlzIG5vdCBmb3VuZCwgdGhlXG4vLyBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggbnVsbCBmb3IgYm90aCBhcmd1bWVudHMgYW5kIG5vIGVycm9yLlxuQ2xpZW50LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgIHNlbGYuZ2V0KGtleSwgZnVuY3Rpb24oZXJyLCB2YWx1ZSwgZmxhZ3MpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB7dmFsdWU6IHZhbHVlLCBmbGFnczogZmxhZ3N9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB0aGlzLmluY3JTZXEoKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcigwLCBrZXksICcnLCAnJywgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGRlc2VyaWFsaXplZCA9IHNlbGYuc2VyaWFsaXplci5kZXNlcmlhbGl6ZShyZXNwb25zZS5oZWFkZXIub3Bjb2RlLCByZXNwb25zZS52YWwsIHJlc3BvbnNlLmV4dHJhcyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGRlc2VyaWFsaXplZC52YWx1ZSwgZGVzZXJpYWxpemVkLmV4dHJhcyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgbnVsbCwgbnVsbCk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIEdFVDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gU0VUXG4vL1xuLy8gU2V0cyB0aGUgZ2l2ZW4gX2tleV8gYW5kIF92YWx1ZV8gaW4gbWVtY2FjaGUuXG4vL1xuLy8gVGhlIG9wdGlvbnMgZGljdGlvbmFyeSB0YWtlczpcbi8vICogX2V4cGlyZXNfOiBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZXhwaXJhdGlvbiAoc2VlIGBDbGllbnQuY3JlYXRlYCkgZm9yIHRoaXNcbi8vICAgICAgICAgICAgICBwYXJ0aWN1bGFyIGtleS12YWx1ZSBwYWlyLlxuLy9cbi8vIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc3VjY2VzcylcbkNsaWVudC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7IHNlbGYuc2V0KGtleSwgdmFsdWUsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgc3VjY2VzcykgeyBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpOyB9KTsgfSk7XG4gIH1cbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHZhciBleHBpcmVzO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgIC8vIE9MRDogZnVuY3Rpb24oa2V5LCB2YWx1ZSwgY2FsbGJhY2ssIGV4cGlyZXMpXG4gICAgbG9nZ2VyLmxvZygnTWVtSlMgU0VUOiB1c2luZyBkZXByZWNhdGVkIGNhbGwgLSBhcmd1bWVudHMgaGF2ZSBjaGFuZ2VkJyk7XG4gICAgZXhwaXJlcyA9IGNhbGxiYWNrO1xuICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICBleHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgZmxhZ3MsIHN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICB0aGlzLmluY3JTZXEoKTtcbiAgdmFyIGV4cGlyYXRpb24gPSBtYWtlRXhwaXJhdGlvbihleHBpcmVzIHx8IHRoaXMub3B0aW9ucy5leHBpcmVzKTtcbiAgdmFyIGV4dHJhcyA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKCcwMDAwMDAwMCcsICdoZXgnKSwgZXhwaXJhdGlvbl0pO1xuXG4gIHZhciBvcGNvZGUgPSAxO1xuICB2YXIgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplci5zZXJpYWxpemUob3Bjb2RlLCB2YWx1ZSwgZXh0cmFzKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcihvcGNvZGUsIGtleSwgc2VyaWFsaXplZC5leHRyYXMsIHNlcmlhbGl6ZWQudmFsdWUsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIFNFVDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gQUREXG4vL1xuLy8gQWRkcyB0aGUgZ2l2ZW4gX2tleV8gYW5kIF92YWx1ZV8gdG8gbWVtY2FjaGUuIFRoZSBvcGVyYXRpb24gb25seSBzdWNjZWVkc1xuLy8gaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXQuXG4vL1xuLy8gVGhlIG9wdGlvbnMgZGljdGlvbmFyeSB0YWtlczpcbi8vICogX2V4cGlyZXNfOiBvdmVycmlkZXMgdGhlIGRlZmF1bHQgZXhwaXJhdGlvbiAoc2VlIGBDbGllbnQuY3JlYXRlYCkgZm9yIHRoaXNcbi8vICAgICAgICAgICAgICBwYXJ0aWN1bGFyIGtleS12YWx1ZSBwYWlyLlxuLy9cbi8vIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc3VjY2VzcylcbkNsaWVudC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7IHNlbGYuYWRkKGtleSwgdmFsdWUsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgc3VjY2VzcykgeyBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpOyB9KTsgfSk7XG4gIH1cbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHZhciBleHBpcmVzO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBPTEQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNhbGxiYWNrLCBleHBpcmVzKVxuICAgIGxvZ2dlci5sb2coJ01lbUpTIEFERDogdXNpbmcgZGVwcmVjYXRlZCBjYWxsIC0gYXJndW1lbnRzIGhhdmUgY2hhbmdlZCcpO1xuICAgIGV4cGlyZXMgPSBjYWxsYmFjaztcbiAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgZXhwaXJlcyA9IG9wdGlvbnMuZXhwaXJlcztcblxuICAvLyBUT0RPOiBzdXBwb3J0IGZsYWdzLCBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciBleHBpcmF0aW9uID0gbWFrZUV4cGlyYXRpb24oZXhwaXJlcyB8fCB0aGlzLm9wdGlvbnMuZXhwaXJlcyk7XG4gIHZhciBleHRyYXMgPSBCdWZmZXIuY29uY2F0KFtCdWZmZXIuZnJvbSgnMDAwMDAwMDAnLCAnaGV4JyksIGV4cGlyYXRpb25dKTtcblxuICB2YXIgb3Bjb2RlID0gMjtcbiAgdmFyIHNlcmlhbGl6ZWQgPSB0aGlzLnNlcmlhbGl6ZXIuc2VyaWFsaXplKG9wY29kZSwgdmFsdWUsIGV4dHJhcyk7XG4gIHZhciByZXF1ZXN0ID0gbWFrZVJlcXVlc3RCdWZmZXIob3Bjb2RlLCBrZXksIHNlcmlhbGl6ZWQuZXh0cmFzLCBzZXJpYWxpemVkLnZhbHVlLCB0aGlzLnNlcSk7XG4gIHRoaXMucGVyZm9ybShrZXksIHJlcXVlc3QsIHRoaXMuc2VxLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGVyciwgbnVsbCwgbnVsbCk7IH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChyZXNwb25zZS5oZWFkZXIuc3RhdHVzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHRydWUpOyB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgZmFsc2UpOyB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9ICdNZW1KUyBBREQ6ICcgKyBlcnJvcnNbcmVzcG9uc2UuaGVhZGVyLnN0YXR1c107XG4gICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBSRVBMQUNFXG4vL1xuLy8gUmVwbGFjZXMgdGhlIGdpdmVuIF9rZXlfIGFuZCBfdmFsdWVfIHRvIG1lbWNhY2hlLiBUaGUgb3BlcmF0aW9uIG9ubHkgc3VjY2VlZHNcbi8vIGlmIHRoZSBrZXkgaXMgYWxyZWFkeSBwcmVzZW50LlxuLy9cbi8vIFRoZSBvcHRpb25zIGRpY3Rpb25hcnkgdGFrZXM6XG4vLyAqIF9leHBpcmVzXzogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGV4cGlyYXRpb24gKHNlZSBgQ2xpZW50LmNyZWF0ZWApIGZvciB0aGlzXG4vLyAgICAgICAgICAgICAgcGFydGljdWxhciBrZXktdmFsdWUgcGFpci5cbi8vXG4vLyBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpXG5DbGllbnQucHJvdG90eXBlLnJlcGxhY2UgPSBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvcHRpb25zICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHsgc2VsZi5yZXBsYWNlKGtleSwgdmFsdWUsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgc3VjY2VzcykgeyBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpOyB9KTsgfSk7XG4gIH1cbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHZhciBleHBpcmVzO1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBPTEQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNhbGxiYWNrLCBleHBpcmVzKVxuICAgIGxvZ2dlci5sb2coJ01lbUpTIFJFUExBQ0U6IHVzaW5nIGRlcHJlY2F0ZWQgY2FsbCAtIGFyZ3VtZW50cyBoYXZlIGNoYW5nZWQnKTtcbiAgICBleHBpcmVzID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIGV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG5cbiAgLy8gVE9ETzogc3VwcG9ydCBmbGFncywgc3VwcG9ydCB2ZXJzaW9uIChDQVMpXG4gIHRoaXMuaW5jclNlcSgpO1xuICB2YXIgZXhwaXJhdGlvbiA9IG1ha2VFeHBpcmF0aW9uKGV4cGlyZXMgfHwgdGhpcy5vcHRpb25zLmV4cGlyZXMpO1xuICB2YXIgZXh0cmFzID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oJzAwMDAwMDAwJywgJ2hleCcpLCBleHBpcmF0aW9uXSk7XG5cbiAgdmFyIG9wY29kZSA9IDM7XG4gIHZhciBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemVyLnNlcmlhbGl6ZShvcGNvZGUsIHZhbHVlLCBleHRyYXMpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKG9wY29kZSwga2V5LCBzZXJpYWxpemVkLmV4dHJhcywgc2VyaWFsaXplZC52YWx1ZSwgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgMDpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCB0cnVlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIGZhbHNlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgUkVQTEFDRTogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlLCBmYWxzZSk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobmV3IEVycm9yKGVycm9yTWVzc2FnZSksIG51bGwsIG51bGwpOyB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIERFTEVURVxuLy9cbi8vIERlbGV0ZXMgdGhlIGdpdmVuIF9rZXlfIGZyb20gbWVtY2FjaGUuIFRoZSBvcGVyYXRpb24gb25seSBzdWNjZWVkc1xuLy8gaWYgdGhlIGtleSBpcyBhbHJlYWR5IHByZXNlbnQuXG4vL1xuLy8gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzdWNjZXNzKVxuQ2xpZW50LnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihrZXksIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykgeyBzZWxmLmRlbGV0ZShrZXksIGZ1bmN0aW9uKGVyciwgc3VjY2VzcykgeyBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpOyB9KTsgfSk7XG4gIH1cbiAgLy8gVE9ETzogU3VwcG9ydCB2ZXJzaW9uIChDQVMpXG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB0aGlzLmluY3JTZXEoKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcig0LCBrZXksICcnLCAnJywgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCBmYWxzZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIERFTEVURTogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlLCBmYWxzZSk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobmV3IEVycm9yKGVycm9yTWVzc2FnZSksIG51bGwpOyB9XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIElOQ1JFTUVOVFxuLy9cbi8vIEluY3JlbWVudHMgdGhlIGdpdmVuIF9rZXlfIGluIG1lbWNhY2hlLlxuLy9cbi8vIFRoZSBvcHRpb25zIGRpY3Rpb25hcnkgdGFrZXM6XG4vLyAqIF9pbml0aWFsXzogdGhlIHZhbHVlIGZvciB0aGUga2V5IGlmIG5vdCBhbHJlYWR5IHByZXNlbnQsIGRlZmF1bHRzIHRvIDAuXG4vLyAqIF9leHBpcmVzXzogb3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGV4cGlyYXRpb24gKHNlZSBgQ2xpZW50LmNyZWF0ZWApIGZvciB0aGlzXG4vLyAgICAgICAgICAgICAgcGFydGljdWxhciBrZXktdmFsdWUgcGFpci5cbi8vXG4vLyBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MsIHZhbHVlKVxuQ2xpZW50LnByb3RvdHlwZS5pbmNyZW1lbnQgPSBmdW5jdGlvbihrZXksIGFtb3VudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0aW9ucyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICAgIHNlbGYuaW5jcmVtZW50KGtleSwgYW1vdW50LCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MsIHZhbHVlKSB7XG4gICAgICAgIGNhbGxiYWNrKGVyciwge3N1Y2Nlc3M6IHN1Y2Nlc3MsIHZhbHVlOiB2YWx1ZX0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHZhciBpbml0aWFsO1xuICB2YXIgZXhwaXJlcztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gT0xEOiBmdW5jdGlvbihrZXksIGFtb3VudCwgY2FsbGJhY2ssIGV4cGlyZXMsIGluaXRpYWwpXG4gICAgbG9nZ2VyLmxvZygnTWVtSlMgSU5DUkVNRU5UOiB1c2luZyBkZXByZWNhdGVkIGNhbGwgLSBhcmd1bWVudHMgaGF2ZSBjaGFuZ2VkJyk7XG4gICAgaW5pdGlhbCA9IGFyZ3VtZW50c1s0XTtcbiAgICBleHBpcmVzID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIGluaXRpYWwgPSBvcHRpb25zLmluaXRpYWw7XG4gIGV4cGlyZXMgPSBvcHRpb25zLmV4cGlyZXM7XG5cbiAgLy8gVE9ETzogc3VwcG9ydCB2ZXJzaW9uIChDQVMpXG4gIHRoaXMuaW5jclNlcSgpO1xuICBpbml0aWFsID0gaW5pdGlhbCB8fCAwO1xuICBleHBpcmVzID0gZXhwaXJlcyB8fCB0aGlzLm9wdGlvbnMuZXhwaXJlcztcbiAgdmFyIGV4dHJhcyA9IG1ha2VBbW91bnRJbml0aWFsQW5kRXhwaXJhdGlvbihhbW91bnQsIGluaXRpYWwsIGV4cGlyZXMpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKDUsIGtleSwgZXh0cmFzLCAnJywgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgMDpcbiAgICAgIHZhciBidWZJbnQgPSAocmVzcG9uc2UudmFsLnJlYWRVSW50MzJCRSgwKSA8PCA4KSArIHJlc3BvbnNlLnZhbC5yZWFkVUludDMyQkUoNCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSwgYnVmSW50KTsgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgSU5DUkVNRU5UOiAnICsgZXJyb3JzW3Jlc3BvbnNlLmhlYWRlci5zdGF0dXNdO1xuICAgICAgbG9nZ2VyLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBERUNSRU1FTlRcbi8vXG4vLyBEZWNyZW1lbnRzIHRoZSBnaXZlbiBfa2V5XyBpbiBtZW1jYWNoZS5cbi8vXG4vLyBUaGUgb3B0aW9ucyBkaWN0aW9uYXJ5IHRha2VzOlxuLy8gKiBfaW5pdGlhbF86IHRoZSB2YWx1ZSBmb3IgdGhlIGtleSBpZiBub3QgYWxyZWFkeSBwcmVzZW50LCBkZWZhdWx0cyB0byAwLlxuLy8gKiBfZXhwaXJlc186IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBleHBpcmF0aW9uIChzZWUgYENsaWVudC5jcmVhdGVgKSBmb3IgdGhpc1xuLy8gICAgICAgICAgICAgIHBhcnRpY3VsYXIga2V5LXZhbHVlIHBhaXIuXG4vL1xuLy8gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzdWNjZXNzLCB2YWx1ZSlcbkNsaWVudC5wcm90b3R5cGUuZGVjcmVtZW50ID0gZnVuY3Rpb24oa2V5LCBhbW91bnQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgc2VsZi5kZWNyZW1lbnQoa2V5LCBhbW91bnQsIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgc3VjY2VzcywgdmFsdWUpIHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCB7c3VjY2Vzczogc3VjY2VzcywgdmFsdWU6IHZhbHVlfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvLyBUT0RPOiBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHZhciBpbml0aWFsO1xuICB2YXIgZXhwaXJlcztcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gT0xEOiBmdW5jdGlvbihrZXksIGFtb3VudCwgY2FsbGJhY2ssIGV4cGlyZXMsIGluaXRpYWwpXG4gICAgbG9nZ2VyLmxvZygnTWVtSlMgREVDUkVNRU5UOiB1c2luZyBkZXByZWNhdGVkIGNhbGwgLSBhcmd1bWVudHMgaGF2ZSBjaGFuZ2VkJyk7XG4gICAgaW5pdGlhbCA9IGFyZ3VtZW50c1s0XTtcbiAgICBleHBpcmVzID0gY2FsbGJhY2s7XG4gICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIC8vIFRPRE86IHN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICBpbml0aWFsID0gb3B0aW9ucy5pbml0aWFsO1xuICBleHBpcmVzID0gb3B0aW9ucy5leHBpcmVzO1xuXG4gIHRoaXMuaW5jclNlcSgpO1xuICBpbml0aWFsID0gaW5pdGlhbCB8fCAwO1xuICBleHBpcmVzID0gZXhwaXJlcyB8fCB0aGlzLm9wdGlvbnMuZXhwaXJlcztcbiAgdmFyIGV4dHJhcyA9IG1ha2VBbW91bnRJbml0aWFsQW5kRXhwaXJhdGlvbihhbW91bnQsIGluaXRpYWwsIGV4cGlyZXMpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKDYsIGtleSwgZXh0cmFzLCAnJywgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgMDpcbiAgICAgIHZhciBidWZJbnQgPSAocmVzcG9uc2UudmFsLnJlYWRVSW50MzJCRSgwKSA8PCA4KSArIHJlc3BvbnNlLnZhbC5yZWFkVUludDMyQkUoNCk7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSwgYnVmSW50KTsgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgREVDUkVNRU5UOiAnICsgZXJyb3JzW3Jlc3BvbnNlLmhlYWRlci5zdGF0dXNdO1xuICAgICAgbG9nZ2VyLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBBUFBFTkRcbi8vXG4vLyBBcHBlbmQgdGhlIGdpdmVuIF92YWx1ZV8gdG8gdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gX2tleV8gaW5cbi8vIG1lbWNhY2hlLiBUaGUgb3BlcmF0aW9uIG9ubHkgc3VjY2VlZHMgaWYgdGhlIGtleSBpcyBhbHJlYWR5IHByZXNlbnQuIFRoZVxuLy8gY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHN1Y2Nlc3MpXG5DbGllbnQucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykgeyBzZWxmLmFwcGVuZChrZXksIHZhbHVlLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MpIHsgY2FsbGJhY2soZXJyLCBzdWNjZXNzKTsgfSk7IH0pO1xuICB9XG4gIC8vIFRPRE86IHN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICB2YXIgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciBvcGNvZGUgPSAweDBFO1xuICB2YXIgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplci5zZXJpYWxpemUob3Bjb2RlLCB2YWx1ZSwgJycpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKG9wY29kZSwga2V5LCBzZXJpYWxpemVkLmV4dHJhcywgc2VyaWFsaXplZC52YWx1ZSwgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgMDpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCB0cnVlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIGZhbHNlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgQVBQRU5EOiAnICsgZXJyb3JzW3Jlc3BvbnNlLmhlYWRlci5zdGF0dXNdO1xuICAgICAgbG9nZ2VyLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBQUkVQRU5EXG4vL1xuLy8gUHJlcGVuZCB0aGUgZ2l2ZW4gX3ZhbHVlXyB0byB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBfa2V5XyBpblxuLy8gbWVtY2FjaGUuIFRoZSBvcGVyYXRpb24gb25seSBzdWNjZWVkcyBpZiB0aGUga2V5IGlzIGFscmVhZHkgcHJlc2VudC4gVGhlXG4vLyBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc3VjY2VzcylcbkNsaWVudC5wcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gIGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHByb21pc2lmeShmdW5jdGlvbihjYWxsYmFjaykgeyBzZWxmLnByZXBlbmQoa2V5LCB2YWx1ZSwgZnVuY3Rpb24oZXJyLCBzdWNjZXNzKSB7IGNhbGxiYWNrKGVyciwgc3VjY2Vzcyk7IH0pOyB9KTtcbiAgfVxuICAvLyBUT0RPOiBzdXBwb3J0IHZlcnNpb24gKENBUylcbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHRoaXMuaW5jclNlcSgpO1xuXG4gIHZhciBvcGNvZGUgPSAweDBFO1xuICB2YXIgc2VyaWFsaXplZCA9IHRoaXMuc2VyaWFsaXplci5zZXJpYWxpemUob3Bjb2RlLCB2YWx1ZSwgJycpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKG9wY29kZSwga2V5LCBzZXJpYWxpemVkLmV4dHJhcywgc2VyaWFsaXplZC52YWx1ZSwgdGhpcy5zZXEpO1xuICB0aGlzLnBlcmZvcm0oa2V5LCByZXF1ZXN0LCB0aGlzLnNlcSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIG51bGwpOyB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgIGNhc2UgMDpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCB0cnVlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIGZhbHNlKTsgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgUFJFUEVORDogJyArIGVycm9yc1tyZXNwb25zZS5oZWFkZXIuc3RhdHVzXTtcbiAgICAgIGxvZ2dlci5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgbnVsbCk7IH1cbiAgICB9XG4gIH0pO1xufTtcblxuLy8gVE9VQ0hcbi8vXG4vLyBUb3VjaCBzZXRzIGFuIGV4cGlyYXRpb24gdmFsdWUsIGdpdmVuIGJ5IF9leHBpcmVzXywgb24gdGhlIGdpdmVuIF9rZXlfIGluXG4vLyBtZW1jYWNoZS4gVGhlIG9wZXJhdGlvbiBvbmx5IHN1Y2NlZWRzIGlmIHRoZSBrZXkgaXMgYWxyZWFkeSBwcmVzZW50LiBUaGVcbi8vIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzdWNjZXNzKVxuQ2xpZW50LnByb3RvdHlwZS50b3VjaCA9IGZ1bmN0aW9uKGtleSwgZXhwaXJlcywgY2FsbGJhY2spIHtcbiAgaWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNhbGxiYWNrKSB7IHNlbGYudG91Y2goa2V5LCBleHBpcmVzLCBmdW5jdGlvbihlcnIsIHN1Y2Nlc3MpIHsgY2FsbGJhY2soZXJyLCBzdWNjZXNzKTsgfSk7IH0pO1xuICB9XG4gIC8vIFRPRE86IHN1cHBvcnQgdmVyc2lvbiAoQ0FTKVxuICB2YXIgbG9nZ2VyID0gdGhpcy5vcHRpb25zLmxvZ2dlcjtcbiAgdGhpcy5pbmNyU2VxKCk7XG4gIHZhciBleHRyYXMgPSBtYWtlRXhwaXJhdGlvbihleHBpcmVzIHx8IHRoaXMub3B0aW9ucy5leHBpcmVzKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcigweDFDLCBrZXksIGV4dHJhcywgJycsIHRoaXMuc2VxKTtcbiAgdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgdGhpcy5zZXEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBudWxsKTsgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMpIHtcbiAgICBjYXNlIDA6XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCBmYWxzZSk7IH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gJ01lbUpTIFRPVUNIOiAnICsgZXJyb3JzW3Jlc3BvbnNlLmhlYWRlci5zdGF0dXNdO1xuICAgICAgbG9nZ2VyLmxvZyhlcnJvck1lc3NhZ2UpO1xuICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCBudWxsKTsgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBGTFVTSFxuLy9cbi8vIEZsdXNoZXMgdGhlIGNhY2hlIG9uIGVhY2ggY29ubmVjdGVkIHNlcnZlci4gVGhlIGNhbGxiYWNrIHNpZ25hdHVyZSBpczpcbi8vXG4vLyAgICAgY2FsbGJhY2sobGFzdEVyciwgcmVzdWx0cylcbi8vXG4vLyB3aGVyZSBfbGFzdEVycl8gaXMgdGhlIGxhc3QgZXJyb3IgZW5jb3VudGVyZWQgKG9yIG51bGwsIGluIHRoZSBjb21tb24gY2FzZVxuLy8gb2Ygbm8gZXJyb3JzKS4gX3Jlc3VsdHNfIGlzIGEgZGljdGlvbmFyeSBtYXBwaW5nIGBcImhvc3RuYW1lOnBvcnRcImAgdG8gZWl0aGVyXG4vLyBgdHJ1ZWAgKGlmIHRoZSBvcGVyYXRpb24gd2FzIHN1Y2Nlc3NmdWwpLCBvciBhbiBlcnJvci5cbkNsaWVudC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICBpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBwcm9taXNpZnkoZnVuY3Rpb24oY2FsbGJhY2spIHsgc2VsZi5mbHVzaChmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHsgY2FsbGJhY2soZXJyLCByZXN1bHRzKTsgfSk7IH0pO1xuICB9XG4gIC8vIFRPRE86IHN1cHBvcnQgZXhwaXJhdGlvblxuICB0aGlzLmluY3JTZXEoKTtcbiAgdmFyIHJlcXVlc3QgPSBtYWtlUmVxdWVzdEJ1ZmZlcigweDA4LCAnJywgJycsICcnLCB0aGlzLnNlcSk7XG4gIHZhciBjb3VudCAgID0gdGhpcy5zZXJ2ZXJzLmxlbmd0aDtcbiAgdmFyIHJlc3VsdCAgPSB7fTtcbiAgdmFyIGxhc3RFcnIgPSBudWxsO1xuICB2YXIgaTtcblxuICB2YXIgaGFuZGxlRmx1c2ggPSBmdW5jdGlvbihzZXEsIHNlcnYpIHtcbiAgICBzZXJ2Lm9uUmVzcG9uc2Uoc2VxLCBmdW5jdGlvbigvKiByZXNwb25zZSAqLykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICAgIHJlc3VsdFtzZXJ2Lmhvc3QgKyAnOicgKyBzZXJ2LnBvcnRdID0gdHJ1ZTtcbiAgICAgIGlmIChjYWxsYmFjayAmJiBjb3VudCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhsYXN0RXJyLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlcnYub25FcnJvcihzZXEsIGZ1bmN0aW9uKGVycikge1xuICAgICAgY291bnQgLT0gMTtcbiAgICAgIGxhc3RFcnIgPSBlcnI7XG4gICAgICByZXN1bHRbc2Vydi5ob3N0ICsgJzonICsgc2Vydi5wb3J0XSA9IGVycjtcbiAgICAgIGlmIChjYWxsYmFjayAmJiBjb3VudCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhsYXN0RXJyLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlcnYud3JpdGUocmVxdWVzdCk7XG4gIH07XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgIGhhbmRsZUZsdXNoKHRoaXMuc2VxLCB0aGlzLnNlcnZlcnNbaV0pO1xuICB9XG59O1xuXG4vLyBTVEFUU19XSVRIX0tFWVxuLy9cbi8vIFNlbmRzIGEgbWVtY2FjaGUgc3RhdHMgY29tbWFuZCB3aXRoIGEga2V5IHRvIGVhY2ggY29ubmVjdGVkIHNlcnZlci4gVGhlXG4vLyBjYWxsYmFjayBpcyBpbnZva2VkICoqT05DRSBQRVIgU0VSVkVSKiogYW5kIGhhcyB0aGUgc2lnbmF0dXJlOlxuLy9cbi8vICAgICBjYWxsYmFjayhlcnIsIHNlcnZlciwgc3RhdHMpXG4vL1xuLy8gX3NlcnZlcl8gaXMgdGhlIGBcImhvc3RuYW1lOnBvcnRcImAgb2YgdGhlIHNlcnZlciwgYW5kIF9zdGF0c18gaXMgYSBkaWN0aW9uYXJ5XG4vLyBtYXBwaW5nIHRoZSBzdGF0IG5hbWUgdG8gdGhlIHZhbHVlIG9mIHRoZSBzdGF0aXN0aWMgYXMgYSBzdHJpbmcuXG5DbGllbnQucHJvdG90eXBlLnN0YXRzV2l0aEtleSA9IGZ1bmN0aW9uKGtleSwgY2FsbGJhY2spIHtcbiAgdmFyIGxvZ2dlciA9IHRoaXMub3B0aW9ucy5sb2dnZXI7XG4gIHRoaXMuaW5jclNlcSgpO1xuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKDB4MTAsIGtleSwgJycsICcnLCB0aGlzLnNlcSk7XG4gIHZhciBpO1xuXG4gIHZhciBoYW5kbGVTdGF0cyA9IGZ1bmN0aW9uKHNlcSwgc2Vydikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgaGFuZGxlID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgIC8vIGVuZCBvZiBzdGF0IHJlc3BvbnNlc1xuICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlci50b3RhbEJvZHlMZW5ndGggPT09IDApIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHNlcnYuaG9zdCArICc6JyArIHNlcnYucG9ydCwgcmVzdWx0KTsgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBwcm9jZXNzIHNpbmdsZSBzdGF0IGxpbmUgcmVzcG9uc2VcbiAgICAgIHN3aXRjaCAocmVzcG9uc2UuaGVhZGVyLnN0YXR1cykge1xuICAgICAgY2FzZSAgMDpcbiAgICAgICAgcmVzdWx0W3Jlc3BvbnNlLmtleS50b1N0cmluZygpXSA9IHJlc3BvbnNlLnZhbC50b1N0cmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSAnTWVtSlMgU1RBVFMgKCcgKyBrZXkgKyAnKTogJyArXG4gICAgICAgICAgZXJyb3JzW3Jlc3BvbnNlLmhlYWRlci5zdGF0dXNdO1xuICAgICAgICBsb2dnZXIubG9nKGVycm9yTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKSwgc2Vydi5ob3N0ICsgJzonICsgc2Vydi5wb3J0LCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlLnF1aWV0ID0gdHJ1ZTtcblxuICAgIHNlcnYub25SZXNwb25zZShzZXEsIGhhbmRsZSk7XG4gICAgc2Vydi5vbkVycm9yKHNlcSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHsgY2FsbGJhY2soZXJyLCBzZXJ2Lmhvc3QgKyAnOicgKyBzZXJ2LnBvcnQsIG51bGwpOyB9XG4gICAgfSk7XG4gICAgc2Vydi53cml0ZShyZXF1ZXN0KTtcbiAgfTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgaGFuZGxlU3RhdHModGhpcy5zZXEsIHRoaXMuc2VydmVyc1tpXSk7XG4gIH1cbn07XG5cblxuLy8gU1RBVFNcbi8vXG4vLyBGZXRjaGVzIG1lbWNhY2hlIHN0YXRzIGZyb20gZWFjaCBjb25uZWN0ZWQgc2VydmVyLiBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZFxuLy8gKipPTkNFIFBFUiBTRVJWRVIqKiBhbmQgaGFzIHRoZSBzaWduYXR1cmU6XG4vL1xuLy8gICAgIGNhbGxiYWNrKGVyciwgc2VydmVyLCBzdGF0cylcbi8vXG4vLyBfc2VydmVyXyBpcyB0aGUgYFwiaG9zdG5hbWU6cG9ydFwiYCBvZiB0aGUgc2VydmVyLCBhbmQgX3N0YXRzXyBpcyBhXG4vLyBkaWN0aW9uYXJ5IG1hcHBpbmcgdGhlIHN0YXQgbmFtZSB0byB0aGUgdmFsdWUgb2YgdGhlIHN0YXRpc3RpYyBhcyBhIHN0cmluZy5cbkNsaWVudC5wcm90b3R5cGUuc3RhdHMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICB0aGlzLnN0YXRzV2l0aEtleSgnJywgY2FsbGJhY2spO1xufTtcblxuLy8gUkVTRVRfU1RBVFNcbi8vXG4vLyBSZXNldCB0aGUgc3RhdGlzdGljcyBlYWNoIHNlcnZlciBpcyBrZWVwaW5nIGJhY2sgdG8gemVyby4gVGhpcyBkb2Vzbid0IGNsZWFyXG4vLyBzdGF0cyBzdWNoIGFzIGl0ZW0gY291bnQsIGJ1dCB0ZW1wb3Jhcnkgc3RhdHMgc3VjaCBhcyB0b3RhbCBudW1iZXIgb2Zcbi8vIGNvbm5lY3Rpb25zIG92ZXIgdGltZS5cbi8vXG4vLyBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZCAqKk9OQ0UgUEVSIFNFUlZFUioqIGFuZCBoYXMgdGhlIHNpZ25hdHVyZTpcbi8vXG4vLyAgICAgY2FsbGJhY2soZXJyLCBzZXJ2ZXIpXG4vL1xuLy8gX3NlcnZlcl8gaXMgdGhlIGBcImhvc3RuYW1lOnBvcnRcImAgb2YgdGhlIHNlcnZlci5cbkNsaWVudC5wcm90b3R5cGUucmVzZXRTdGF0cyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHRoaXMuc3RhdHNXaXRoS2V5KCdyZXNldCcsIGNhbGxiYWNrKTtcbn07XG5cbi8vIFFVSVRcbi8vXG4vLyBDbG9zZXMgdGhlIGNvbm5lY3Rpb24gdG8gZWFjaCBzZXJ2ZXIsIG5vdGlmeWluZyB0aGVtIG9mIHRoaXMgaW50ZW50aW9uLiBOb3RlXG4vLyB0aGF0IHF1aXQgY2FuIHJhY2UgYWdhaW5zdCBhbHJlYWR5IG91dHN0YW5kaW5nIHJlcXVlc3RzIHdoZW4gdGhvc2UgcmVxdWVzdHNcbi8vIGZhaWwgYW5kIGFyZSByZXRyaWVkLCBsZWFkaW5nIHRvIHRoZSBxdWl0IGNvbW1hbmQgd2lubmluZyBhbmQgY2xvc2luZyB0aGVcbi8vIGNvbm5lY3Rpb24gYmVmb3JlIHRoZSByZXRyaWVzIGNvbXBsZXRlLlxuQ2xpZW50LnByb3RvdHlwZS5xdWl0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5jclNlcSgpO1xuICAvLyBUT0RPOiBOaWNlciBwZXJoYXBzIHRvIGRvIFFVSVRRICgweDE3KSBidXQgbmVlZCBhIG5ldyBjYWxsYmFjayBmb3Igd2hlblxuICAvLyB3cml0ZSBpcyBkb25lLlxuICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0QnVmZmVyKDB4MDcsICcnLCAnJywgJycsIHRoaXMuc2VxKTsgLy8gUVVJVFxuICB2YXIgc2VydjtcbiAgdmFyIGk7XG5cbiAgdmFyIGhhbmRsZVF1aXQgPSBmdW5jdGlvbihzZXEsIHNlcnYpIHtcbiAgICBzZXJ2Lm9uUmVzcG9uc2Uoc2VxLCBmdW5jdGlvbigvKiByZXNwb25zZSAqLykge1xuICAgICAgc2Vydi5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHNlcnYub25FcnJvcihzZXEsIGZ1bmN0aW9uKC8qIGVyciAqLykge1xuICAgICAgc2Vydi5jbG9zZSgpO1xuICAgIH0pO1xuICAgIHNlcnYud3JpdGUocmVxdWVzdCk7XG4gIH07XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgIHNlcnYgPSB0aGlzLnNlcnZlcnNbaV07XG4gICAgaGFuZGxlUXVpdCh0aGlzLnNlcSwgc2Vydik7XG4gIH1cbn07XG5cbi8vIENMT1NFXG4vL1xuLy8gQ2xvc2VzIChhYnJ1cHRseSkgY29ubmVjdGlvbnMgdG8gYWxsIHRoZSBzZXJ2ZXJzLlxuQ2xpZW50LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuc2VydmVyc1tpXS5jbG9zZSgpO1xuICB9XG59O1xuXG4vLyBQZXJmb3JtIGEgZ2VuZXJpYyBzaW5nbGUgcmVzcG9uc2Ugb3BlcmF0aW9uIChnZXQsIHNldCBldGMpIG9uIGEgc2VydmVyXG4vLyBzZXJ2OiB0aGUgc2VydmVyIHRvIHBlcmZvcm0gdGhlIG9wZXJhdGlvbiBvblxuLy8gcmVxdWVzdDogYSBidWZmZXIgY29udGFpbmluZyB0aGUgcmVxdWVzdFxuLy8gc2VxOiB0aGUgc2VxdWVuY2UgbnVtYmVyIG9mIHRoZSBvcGVyYXRpb24uIEl0IGlzIHVzZWQgdG8gcGluIHRoZSBjYWxsYmFja3Ncbi8vICAgICAgdG8gYSBzcGVjaWZpYyBvcGVyYXRpb24gYW5kIHNob3VsZCBuZXZlciBjaGFuZ2UgZHVyaW5nIGEgYHBlcmZvcm1gLlxuLy8gY2FsbGJhY2s6IGEgY2FsbGJhY2sgaW52b2tlZCB3aGVuIGEgcmVzcG9uc2UgaXMgcmVjZWl2ZWQgb3IgdGhlIHJlcXVlc3Rcbi8vICAgICAgICAgICBmYWlsc1xuLy8gcmV0cmllczogbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IHJlcXVlc3Qgb24gZmFpbHVyZVxuQ2xpZW50LnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24oa2V5LCByZXF1ZXN0LCBzZXEsIGNhbGxiYWNrLCByZXRyaWVzKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBzZXJ2ID0gdGhpcy5zZXJ2ZXIoa2V5KTtcbiAgaWYgKCFzZXJ2KSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG5ldyBFcnJvcignTm8gc2VydmVycyBhdmFpbGFibGUnKSwgbnVsbCk7IH1cbiAgICByZXR1cm47XG4gIH1cblxuICByZXRyaWVzID0gcmV0cmllcyB8fCB0aGlzLm9wdGlvbnMucmV0cmllcztcbiAgdmFyIGZhaWxvdmVyID0gdGhpcy5vcHRpb25zLmZhaWxvdmVyO1xuICB2YXIgZmFpbG92ZXJUaW1lID0gdGhpcy5vcHRpb25zLmZhaWxvdmVyVGltZTtcbiAgdmFyIG9yaWdSZXRyaWVzID0gdGhpcy5vcHRpb25zLnJldHJpZXM7XG4gIHZhciBsb2dnZXIgPSB0aGlzLm9wdGlvbnMubG9nZ2VyO1xuICB2YXIgcmV0cnlfZGVsYXkgPSB0aGlzLm9wdGlvbnMucmV0cnlfZGVsYXk7XG5cbiAgdmFyIHJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTsgfVxuICB9O1xuXG4gIHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvcikge1xuICAgIGlmICgtLXJldHJpZXMgPiAwKSB7XG4gICAgICAvLyBXYWl0IGZvciByZXRyeV9kZWxheVxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMucGVyZm9ybShrZXksIHJlcXVlc3QsIHNlcSwgY2FsbGJhY2ssIHJldHJpZXMpO1xuICAgICAgfSwgMTAwMCAqIHJldHJ5X2RlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmxvZygnTWVtSlM6IFNlcnZlciA8JyArIHNlcnYuaG9zdCArICc6JyArIHNlcnYucG9ydCArXG4gICAgICAgICAgICAgICAgICAnPiBmYWlsZWQgYWZ0ZXIgKCcgKyBvcmlnUmV0cmllcyArXG4gICAgICAgICAgICAgICAgICAnKSByZXRyaWVzIHdpdGggZXJyb3IgLSAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICBpZiAoZmFpbG92ZXIpIHtcbiAgICAgICAgc2Vydi53YWtldXBBdCA9IERhdGUubm93KCkgKyBmYWlsb3ZlclRpbWUgKiAxMDAwO1xuICAgICAgICBfdGhpcy5wZXJmb3JtKGtleSwgcmVxdWVzdCwgc2VxLCBjYWxsYmFjaywgb3JpZ1JldHJpZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGVycm9yLCBudWxsKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBzZXJ2Lm9uUmVzcG9uc2Uoc2VxLCByZXNwb25zZUhhbmRsZXIpO1xuICBzZXJ2Lm9uRXJyb3Ioc2VxLCBlcnJvckhhbmRsZXIpO1xuICBzZXJ2LndyaXRlKHJlcXVlc3QpO1xufTtcblxuLy8gSW5jcmVtZW50IHRoZSBzZXEgdmFsdWVcbkNsaWVudC5wcm90b3R5cGUuaW5jclNlcSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlcSsrO1xuXG4gIC8vIFdyYXAgYHRoaXMuc2VxYCB0byAzMi1iaXRzIHNpbmNlIHRoZSBmaWVsZCB3ZSBmaXQgaXQgaW50byBpcyBvbmx5IDMyLWJpdHMuXG4gIHRoaXMuc2VxICY9IDB4ZmZmZmZmZmY7XG59O1xuXG5leHBvcnRzLkNsaWVudCA9IENsaWVudDtcbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuZXhwb3J0cy5VdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbmV4cG9ydHMuSGVhZGVyID0gcmVxdWlyZSgnLi9oZWFkZXInKTtcbiJdLCJuYW1lcyI6WyJlcnJvcnMiLCJyZXF1aXJlIiwiU2VydmVyIiwibm9vcFNlcmlhbGl6ZXIiLCJtYWtlUmVxdWVzdEJ1ZmZlciIsImhhc2hDb2RlIiwibWVyZ2UiLCJtYWtlRXhwaXJhdGlvbiIsIm1ha2VBbW91bnRJbml0aWFsQW5kRXhwaXJhdGlvbiIsIkNsaWVudCIsInNlcnZlcnMiLCJvcHRpb25zIiwic2VxIiwiZmFpbG92ZXJUaW1lIiwicmV0cmllcyIsInJldHJ5X2RlbGF5IiwiZXhwaXJlcyIsImxvZ2dlciIsImNvbnNvbGUiLCJzZXJpYWxpemVyIiwiY3JlYXRlIiwic2VydmVyc1N0ciIsInByb2Nlc3MiLCJlbnYiLCJNRU1DQUNISUVSX1NFUlZFUlMiLCJNRU1DQUNIRV9TRVJWRVJTIiwic2VydmVyVXJpcyIsInNwbGl0IiwibWFwIiwidXJpIiwidXJpUGFydHMiLCJob3N0UG9ydCIsImxlbmd0aCIsInVzZXJQYXNzIiwicGFyc2VJbnQiLCJwcm90b3R5cGUiLCJnZXRTZXJ2ZXIiLCJrZXkiLCJzZXJ2ZXIiLCJ0b3RhbCIsIm9yaWdJZHgiLCJpZHgiLCJzZXJ2Iiwid2FrZXVwQXQiLCJEYXRlIiwibm93IiwicHJvbWlzaWZ5IiwiY29tbWFuZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZXJyIiwicmVzdWx0IiwiZ2V0IiwiY2FsbGJhY2siLCJzZWxmIiwidW5kZWZpbmVkIiwidmFsdWUiLCJmbGFncyIsImluY3JTZXEiLCJyZXF1ZXN0IiwicGVyZm9ybSIsInJlc3BvbnNlIiwiaGVhZGVyIiwic3RhdHVzIiwiZGVzZXJpYWxpemVkIiwiZGVzZXJpYWxpemUiLCJvcGNvZGUiLCJ2YWwiLCJleHRyYXMiLCJlcnJvck1lc3NhZ2UiLCJsb2ciLCJFcnJvciIsInNldCIsInN1Y2Nlc3MiLCJleHBpcmF0aW9uIiwiQnVmZmVyIiwiY29uY2F0IiwiZnJvbSIsInNlcmlhbGl6ZWQiLCJzZXJpYWxpemUiLCJhZGQiLCJyZXBsYWNlIiwiZGVsZXRlIiwiaW5jcmVtZW50IiwiYW1vdW50IiwiaW5pdGlhbCIsImFyZ3VtZW50cyIsImJ1ZkludCIsInJlYWRVSW50MzJCRSIsImRlY3JlbWVudCIsImFwcGVuZCIsInByZXBlbmQiLCJ0b3VjaCIsImZsdXNoIiwicmVzdWx0cyIsImNvdW50IiwibGFzdEVyciIsImkiLCJoYW5kbGVGbHVzaCIsIm9uUmVzcG9uc2UiLCJob3N0IiwicG9ydCIsIm9uRXJyb3IiLCJ3cml0ZSIsInN0YXRzV2l0aEtleSIsImhhbmRsZVN0YXRzIiwiaGFuZGxlIiwidG90YWxCb2R5TGVuZ3RoIiwidG9TdHJpbmciLCJxdWlldCIsInN0YXRzIiwicmVzZXRTdGF0cyIsInF1aXQiLCJoYW5kbGVRdWl0IiwiY2xvc2UiLCJfdGhpcyIsImZhaWxvdmVyIiwib3JpZ1JldHJpZXMiLCJyZXNwb25zZUhhbmRsZXIiLCJlcnJvckhhbmRsZXIiLCJlcnJvciIsInNldFRpbWVvdXQiLCJtZXNzYWdlIiwiZXhwb3J0cyIsIlV0aWxzIiwiSGVhZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/memjs/lib/memjs/memjs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/memjs/lib/memjs/noop-serializer.js":
/*!*********************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/noop-serializer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("var noopSerializer = {\n    serialize: function(opcode, value, extras) {\n        return {\n            value: value,\n            extras: extras\n        };\n    },\n    deserialize: function(opcode, value, extras) {\n        return {\n            value: value,\n            extras: extras\n        };\n    }\n};\nexports.noopSerializer = noopSerializer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL25vb3Atc2VyaWFsaXplci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxpQkFBaUI7SUFDbkJDLFdBQVcsU0FBVUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU07UUFDeEMsT0FBTztZQUFFRCxPQUFPQTtZQUFPQyxRQUFRQTtRQUFPO0lBQ3hDO0lBQ0FDLGFBQWEsU0FBVUgsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLE1BQU07UUFDMUMsT0FBTztZQUFFRCxPQUFPQTtZQUFPQyxRQUFRQTtRQUFPO0lBQ3hDO0FBQ0Y7QUFFQUUsc0JBQXNCLEdBQUdOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9tZW1qcy9saWIvbWVtanMvbm9vcC1zZXJpYWxpemVyLmpzP2UwZTIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIG5vb3BTZXJpYWxpemVyID0ge1xuICBzZXJpYWxpemU6IGZ1bmN0aW9uIChvcGNvZGUsIHZhbHVlLCBleHRyYXMpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGV4dHJhczogZXh0cmFzIH07XG4gIH0sXG4gIGRlc2VyaWFsaXplOiBmdW5jdGlvbiAob3Bjb2RlLCB2YWx1ZSwgZXh0cmFzKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlLCBleHRyYXM6IGV4dHJhcyB9O1xuICB9XG59O1xuXG5leHBvcnRzLm5vb3BTZXJpYWxpemVyID0gbm9vcFNlcmlhbGl6ZXI7XG4iXSwibmFtZXMiOlsibm9vcFNlcmlhbGl6ZXIiLCJzZXJpYWxpemUiLCJvcGNvZGUiLCJ2YWx1ZSIsImV4dHJhcyIsImRlc2VyaWFsaXplIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/memjs/lib/memjs/noop-serializer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/memjs/lib/memjs/protocol.js":
/*!**************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/protocol.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// # MemJS Memcache binary protocol errors\nexports.errors = {};\nexports.errors[0] = \"No error\";\nexports.errors[1] = \"Key not found\";\nexports.errors[2] = \"Key exists\";\nexports.errors[3] = \"Value too large\";\nexports.errors[4] = \"Invalid arguments\";\nexports.errors[5] = \"Item not stored\";\nexports.errors[6] = \"Incr/Decr on non-numeric value\";\nexports.errors[7] = \"The vbucket belongs to another server\";\nexports.errors[8] = \"Authentication error\";\nexports.errors[9] = \"Authentication continue\";\nexports.errors[129] = \"Unknown command\";\nexports.errors[130] = \"Out of memory\";\nexports.errors[131] = \"Not supported\";\nexports.errors[132] = \"Internal error\";\nexports.errors[133] = \"Busy\";\nexports.errors[134] = \"Temporary failure\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3Byb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFBLDBDQUEwQztBQUUxQ0EsY0FBYyxHQUFHLENBQUM7QUFDbEJBLGlCQUFzQixHQUFHO0FBQ3pCQSxpQkFBc0IsR0FBRztBQUN6QkEsaUJBQXNCLEdBQUc7QUFDekJBLGlCQUFzQixHQUFHO0FBQ3pCQSxpQkFBc0IsR0FBRztBQUN6QkEsaUJBQXNCLEdBQUc7QUFDekJBLGlCQUFzQixHQUFHO0FBQ3pCQSxpQkFBc0IsR0FBRztBQUN6QkEsaUJBQXNCLEdBQUc7QUFDekJBLGlCQUFzQixHQUFHO0FBQ3pCQSxtQkFBc0IsR0FBRztBQUN6QkEsbUJBQXNCLEdBQUc7QUFDekJBLG1CQUFzQixHQUFHO0FBQ3pCQSxtQkFBc0IsR0FBRztBQUN6QkEsbUJBQXNCLEdBQUc7QUFDekJBLG1CQUFzQixHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9tZW1qcy9saWIvbWVtanMvcHJvdG9jb2wuanM/OWIzNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAjIE1lbUpTIE1lbWNhY2hlIGJpbmFyeSBwcm90b2NvbCBlcnJvcnNcblxuZXhwb3J0cy5lcnJvcnMgPSB7fTtcbmV4cG9ydHMuZXJyb3JzWzB4MDAwMF0gPSAnTm8gZXJyb3InO1xuZXhwb3J0cy5lcnJvcnNbMHgwMDAxXSA9ICdLZXkgbm90IGZvdW5kJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwMl0gPSAnS2V5IGV4aXN0cyc7XG5leHBvcnRzLmVycm9yc1sweDAwMDNdID0gJ1ZhbHVlIHRvbyBsYXJnZSc7XG5leHBvcnRzLmVycm9yc1sweDAwMDRdID0gJ0ludmFsaWQgYXJndW1lbnRzJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwNV0gPSAnSXRlbSBub3Qgc3RvcmVkJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwNl0gPSAnSW5jci9EZWNyIG9uIG5vbi1udW1lcmljIHZhbHVlJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwN10gPSAnVGhlIHZidWNrZXQgYmVsb25ncyB0byBhbm90aGVyIHNlcnZlcic7XG5leHBvcnRzLmVycm9yc1sweDAwMDhdID0gJ0F1dGhlbnRpY2F0aW9uIGVycm9yJztcbmV4cG9ydHMuZXJyb3JzWzB4MDAwOV0gPSAnQXV0aGVudGljYXRpb24gY29udGludWUnO1xuZXhwb3J0cy5lcnJvcnNbMHgwMDgxXSA9ICdVbmtub3duIGNvbW1hbmQnO1xuZXhwb3J0cy5lcnJvcnNbMHgwMDgyXSA9ICdPdXQgb2YgbWVtb3J5JztcbmV4cG9ydHMuZXJyb3JzWzB4MDA4M10gPSAnTm90IHN1cHBvcnRlZCc7XG5leHBvcnRzLmVycm9yc1sweDAwODRdID0gJ0ludGVybmFsIGVycm9yJztcbmV4cG9ydHMuZXJyb3JzWzB4MDA4NV0gPSAnQnVzeSc7XG5leHBvcnRzLmVycm9yc1sweDAwODZdID0gJ1RlbXBvcmFyeSBmYWlsdXJlJztcbiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiZXJyb3JzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/memjs/lib/memjs/protocol.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/memjs/lib/memjs/server.js":
/*!************************************************!*\
  !*** ./node_modules/memjs/lib/memjs/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("var net = __webpack_require__(/*! net */ \"net\");\nvar events = __webpack_require__(/*! events */ \"events\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar makeRequestBuffer = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").makeRequestBuffer);\nvar parseMessage = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").parseMessage);\nvar merge = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").merge);\nvar timestamp = (__webpack_require__(/*! ./utils */ \"(ssr)/./node_modules/memjs/lib/memjs/utils.js\").timestamp);\nvar Server = function(host, port, username, password, options) {\n    events.EventEmitter.call(this);\n    this.responseBuffer = Buffer.from([]);\n    this.host = host;\n    this.port = port;\n    this.connected = false;\n    this.timeoutSet = false;\n    this.connectCallbacks = [];\n    this.responseCallbacks = {};\n    this.requestTimeouts = [];\n    this.errorCallbacks = {};\n    this.options = merge(options || {}, {\n        timeout: 0.5,\n        keepAlive: false,\n        keepAliveDelay: 30\n    });\n    if (this.options.conntimeout === undefined || this.options.conntimeout === null) {\n        this.options.conntimeout = 2 * this.options.timeout;\n    }\n    this.username = username || this.options.username || process.env.MEMCACHIER_USERNAME || process.env.MEMCACHE_USERNAME;\n    this.password = password || this.options.password || process.env.MEMCACHIER_PASSWORD || process.env.MEMCACHE_PASSWORD;\n    return this;\n};\nutil.inherits(Server, events.EventEmitter);\nServer.prototype.onConnect = function(func) {\n    this.connectCallbacks.push(func);\n};\nServer.prototype.onResponse = function(seq, func) {\n    this.responseCallbacks[seq] = func;\n};\nServer.prototype.respond = function(response) {\n    var callback = this.responseCallbacks[response.header.opaque];\n    if (!callback) {\n        // in case of authentication, no callback is registered\n        return;\n    }\n    callback(response);\n    if (!callback.quiet || response.header.totalBodyLength === 0) {\n        delete this.responseCallbacks[response.header.opaque];\n        this.requestTimeouts.shift();\n        delete this.errorCallbacks[response.header.opaque];\n    }\n};\nServer.prototype.onError = function(seq, func) {\n    this.errorCallbacks[seq] = func;\n};\nServer.prototype.error = function(err) {\n    var errcalls = this.errorCallbacks;\n    this.connectCallbacks = [];\n    this.responseCallbacks = {};\n    this.requestTimeouts = [];\n    this.errorCallbacks = {};\n    this.timeoutSet = false;\n    if (this._socket) {\n        this._socket.destroy();\n        delete this._socket;\n    }\n    var k;\n    for(k in errcalls){\n        if (errcalls.hasOwnProperty(k)) {\n            errcalls[k](err);\n        }\n    }\n};\nServer.prototype.listSasl = function() {\n    var buf = makeRequestBuffer(0x20, \"\", \"\", \"\");\n    this.writeSASL(buf);\n};\nServer.prototype.saslAuth = function() {\n    var authStr = \"\\x00\" + this.username + \"\\x00\" + this.password;\n    var buf = makeRequestBuffer(0x21, \"PLAIN\", \"\", authStr);\n    this.writeSASL(buf);\n};\nServer.prototype.appendToBuffer = function(dataBuf) {\n    var old = this.responseBuffer;\n    this.responseBuffer = Buffer.alloc(old.length + dataBuf.length);\n    old.copy(this.responseBuffer, 0);\n    dataBuf.copy(this.responseBuffer, old.length);\n    return this.responseBuffer;\n};\nServer.prototype.responseHandler = function(dataBuf) {\n    var response = parseMessage(this.appendToBuffer(dataBuf));\n    var respLength;\n    while(response){\n        if (response.header.opcode === 0x20) {\n            this.saslAuth();\n        } else if (response.header.status === 0x20) {\n            this.error(\"Memcached server authentication failed!\");\n        } else if (response.header.opcode === 0x21) {\n            this.emit(\"authenticated\");\n        } else {\n            this.respond(response);\n        }\n        respLength = response.header.totalBodyLength + 24;\n        this.responseBuffer = this.responseBuffer.slice(respLength);\n        response = parseMessage(this.responseBuffer);\n    }\n};\nServer.prototype.sock = function(sasl, go) {\n    var self = this;\n    if (!self._socket) {\n        // CASE 1: completely new socket\n        self.connected = false;\n        self._socket = net.connect(this.port, this.host, function() {\n            // SASL authentication handler\n            self.once(\"authenticated\", function() {\n                if (self._socket) {\n                    self.connected = true;\n                    // cancel connection timeout\n                    self._socket.setTimeout(0);\n                    self.timeoutSet = false;\n                    // run actual request(s)\n                    go(self._socket);\n                    self.connectCallbacks.forEach(function(cb) {\n                        cb(self._socket);\n                    });\n                    self.connectCallbacks = [];\n                }\n            });\n            // setup response handler\n            this.on(\"data\", function(dataBuf) {\n                self.responseHandler(dataBuf);\n            });\n            // kick of SASL if needed\n            if (self.username && self.password) {\n                self.listSasl();\n            } else {\n                self.emit(\"authenticated\");\n            }\n        });\n        // setup error handler\n        self._socket.on(\"error\", function(error) {\n            self.error(error);\n        });\n        self._socket.on(\"close\", function() {\n            self.connected = false;\n            if (self.timeoutSet) {\n                self._socket.setTimeout(0);\n                self.timeoutSet = false;\n            }\n            self._socket = undefined;\n        });\n        // setup connection timeout handler\n        self.timeoutSet = true;\n        self._socket.setTimeout(self.options.conntimeout * 1000, function() {\n            self.timeoutSet = false;\n            if (!self.connected) {\n                this.end();\n                self._socket = undefined;\n                self.error(new Error(\"socket timed out connecting to server.\"));\n            }\n        });\n        // use TCP keep-alive\n        self._socket.setKeepAlive(self.options.keepAlive, self.options.keepAliveDelay * 1000);\n    } else if (!self.connected && !sasl) {\n        // CASE 2: socket exists, but still connecting / authenticating\n        self.onConnect(go);\n    } else {\n        // CASE 3: socket exists and connected / ready to use\n        go(self._socket);\n    }\n};\n// We handle tracking timeouts with an array of deadlines (requestTimeouts), as\n// node doesn't like us setting up lots of timers, and using just one is more\n// efficient anyway.\nvar timeoutHandler = function(server, sock) {\n    if (server.requestTimeouts.length === 0) {\n        // nothing active\n        server.timeoutSet = false;\n        return;\n    }\n    // some requests outstanding, check if any have timed-out\n    var now = timestamp();\n    var soonestTimeout = server.requestTimeouts[0];\n    if (soonestTimeout <= now) {\n        // timeout occurred!\n        sock.end();\n        server.connected = false;\n        server._socket = undefined;\n        server.timeoutSet = false;\n        server.error(new Error(\"socket timed out waiting on response.\"));\n    } else {\n        // no timeout! Setup next one.\n        var deadline = soonestTimeout - now;\n        sock.setTimeout(deadline, function() {\n            timeoutHandler(server, sock);\n        });\n    }\n};\nServer.prototype.write = function(blob) {\n    var self = this;\n    var deadline = Math.round(self.options.timeout * 1000);\n    this.sock(false, function(s) {\n        s.write(blob);\n        self.requestTimeouts.push(timestamp() + deadline);\n        if (!self.timeoutSet) {\n            self.timeoutSet = true;\n            s.setTimeout(deadline, function() {\n                timeoutHandler(self, this);\n            });\n        }\n    });\n};\nServer.prototype.writeSASL = function(blob) {\n    this.sock(true, function(s) {\n        s.write(blob);\n    });\n};\nServer.prototype.close = function() {\n    if (this._socket) {\n        this._socket.end();\n    }\n};\nServer.prototype.toString = function() {\n    return \"<Server \" + this.host + \":\" + this.port + \">\";\n};\nexports.Server = Server;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3NlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxJQUFJQSxNQUFNQyxtQkFBT0EsQ0FBQztBQUNsQixJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUNuQixJQUFJRyxvQkFBb0JILHVHQUFvQztBQUM1RCxJQUFJSSxlQUFlSixrR0FBK0I7QUFDbEQsSUFBSUssUUFBUUwsMkZBQXdCO0FBQ3BDLElBQUlNLFlBQVlOLCtGQUE0QjtBQUU1QyxJQUFJTyxTQUFTLFNBQVNDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsT0FBTztJQUMzRFgsT0FBT1ksWUFBWSxDQUFDQyxJQUFJLENBQUMsSUFBSTtJQUM3QixJQUFJLENBQUNDLGNBQWMsR0FBR0MsT0FBT0MsSUFBSSxDQUFDLEVBQUU7SUFDcEMsSUFBSSxDQUFDVCxJQUFJLEdBQUdBO0lBQ1osSUFBSSxDQUFDQyxJQUFJLEdBQUdBO0lBQ1osSUFBSSxDQUFDUyxTQUFTLEdBQUc7SUFDakIsSUFBSSxDQUFDQyxVQUFVLEdBQUc7SUFDbEIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBRyxFQUFFO0lBQzFCLElBQUksQ0FBQ0MsaUJBQWlCLEdBQUcsQ0FBQztJQUMxQixJQUFJLENBQUNDLGVBQWUsR0FBRyxFQUFFO0lBQ3pCLElBQUksQ0FBQ0MsY0FBYyxHQUFHLENBQUM7SUFDdkIsSUFBSSxDQUFDWCxPQUFPLEdBQUdQLE1BQU1PLFdBQVcsQ0FBQyxHQUFHO1FBQUNZLFNBQVM7UUFBS0MsV0FBVztRQUFPQyxnQkFBZ0I7SUFBRTtJQUN2RixJQUFJLElBQUksQ0FBQ2QsT0FBTyxDQUFDZSxXQUFXLEtBQUtDLGFBQWEsSUFBSSxDQUFDaEIsT0FBTyxDQUFDZSxXQUFXLEtBQUssTUFBTTtRQUMvRSxJQUFJLENBQUNmLE9BQU8sQ0FBQ2UsV0FBVyxHQUFHLElBQUksSUFBSSxDQUFD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RCxRQUFRLEdBQUc7SUFDMUIsT0FBTyxhQUFhLElBQUksQ0FBQzNGLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQ0MsSUFBSSxHQUFHO0FBQ3BEO0FBRUEyRixjQUFjLEdBQUc3RiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpb25lei1uZXh0anMvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3NlcnZlci5qcz8wMGQxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBuZXQgPSByZXF1aXJlKCduZXQnKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIG1ha2VSZXF1ZXN0QnVmZmVyID0gcmVxdWlyZSgnLi91dGlscycpLm1ha2VSZXF1ZXN0QnVmZmVyO1xudmFyIHBhcnNlTWVzc2FnZSA9IHJlcXVpcmUoJy4vdXRpbHMnKS5wYXJzZU1lc3NhZ2U7XG52YXIgbWVyZ2UgPSByZXF1aXJlKCcuL3V0aWxzJykubWVyZ2U7XG52YXIgdGltZXN0YW1wID0gcmVxdWlyZSgnLi91dGlscycpLnRpbWVzdGFtcDtcblxudmFyIFNlcnZlciA9IGZ1bmN0aW9uKGhvc3QsIHBvcnQsIHVzZXJuYW1lLCBwYXNzd29yZCwgb3B0aW9ucykge1xuICBldmVudHMuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMucmVzcG9uc2VCdWZmZXIgPSBCdWZmZXIuZnJvbShbXSk7XG4gIHRoaXMuaG9zdCA9IGhvc3Q7XG4gIHRoaXMucG9ydCA9IHBvcnQ7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMudGltZW91dFNldCA9IGZhbHNlO1xuICB0aGlzLmNvbm5lY3RDYWxsYmFja3MgPSBbXTtcbiAgdGhpcy5yZXNwb25zZUNhbGxiYWNrcyA9IHt9O1xuICB0aGlzLnJlcXVlc3RUaW1lb3V0cyA9IFtdO1xuICB0aGlzLmVycm9yQ2FsbGJhY2tzID0ge307XG4gIHRoaXMub3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMgfHwge30sIHt0aW1lb3V0OiAwLjUsIGtlZXBBbGl2ZTogZmFsc2UsIGtlZXBBbGl2ZURlbGF5OiAzMH0pO1xuICBpZiAodGhpcy5vcHRpb25zLmNvbm50aW1lb3V0ID09PSB1bmRlZmluZWQgfHwgdGhpcy5vcHRpb25zLmNvbm50aW1lb3V0ID09PSBudWxsKSB7XG4gICAgdGhpcy5vcHRpb25zLmNvbm50aW1lb3V0ID0gMiAqIHRoaXMub3B0aW9ucy50aW1lb3V0O1xuICB9XG4gIHRoaXMudXNlcm5hbWUgPSB1c2VybmFtZSB8fCB0aGlzLm9wdGlvbnMudXNlcm5hbWUgfHwgcHJvY2Vzcy5lbnYuTUVNQ0FDSElFUl9VU0VSTkFNRSB8fCBwcm9jZXNzLmVudi5NRU1DQUNIRV9VU0VSTkFNRTtcbiAgdGhpcy5wYXNzd29yZCA9IHBhc3N3b3JkIHx8IHRoaXMub3B0aW9ucy5wYXNzd29yZCB8fCBwcm9jZXNzLmVudi5NRU1DQUNISUVSX1BBU1NXT1JEIHx8IHByb2Nlc3MuZW52Lk1FTUNBQ0hFX1BBU1NXT1JEO1xuICByZXR1cm4gdGhpcztcbn07XG5cbnV0aWwuaW5oZXJpdHMoU2VydmVyLCBldmVudHMuRXZlbnRFbWl0dGVyKTtcblxuU2VydmVyLnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbihmdW5jKSB7XG4gIHRoaXMuY29ubmVjdENhbGxiYWNrcy5wdXNoKGZ1bmMpO1xufTtcblxuU2VydmVyLnByb3RvdHlwZS5vblJlc3BvbnNlID0gZnVuY3Rpb24oc2VxLCBmdW5jKSB7XG4gIHRoaXMucmVzcG9uc2VDYWxsYmFja3Nbc2VxXSA9IGZ1bmM7XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLnJlc3BvbmQgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICB2YXIgY2FsbGJhY2sgPSB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3Jlc3BvbnNlLmhlYWRlci5vcGFxdWVdO1xuICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgLy8gaW4gY2FzZSBvZiBhdXRoZW50aWNhdGlvbiwgbm8gY2FsbGJhY2sgaXMgcmVnaXN0ZXJlZFxuICAgIHJldHVybjtcbiAgfVxuICBjYWxsYmFjayhyZXNwb25zZSk7XG4gIGlmICghY2FsbGJhY2sucXVpZXQgfHwgcmVzcG9uc2UuaGVhZGVyLnRvdGFsQm9keUxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSh0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW3Jlc3BvbnNlLmhlYWRlci5vcGFxdWVdKTtcbiAgICB0aGlzLnJlcXVlc3RUaW1lb3V0cy5zaGlmdCgpO1xuICAgIGRlbGV0ZSh0aGlzLmVycm9yQ2FsbGJhY2tzW3Jlc3BvbnNlLmhlYWRlci5vcGFxdWVdKTtcbiAgfVxufTtcblxuU2VydmVyLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24oc2VxLCBmdW5jKSB7XG4gIHRoaXMuZXJyb3JDYWxsYmFja3Nbc2VxXSA9IGZ1bmM7XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gIHZhciBlcnJjYWxscyA9IHRoaXMuZXJyb3JDYWxsYmFja3M7XG4gIHRoaXMuY29ubmVjdENhbGxiYWNrcyA9IFtdO1xuICB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzID0ge307XG4gIHRoaXMucmVxdWVzdFRpbWVvdXRzID0gW107XG4gIHRoaXMuZXJyb3JDYWxsYmFja3MgPSB7fTtcbiAgdGhpcy50aW1lb3V0U2V0ID0gZmFsc2U7XG4gIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIGRlbGV0ZSh0aGlzLl9zb2NrZXQpO1xuICB9XG4gIHZhciBrO1xuICBmb3IgKGsgaW4gZXJyY2FsbHMpIHtcbiAgICBpZiAoZXJyY2FsbHMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgIGVycmNhbGxzW2tdKGVycik7XG4gICAgfVxuICB9XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLmxpc3RTYXNsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBidWYgPSBtYWtlUmVxdWVzdEJ1ZmZlcigweDIwLCAnJywgJycsICcnKTtcbiAgdGhpcy53cml0ZVNBU0woYnVmKTtcbn07XG5cblNlcnZlci5wcm90b3R5cGUuc2FzbEF1dGggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGhTdHIgPSAnXFx4MDAnICsgdGhpcy51c2VybmFtZSArICdcXHgwMCcgKyB0aGlzLnBhc3N3b3JkO1xuICB2YXIgYnVmID0gbWFrZVJlcXVlc3RCdWZmZXIoMHgyMSwgJ1BMQUlOJywgJycsIGF1dGhTdHIpO1xuICB0aGlzLndyaXRlU0FTTChidWYpO1xufTtcblxuU2VydmVyLnByb3RvdHlwZS5hcHBlbmRUb0J1ZmZlciA9IGZ1bmN0aW9uKGRhdGFCdWYpIHtcbiAgdmFyIG9sZCA9IHRoaXMucmVzcG9uc2VCdWZmZXI7XG4gIHRoaXMucmVzcG9uc2VCdWZmZXIgPSBCdWZmZXIuYWxsb2Mob2xkLmxlbmd0aCArIGRhdGFCdWYubGVuZ3RoKTtcbiAgb2xkLmNvcHkodGhpcy5yZXNwb25zZUJ1ZmZlciwgMCk7XG4gIGRhdGFCdWYuY29weSh0aGlzLnJlc3BvbnNlQnVmZmVyLCBvbGQubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXMucmVzcG9uc2VCdWZmZXI7XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLnJlc3BvbnNlSGFuZGxlciA9IGZ1bmN0aW9uKGRhdGFCdWYpIHtcbiAgdmFyIHJlc3BvbnNlID0gcGFyc2VNZXNzYWdlKHRoaXMuYXBwZW5kVG9CdWZmZXIoZGF0YUJ1ZikpO1xuICB2YXIgcmVzcExlbmd0aDtcbiAgd2hpbGUgKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLmhlYWRlci5vcGNvZGUgPT09IDB4MjApIHtcbiAgICAgIHRoaXMuc2FzbEF1dGgoKTtcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLmhlYWRlci5zdGF0dXMgPT09IDB4MjApIHtcbiAgICAgIHRoaXMuZXJyb3IoJ01lbWNhY2hlZCBzZXJ2ZXIgYXV0aGVudGljYXRpb24gZmFpbGVkIScpO1xuICAgIH0gZWxzZSBpZiAocmVzcG9uc2UuaGVhZGVyLm9wY29kZSA9PT0gMHgyMSkge1xuICAgICAgdGhpcy5lbWl0KCdhdXRoZW50aWNhdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzcG9uZChyZXNwb25zZSk7XG4gICAgfVxuICAgIHJlc3BMZW5ndGggPSByZXNwb25zZS5oZWFkZXIudG90YWxCb2R5TGVuZ3RoICsgMjQ7XG4gICAgdGhpcy5yZXNwb25zZUJ1ZmZlciA9IHRoaXMucmVzcG9uc2VCdWZmZXIuc2xpY2UocmVzcExlbmd0aCk7XG4gICAgcmVzcG9uc2UgPSBwYXJzZU1lc3NhZ2UodGhpcy5yZXNwb25zZUJ1ZmZlcik7XG4gIH1cbn07XG5cblNlcnZlci5wcm90b3R5cGUuc29jayA9IGZ1bmN0aW9uKHNhc2wsIGdvKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuX3NvY2tldCkge1xuICAgIC8vIENBU0UgMTogY29tcGxldGVseSBuZXcgc29ja2V0XG4gICAgc2VsZi5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBzZWxmLl9zb2NrZXQgPSBuZXQuY29ubmVjdCh0aGlzLnBvcnQsIHRoaXMuaG9zdCwgZnVuY3Rpb24oKSB7XG5cbiAgICAgIC8vIFNBU0wgYXV0aGVudGljYXRpb24gaGFuZGxlclxuICAgICAgc2VsZi5vbmNlKCdhdXRoZW50aWNhdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLl9zb2NrZXQpIHtcbiAgICAgICAgICBzZWxmLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgICAgLy8gY2FuY2VsIGNvbm5lY3Rpb24gdGltZW91dFxuICAgICAgICAgIHNlbGYuX3NvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgICAgICAgIHNlbGYudGltZW91dFNldCA9IGZhbHNlO1xuICAgICAgICAgIC8vIHJ1biBhY3R1YWwgcmVxdWVzdChzKVxuICAgICAgICAgIGdvKHNlbGYuX3NvY2tldCk7XG4gICAgICAgICAgc2VsZi5jb25uZWN0Q2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgIGNiKHNlbGYuX3NvY2tldCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2VsZi5jb25uZWN0Q2FsbGJhY2tzID0gW107XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyXG4gICAgICB0aGlzLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YUJ1Zikge1xuICAgICAgICBzZWxmLnJlc3BvbnNlSGFuZGxlcihkYXRhQnVmKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBraWNrIG9mIFNBU0wgaWYgbmVlZGVkXG4gICAgICBpZiAoc2VsZi51c2VybmFtZSAmJiBzZWxmLnBhc3N3b3JkKSB7XG4gICAgICAgIHNlbGYubGlzdFNhc2woKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnYXV0aGVudGljYXRlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gc2V0dXAgZXJyb3IgaGFuZGxlclxuICAgIHNlbGYuX3NvY2tldC5vbignZXJyb3InLCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgc2VsZi5lcnJvcihlcnJvcik7XG4gICAgfSk7XG5cbiAgICBzZWxmLl9zb2NrZXQub24oJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgaWYgKHNlbGYudGltZW91dFNldCkge1xuICAgICAgICBzZWxmLl9zb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICAgICAgc2VsZi50aW1lb3V0U2V0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzZWxmLl9zb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG5cbiAgICAvLyBzZXR1cCBjb25uZWN0aW9uIHRpbWVvdXQgaGFuZGxlclxuICAgIHNlbGYudGltZW91dFNldCA9IHRydWU7XG4gICAgc2VsZi5fc29ja2V0LnNldFRpbWVvdXQoc2VsZi5vcHRpb25zLmNvbm50aW1lb3V0ICogMTAwMCwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLnRpbWVvdXRTZXQgPSBmYWxzZTtcbiAgICAgIGlmICghc2VsZi5jb25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgc2VsZi5fc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBzZWxmLmVycm9yKG5ldyBFcnJvcignc29ja2V0IHRpbWVkIG91dCBjb25uZWN0aW5nIHRvIHNlcnZlci4nKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyB1c2UgVENQIGtlZXAtYWxpdmVcbiAgICBzZWxmLl9zb2NrZXQuc2V0S2VlcEFsaXZlKHNlbGYub3B0aW9ucy5rZWVwQWxpdmUsIHNlbGYub3B0aW9ucy5rZWVwQWxpdmVEZWxheSAqIDEwMDApO1xuXG4gIH0gZWxzZSBpZiAoIXNlbGYuY29ubmVjdGVkICYmICFzYXNsKSB7XG4gICAgLy8gQ0FTRSAyOiBzb2NrZXQgZXhpc3RzLCBidXQgc3RpbGwgY29ubmVjdGluZyAvIGF1dGhlbnRpY2F0aW5nXG4gICAgc2VsZi5vbkNvbm5lY3QoZ28pO1xuXG4gIH0gZWxzZSB7XG4gICAgLy8gQ0FTRSAzOiBzb2NrZXQgZXhpc3RzIGFuZCBjb25uZWN0ZWQgLyByZWFkeSB0byB1c2VcbiAgICBnbyhzZWxmLl9zb2NrZXQpO1xuICB9XG59O1xuXG4vLyBXZSBoYW5kbGUgdHJhY2tpbmcgdGltZW91dHMgd2l0aCBhbiBhcnJheSBvZiBkZWFkbGluZXMgKHJlcXVlc3RUaW1lb3V0cyksIGFzXG4vLyBub2RlIGRvZXNuJ3QgbGlrZSB1cyBzZXR0aW5nIHVwIGxvdHMgb2YgdGltZXJzLCBhbmQgdXNpbmcganVzdCBvbmUgaXMgbW9yZVxuLy8gZWZmaWNpZW50IGFueXdheS5cbnZhciB0aW1lb3V0SGFuZGxlciA9IGZ1bmN0aW9uKHNlcnZlciwgc29jaykge1xuICBpZiAoc2VydmVyLnJlcXVlc3RUaW1lb3V0cy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBub3RoaW5nIGFjdGl2ZVxuICAgIHNlcnZlci50aW1lb3V0U2V0ID0gZmFsc2U7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc29tZSByZXF1ZXN0cyBvdXRzdGFuZGluZywgY2hlY2sgaWYgYW55IGhhdmUgdGltZWQtb3V0XG4gIHZhciBub3cgPSB0aW1lc3RhbXAoKTtcbiAgdmFyIHNvb25lc3RUaW1lb3V0ID0gc2VydmVyLnJlcXVlc3RUaW1lb3V0c1swXTtcblxuICBpZiAoc29vbmVzdFRpbWVvdXQgPD0gbm93KSB7XG4gICAgLy8gdGltZW91dCBvY2N1cnJlZCFcbiAgICBzb2NrLmVuZCgpO1xuICAgIHNlcnZlci5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICBzZXJ2ZXIuX3NvY2tldCA9IHVuZGVmaW5lZDtcbiAgICBzZXJ2ZXIudGltZW91dFNldCA9IGZhbHNlO1xuICAgIHNlcnZlci5lcnJvcihuZXcgRXJyb3IoJ3NvY2tldCB0aW1lZCBvdXQgd2FpdGluZyBvbiByZXNwb25zZS4nKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm8gdGltZW91dCEgU2V0dXAgbmV4dCBvbmUuXG4gICAgdmFyIGRlYWRsaW5lID0gc29vbmVzdFRpbWVvdXQgLSBub3c7XG4gICAgc29jay5zZXRUaW1lb3V0KGRlYWRsaW5lLCBmdW5jdGlvbigpIHtcbiAgICAgIHRpbWVvdXRIYW5kbGVyKHNlcnZlciwgc29jayk7XG4gICAgfSk7XG4gIH1cbn07XG5cblNlcnZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihibG9iKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGRlYWRsaW5lID0gTWF0aC5yb3VuZChzZWxmLm9wdGlvbnMudGltZW91dCAqIDEwMDApO1xuICB0aGlzLnNvY2soZmFsc2UsIGZ1bmN0aW9uKHMpIHtcbiAgICBzLndyaXRlKGJsb2IpO1xuICAgIHNlbGYucmVxdWVzdFRpbWVvdXRzLnB1c2godGltZXN0YW1wKCkgKyBkZWFkbGluZSk7XG4gICAgaWYgKCFzZWxmLnRpbWVvdXRTZXQpIHtcbiAgICAgIHNlbGYudGltZW91dFNldCA9IHRydWU7XG4gICAgICBzLnNldFRpbWVvdXQoZGVhZGxpbmUsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aW1lb3V0SGFuZGxlcihzZWxmLCB0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5TZXJ2ZXIucHJvdG90eXBlLndyaXRlU0FTTCA9IGZ1bmN0aW9uKGJsb2IpIHtcbiAgdGhpcy5zb2NrKHRydWUsIGZ1bmN0aW9uKHMpIHtcbiAgICBzLndyaXRlKGJsb2IpO1xuICB9KTtcbn07XG5cblNlcnZlci5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX3NvY2tldCkgeyB0aGlzLl9zb2NrZXQuZW5kKCk7IH1cbn07XG5cblNlcnZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICc8U2VydmVyICcgKyB0aGlzLmhvc3QgKyAnOicgKyB0aGlzLnBvcnQgKyAnPic7XG59O1xuXG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbiJdLCJuYW1lcyI6WyJuZXQiLCJyZXF1aXJlIiwiZXZlbnRzIiwidXRpbCIsIm1ha2VSZXF1ZXN0QnVmZmVyIiwicGFyc2VNZXNzYWdlIiwibWVyZ2UiLCJ0aW1lc3RhbXAiLCJTZXJ2ZXIiLCJob3N0IiwicG9ydCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJvcHRpb25zIiwiRXZlbnRFbWl0dGVyIiwiY2FsbCIsInJlc3BvbnNlQnVmZmVyIiwiQnVmZmVyIiwiZnJvbSIsImNvbm5lY3RlZCIsInRpbWVvdXRTZXQiLCJjb25uZWN0Q2FsbGJhY2tzIiwicmVzcG9uc2VDYWxsYmFja3MiLCJyZXF1ZXN0VGltZW91dHMiLCJlcnJvckNhbGxiYWNrcyIsInRpbWVvdXQiLCJrZWVwQWxpdmUiLCJrZWVwQWxpdmVEZWxheSIsImNvbm50aW1lb3V0IiwidW5kZWZpbmVkIiwicHJvY2VzcyIsImVudiIsIk1FTUNBQ0hJRVJfVVNFUk5BTUUiLCJNRU1DQUNIRV9VU0VSTkFNRSIsIk1FTUNBQ0hJRVJfUEFTU1dPUkQiLCJNRU1DQUNIRV9QQVNTV09SRCIsImluaGVyaXRzIiwicHJvdG90eXBlIiwib25Db25uZWN0IiwiZnVuYyIsInB1c2giLCJvblJlc3BvbnNlIiwic2VxIiwicmVzcG9uZCIsInJlc3BvbnNlIiwiY2FsbGJhY2siLCJoZWFkZXIiLCJvcGFxdWUiLCJxdWlldCIsInRvdGFsQm9keUxlbmd0aCIsInNoaWZ0Iiwib25FcnJvciIsImVycm9yIiwiZXJyIiwiZXJyY2FsbHMiLCJfc29ja2V0IiwiZGVzdHJveSIsImsiLCJoYXNPd25Qcm9wZXJ0eSIsImxpc3RTYXNsIiwiYnVmIiwid3JpdGVTQVNMIiwic2FzbEF1dGgiLCJhdXRoU3RyIiwiYXBwZW5kVG9CdWZmZXIiLCJkYXRhQnVmIiwib2xkIiwiYWxsb2MiLCJsZW5ndGgiLCJjb3B5IiwicmVzcG9uc2VIYW5kbGVyIiwicmVzcExlbmd0aCIsIm9wY29kZSIsInN0YXR1cyIsImVtaXQiLCJzbGljZSIsInNvY2siLCJzYXNsIiwiZ28iLCJzZWxmIiwiY29ubmVjdCIsIm9uY2UiLCJzZXRUaW1lb3V0IiwiZm9yRWFjaCIsImNiIiwib24iLCJlbmQiLCJFcnJvciIsInNldEtlZXBBbGl2ZSIsInRpbWVvdXRIYW5kbGVyIiwic2VydmVyIiwibm93Iiwic29vbmVzdFRpbWVvdXQiLCJkZWFkbGluZSIsIndyaXRlIiwiYmxvYiIsIk1hdGgiLCJyb3VuZCIsInMiLCJjbG9zZSIsInRvU3RyaW5nIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/memjs/lib/memjs/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/memjs/lib/memjs/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/memjs/lib/memjs/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// # MemJS utility functions\nvar header = __webpack_require__(/*! ./header */ \"(ssr)/./node_modules/memjs/lib/memjs/header.js\");\nvar bufferify = function(val) {\n    return Buffer.isBuffer(val) ? val : Buffer.from(val);\n};\nexports.makeRequestBuffer = function(opcode, key, extras, value, opaque) {\n    key = bufferify(key);\n    extras = bufferify(extras);\n    value = bufferify(value);\n    var buf = Buffer.alloc(24 + key.length + extras.length + value.length);\n    buf.fill();\n    var requestHeader = {\n        magic: 0x80,\n        opcode: opcode,\n        keyLength: key.length,\n        extrasLength: extras.length,\n        totalBodyLength: key.length + value.length + extras.length,\n        opaque: opaque\n    };\n    header.toBuffer(requestHeader).copy(buf);\n    extras.copy(buf, 24);\n    key.copy(buf, 24 + extras.length);\n    value.copy(buf, 24 + extras.length + key.length);\n    return buf;\n};\nexports.makeAmountInitialAndExpiration = function(amount, amountIfEmpty, expiration) {\n    var buf = Buffer.alloc(20);\n    buf.writeUInt32BE(0, 0);\n    buf.writeUInt32BE(amount, 4);\n    buf.writeUInt32BE(0, 8);\n    buf.writeUInt32BE(amountIfEmpty, 12);\n    buf.writeUInt32BE(expiration, 16);\n    return buf;\n};\nexports.makeExpiration = function(expiration) {\n    var buf = Buffer.alloc(4);\n    buf.writeUInt32BE(expiration, 0);\n    return buf;\n};\nexports.hashCode = function(str) {\n    var ret, i, len;\n    for(ret = 0, i = 0, len = str.length; i < len; i++){\n        ret = 31 * ret + str.charCodeAt(i) << 0;\n    }\n    return Math.abs(ret);\n};\nexports.parseMessage = function(dataBuf) {\n    if (dataBuf.length < 24) {\n        return false;\n    }\n    var responseHeader = header.fromBuffer(dataBuf);\n    if (dataBuf.length < responseHeader.totalBodyLength + 24 || responseHeader.totalBodyLength < responseHeader.keyLength + responseHeader.extrasLength) {\n        return false;\n    }\n    var pointer = 24;\n    var extras = dataBuf.slice(pointer, pointer + responseHeader.extrasLength);\n    pointer += responseHeader.extrasLength;\n    var key = dataBuf.slice(pointer, pointer + responseHeader.keyLength);\n    pointer += responseHeader.keyLength;\n    var val = dataBuf.slice(pointer, 24 + responseHeader.totalBodyLength);\n    return {\n        header: responseHeader,\n        key: key,\n        extras: extras,\n        val: val\n    };\n};\nexports.merge = function(original, deflt) {\n    var attr, originalValue;\n    for(attr in deflt){\n        if (deflt.hasOwnProperty(attr)) {\n            originalValue = original[attr];\n            if (originalValue === undefined || originalValue === null) {\n                original[attr] = deflt[attr];\n            }\n        }\n    }\n    return original;\n};\n// timestamp provides a monotonic timestamp with millisecond accuracy, useful\n// for timers.\nexports.timestamp = function() {\n    var times = process.hrtime();\n    return times[0] * 1000 + Math.round(times[1] / 1000000);\n};\nif (!Buffer.concat) {\n    Buffer.concat = function(list, length) {\n        if (!Array.isArray(list)) {\n            throw new Error(\"Usage: Buffer.concat(list, [length])\");\n        }\n        if (list.length === 0) {\n            return Buffer.alloc(0);\n        }\n        if (list.length === 1) {\n            return list[0];\n        }\n        var i, buf;\n        if (typeof length !== \"number\") {\n            length = 0;\n            for(i = 0; i < list.length; i++){\n                buf = list[i];\n                length += buf.length;\n            }\n        }\n        var buffer = Buffer.alloc(length);\n        var pos = 0;\n        for(i = 0; i < list.length; i++){\n            buf = list[i];\n            buf.copy(buffer, pos);\n            pos += buf.length;\n        }\n        return buffer;\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWVtanMvbGliL21lbWpzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDRCQUE0QjtBQUU1QixJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUVyQixJQUFJQyxZQUFZLFNBQVNDLEdBQUc7SUFDMUIsT0FBT0MsT0FBT0MsUUFBUSxDQUFDRixPQUFPQSxNQUFNQyxPQUFPRSxJQUFJLENBQUNIO0FBQ2xEO0FBRUFJLHlCQUF5QixHQUFHLFNBQVNFLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNyRUgsTUFBTVIsVUFBVVE7SUFDaEJDLFNBQVNULFVBQVVTO0lBQ25CQyxRQUFRVixVQUFVVTtJQUNsQixJQUFJRSxNQUFNVixPQUFPVyxLQUFLLENBQUMsS0FBS0wsSUFBSU0sTUFBTSxHQUFHTCxPQUFPSyxNQUFNLEdBQUdKLE1BQU1JLE1BQU07SUFDckVGLElBQUlHLElBQUk7SUFDUixJQUFJQyxnQkFBZ0I7UUFDbEJDLE9BQU87UUFDUFYsUUFBUUE7UUFDUlcsV0FBV1YsSUFBSU0sTUFBTTtRQUNyQkssY0FBY1YsT0FBT0ssTUFBTTtRQUMzQk0saUJBQWlCWixJQUFJTSxNQUFNLEdBQUdKLE1BQU1JLE1BQU0sR0FBR0wsT0FBT0ssTUFBTTtRQUMxREgsUUFBUUE7SUFDVjtJQUNBYixPQUFPdUIsUUFBUSxDQUFDTCxlQUFlTSxJQUFJLENBQUNWO0lBQ3BDSCxPQUFPYSxJQUFJLENBQUNWLEtBQUs7SUFDakJKLElBQUljLElBQUksQ0FBQ1YsS0FBSyxLQUFLSCxPQUFPSyxNQUFNO0lBQ2hDSixNQUFNWSxJQUFJLENBQUNWLEtBQUssS0FBS0gsT0FBT0ssTUFBTSxHQUFHTixJQUFJTSxNQUFNO0lBQy9DLE9BQU9GO0FBQ1Q7QUFFQVAsc0NBQXNDLEdBQUcsU0FBU21CLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxVQUFVO0lBQ2pGLElBQUlkLE1BQU1WLE9BQU9XLEtBQUssQ0FBQztJQUN2QkQsSUFBSWUsYUFBYSxDQUFDLEdBQUc7SUFDckJmLElBQUllLGFBQWEsQ0FBQ0gsUUFBUTtJQUMxQlosSUFBSWUsYUFBYSxDQUFDLEdBQUc7SUFDckJmLElBQUllLGFBQWEsQ0FBQ0YsZUFBZTtJQUNqQ2IsSUFBSWUsYUFBYSxDQUFDRCxZQUFZO0lBQzlCLE9BQU9kO0FBQ1Q7QUFFQVAsc0JBQXNCLEdBQUcsU0FBU3FCLFVBQVU7SUFDMUMsSUFBSWQsTUFBTVYsT0FBT1csS0FBSyxDQUFDO0lBQ3ZCRCxJQUFJZSxhQUFhLENBQUNELFlBQVk7SUFDOUIsT0FBT2Q7QUFDVDtBQUVBUCxnQkFBZ0IsR0FBRyxTQUFTeUIsR0FBRztJQUM3QixJQUFJQyxLQUFLQyxHQUFHQztJQUNaLElBQUlGLE1BQU0sR0FBR0MsSUFBSSxHQUFHQyxNQUFNSCxJQUFJaEIsTUFBTSxFQUFFa0IsSUFBSUMsS0FBS0QsSUFBSztRQUNsREQsTUFBTSxLQUFNQSxNQUFNRCxJQUFJSSxVQUFVLENBQUNGLE1BQU87SUFDMUM7SUFDQSxPQUFPRyxLQUFLQyxHQUFHLENBQUNMO0FBQ2xCO0FBRUExQixvQkFBb0IsR0FBRyxTQUFTaUMsT0FBTztJQUNyQyxJQUFJQSxRQUFReEIsTUFBTSxHQUFHLElBQUk7UUFDdkIsT0FBTztJQUNUO0lBQ0EsSUFBSXlCLGlCQUFpQnpDLE9BQU8wQyxVQUFVLENBQUNGO0lBQ3ZDLElBQUlBLFFBQVF4QixNQUFNLEdBQUd5QixlQUFlbkIsZUFBZSxHQUFHLE1BQ2xEbUIsZUFBZW5CLGVBQWUsR0FDNUJtQixlQUFlckIsU0FBUyxHQUFHcUIsZUFBZXBCLFlBQVksRUFBRTtRQUM1RCxPQUFPO0lBQ1Q7SUFFQSxJQUFJc0IsVUFBVTtJQUNkLElBQUloQyxTQUFTNkIsUUFBUUksS0FBSyxDQUFDRCxTQUFTQSxVQUFVRixlQUFlcEIsWUFBWTtJQUN6RXNCLFdBQVdGLGVBQWVwQixZQUFZO0lBQ3RDLElBQUlYLE1BQU04QixRQUFRSSxLQUFLLENBQUNELFNBQVNBLFVBQVVGLGVBQWVyQixTQUFTO0lBQ25FdUIsV0FBV0YsZUFBZXJCLFNBQVM7SUFDbkMsSUFBSWpCLE1BQU1xQyxRQUFRSSxLQUFLLENBQUNELFNBQVMsS0FBS0YsZUFBZW5CLGVBQWU7SUFFcEUsT0FBTztRQUFDdEIsUUFBUXlDO1FBQWdCL0IsS0FBS0E7UUFBS0MsUUFBUUE7UUFBUVIsS0FBS0E7SUFBRztBQUNwRTtBQUVBSSxhQUFhLEdBQUcsU0FBU3VDLFFBQVEsRUFBRUMsS0FBSztJQUN0QyxJQUFJQyxNQUFNQztJQUNWLElBQUtELFFBQVFELE1BQU87UUFDbEIsSUFBSUEsTUFBTUcsY0FBYyxDQUFDRixPQUFPO1lBQzlCQyxnQkFBZ0JILFFBQVEsQ0FBQ0UsS0FBSztZQUU5QixJQUFJQyxrQkFBa0JFLGFBQWFGLGtCQUFrQixNQUFNO2dCQUN6REgsUUFBUSxDQUFDRSxLQUFLLEdBQUdELEtBQUssQ0FBQ0MsS0FBSztZQUM5QjtRQUNGO0lBQ0Y7SUFDQSxPQUFPRjtBQUNUO0FBRUEsNkVBQTZFO0FBQzdFLGNBQWM7QUFDZHZDLGlCQUFpQixHQUFHO0lBQ2xCLElBQUk4QyxRQUFRQyxRQUFRQyxNQUFNO0lBQzFCLE9BQU8sS0FBTSxDQUFDLEVBQUUsR0FBRyxPQUFRbEIsS0FBS21CLEtBQUssQ0FBRUgsS0FBSyxDQUFDLEVBQUUsR0FBRztBQUNwRDtBQUVBLElBQUcsQ0FBQ2pELE9BQU9xRCxNQUFNLEVBQUU7SUFDakJyRCxPQUFPcUQsTUFBTSxHQUFHLFNBQVNDLElBQUksRUFBRTFDLE1BQU07UUFDbkMsSUFBSSxDQUFDMkMsTUFBTUMsT0FBTyxDQUFDRixPQUFPO1lBQ3hCLE1BQU0sSUFBSUcsTUFBTTtRQUNsQjtRQUVBLElBQUlILEtBQUsxQyxNQUFNLEtBQUssR0FBRztZQUNyQixPQUFPWixPQUFPVyxLQUFLLENBQUM7UUFDdEI7UUFDQSxJQUFJMkMsS0FBSzFDLE1BQU0sS0FBSyxHQUFHO1lBQ3JCLE9BQU8wQyxJQUFJLENBQUMsRUFBRTtRQUNoQjtRQUVBLElBQUl4QixHQUFHcEI7UUFFUCxJQUFJLE9BQU9FLFdBQVcsVUFBVTtZQUM5QkEsU0FBUztZQUNULElBQUtrQixJQUFJLEdBQUdBLElBQUl3QixLQUFLMUMsTUFBTSxFQUFFa0IsSUFBSztnQkFDaENwQixNQUFNNEMsSUFBSSxDQUFDeEIsRUFBRTtnQkFDYmxCLFVBQVVGLElBQUlFLE1BQU07WUFDdEI7UUFDRjtRQUVBLElBQUk4QyxTQUFTMUQsT0FBT1csS0FBSyxDQUFDQztRQUMxQixJQUFJK0MsTUFBTTtRQUNWLElBQUs3QixJQUFJLEdBQUdBLElBQUl3QixLQUFLMUMsTUFBTSxFQUFFa0IsSUFBSztZQUNoQ3BCLE1BQU00QyxJQUFJLENBQUN4QixFQUFFO1lBQ2JwQixJQUFJVSxJQUFJLENBQUNzQyxRQUFRQztZQUNqQkEsT0FBT2pELElBQUlFLE1BQU07UUFDbkI7UUFDQSxPQUFPOEM7SUFDVDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9tZW1qcy9saWIvbWVtanMvdXRpbHMuanM/ZDlkYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAjIE1lbUpTIHV0aWxpdHkgZnVuY3Rpb25zXG5cbnZhciBoZWFkZXIgPSByZXF1aXJlKCcuL2hlYWRlcicpO1xuXG52YXIgYnVmZmVyaWZ5ID0gZnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIodmFsKSA/IHZhbCA6IEJ1ZmZlci5mcm9tKHZhbCk7XG59O1xuXG5leHBvcnRzLm1ha2VSZXF1ZXN0QnVmZmVyID0gZnVuY3Rpb24ob3Bjb2RlLCBrZXksIGV4dHJhcywgdmFsdWUsIG9wYXF1ZSkge1xuICBrZXkgPSBidWZmZXJpZnkoa2V5KTtcbiAgZXh0cmFzID0gYnVmZmVyaWZ5KGV4dHJhcyk7XG4gIHZhbHVlID0gYnVmZmVyaWZ5KHZhbHVlKTtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYygyNCArIGtleS5sZW5ndGggKyBleHRyYXMubGVuZ3RoICsgdmFsdWUubGVuZ3RoKTtcbiAgYnVmLmZpbGwoKTtcbiAgdmFyIHJlcXVlc3RIZWFkZXIgPSB7XG4gICAgbWFnaWM6IDB4ODAsXG4gICAgb3Bjb2RlOiBvcGNvZGUsXG4gICAga2V5TGVuZ3RoOiBrZXkubGVuZ3RoLFxuICAgIGV4dHJhc0xlbmd0aDogZXh0cmFzLmxlbmd0aCxcbiAgICB0b3RhbEJvZHlMZW5ndGg6IGtleS5sZW5ndGggKyB2YWx1ZS5sZW5ndGggKyBleHRyYXMubGVuZ3RoLFxuICAgIG9wYXF1ZTogb3BhcXVlXG4gIH07XG4gIGhlYWRlci50b0J1ZmZlcihyZXF1ZXN0SGVhZGVyKS5jb3B5KGJ1Zik7XG4gIGV4dHJhcy5jb3B5KGJ1ZiwgMjQpO1xuICBrZXkuY29weShidWYsIDI0ICsgZXh0cmFzLmxlbmd0aCk7XG4gIHZhbHVlLmNvcHkoYnVmLCAyNCArIGV4dHJhcy5sZW5ndGggKyBrZXkubGVuZ3RoKTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cbmV4cG9ydHMubWFrZUFtb3VudEluaXRpYWxBbmRFeHBpcmF0aW9uID0gZnVuY3Rpb24oYW1vdW50LCBhbW91bnRJZkVtcHR5LCBleHBpcmF0aW9uKSB7XG4gIHZhciBidWYgPSBCdWZmZXIuYWxsb2MoMjApO1xuICBidWYud3JpdGVVSW50MzJCRSgwLCAwKTtcbiAgYnVmLndyaXRlVUludDMyQkUoYW1vdW50LCA0KTtcbiAgYnVmLndyaXRlVUludDMyQkUoMCwgOCk7XG4gIGJ1Zi53cml0ZVVJbnQzMkJFKGFtb3VudElmRW1wdHksIDEyKTtcbiAgYnVmLndyaXRlVUludDMyQkUoZXhwaXJhdGlvbiwgMTYpO1xuICByZXR1cm4gYnVmO1xufTtcblxuZXhwb3J0cy5tYWtlRXhwaXJhdGlvbiA9IGZ1bmN0aW9uKGV4cGlyYXRpb24pIHtcbiAgdmFyIGJ1ZiA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgYnVmLndyaXRlVUludDMyQkUoZXhwaXJhdGlvbiwgMCk7XG4gIHJldHVybiBidWY7XG59O1xuXG5leHBvcnRzLmhhc2hDb2RlID0gZnVuY3Rpb24oc3RyKSB7XG4gIHZhciByZXQsIGksIGxlbjtcbiAgZm9yKHJldCA9IDAsIGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXQgPSAoMzEgKiByZXQgKyBzdHIuY2hhckNvZGVBdChpKSkgPDwgMDtcbiAgfVxuICByZXR1cm4gTWF0aC5hYnMocmV0KTtcbn07XG5cbmV4cG9ydHMucGFyc2VNZXNzYWdlID0gZnVuY3Rpb24oZGF0YUJ1Zikge1xuICBpZiAoZGF0YUJ1Zi5sZW5ndGggPCAyNCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcmVzcG9uc2VIZWFkZXIgPSBoZWFkZXIuZnJvbUJ1ZmZlcihkYXRhQnVmKTtcbiAgaWYgKGRhdGFCdWYubGVuZ3RoIDwgcmVzcG9uc2VIZWFkZXIudG90YWxCb2R5TGVuZ3RoICsgMjQgfHxcbiAgICAgIHJlc3BvbnNlSGVhZGVyLnRvdGFsQm9keUxlbmd0aCA8XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLmtleUxlbmd0aCArIHJlc3BvbnNlSGVhZGVyLmV4dHJhc0xlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwb2ludGVyID0gMjQ7XG4gIHZhciBleHRyYXMgPSBkYXRhQnVmLnNsaWNlKHBvaW50ZXIsIHBvaW50ZXIgKyByZXNwb25zZUhlYWRlci5leHRyYXNMZW5ndGgpO1xuICBwb2ludGVyICs9IHJlc3BvbnNlSGVhZGVyLmV4dHJhc0xlbmd0aDtcbiAgdmFyIGtleSA9IGRhdGFCdWYuc2xpY2UocG9pbnRlciwgcG9pbnRlciArIHJlc3BvbnNlSGVhZGVyLmtleUxlbmd0aCk7XG4gIHBvaW50ZXIgKz0gcmVzcG9uc2VIZWFkZXIua2V5TGVuZ3RoO1xuICB2YXIgdmFsID0gZGF0YUJ1Zi5zbGljZShwb2ludGVyLCAyNCArIHJlc3BvbnNlSGVhZGVyLnRvdGFsQm9keUxlbmd0aCk7XG5cbiAgcmV0dXJuIHtoZWFkZXI6IHJlc3BvbnNlSGVhZGVyLCBrZXk6IGtleSwgZXh0cmFzOiBleHRyYXMsIHZhbDogdmFsfTtcbn07XG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbihvcmlnaW5hbCwgZGVmbHQpIHtcbiAgdmFyIGF0dHIsIG9yaWdpbmFsVmFsdWU7XG4gIGZvciAoYXR0ciBpbiBkZWZsdCkge1xuICAgIGlmIChkZWZsdC5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgb3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsW2F0dHJdO1xuXG4gICAgICBpZiAob3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IG9yaWdpbmFsVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgb3JpZ2luYWxbYXR0cl0gPSBkZWZsdFthdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9yaWdpbmFsO1xufTtcblxuLy8gdGltZXN0YW1wIHByb3ZpZGVzIGEgbW9ub3RvbmljIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kIGFjY3VyYWN5LCB1c2VmdWxcbi8vIGZvciB0aW1lcnMuXG5leHBvcnRzLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGltZXMgPSBwcm9jZXNzLmhydGltZSgpO1xuICByZXR1cm4gKHRpbWVzWzBdICogMTAwMCkgKyBNYXRoLnJvdW5kKCh0aW1lc1sxXSAvIDEwMDAwMDApKTtcbn07XG5cbmlmKCFCdWZmZXIuY29uY2F0KSB7XG4gIEJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbihsaXN0LCBsZW5ndGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdCwgW2xlbmd0aF0pJyk7XG4gICAgfVxuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgIH1cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiBsaXN0WzBdO1xuICAgIH1cblxuICAgIHZhciBpLCBidWY7XG5cbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWYgPSBsaXN0W2ldO1xuICAgICAgICBsZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKGxlbmd0aCk7XG4gICAgdmFyIHBvcyA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZiA9IGxpc3RbaV07XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcyk7XG4gICAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcbn1cbiJdLCJuYW1lcyI6WyJoZWFkZXIiLCJyZXF1aXJlIiwiYnVmZmVyaWZ5IiwidmFsIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJmcm9tIiwiZXhwb3J0cyIsIm1ha2VSZXF1ZXN0QnVmZmVyIiwib3Bjb2RlIiwia2V5IiwiZXh0cmFzIiwidmFsdWUiLCJvcGFxdWUiLCJidWYiLCJhbGxvYyIsImxlbmd0aCIsImZpbGwiLCJyZXF1ZXN0SGVhZGVyIiwibWFnaWMiLCJrZXlMZW5ndGgiLCJleHRyYXNMZW5ndGgiLCJ0b3RhbEJvZHlMZW5ndGgiLCJ0b0J1ZmZlciIsImNvcHkiLCJtYWtlQW1vdW50SW5pdGlhbEFuZEV4cGlyYXRpb24iLCJhbW91bnQiLCJhbW91bnRJZkVtcHR5IiwiZXhwaXJhdGlvbiIsIndyaXRlVUludDMyQkUiLCJtYWtlRXhwaXJhdGlvbiIsImhhc2hDb2RlIiwic3RyIiwicmV0IiwiaSIsImxlbiIsImNoYXJDb2RlQXQiLCJNYXRoIiwiYWJzIiwicGFyc2VNZXNzYWdlIiwiZGF0YUJ1ZiIsInJlc3BvbnNlSGVhZGVyIiwiZnJvbUJ1ZmZlciIsInBvaW50ZXIiLCJzbGljZSIsIm1lcmdlIiwib3JpZ2luYWwiLCJkZWZsdCIsImF0dHIiLCJvcmlnaW5hbFZhbHVlIiwiaGFzT3duUHJvcGVydHkiLCJ1bmRlZmluZWQiLCJ0aW1lc3RhbXAiLCJ0aW1lcyIsInByb2Nlc3MiLCJocnRpbWUiLCJyb3VuZCIsImNvbmNhdCIsImxpc3QiLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsImJ1ZmZlciIsInBvcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/memjs/lib/memjs/utils.js\n");

/***/ })

};
;