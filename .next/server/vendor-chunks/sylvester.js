/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sylvester";
exports.ids = ["vendor-chunks/sylvester"];
exports.modules = {

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/index.js":
/*!************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("// Copyright (c) 2011, Chris Umbel\nexports.Vector = __webpack_require__(/*! ./vector */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nglobal.$V = exports.Vector.create;\nexports.Matrix = __webpack_require__(/*! ./matrix */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nglobal.$M = exports.Matrix.create;\nexports.Line = __webpack_require__(/*! ./line */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/line.js\");\nglobal.$L = exports.Line.create;\nexports.Plane = __webpack_require__(/*! ./plane */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/plane.js\");\nglobal.$P = exports.Plane.create;\nexports.Line.Segment = __webpack_require__(/*! ./line.segment */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/line.segment.js\");\nexports.Sylvester = __webpack_require__(/*! ./sylvester */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQ0FBa0M7QUFFbENBLG1IQUF5QjtBQUN6QkcsT0FBT0MsRUFBRSxHQUFHSixRQUFRQyxNQUFNLENBQUNJLE1BQU07QUFDakNMLG1IQUF5QjtBQUN6QkcsT0FBT0ksRUFBRSxHQUFHUCxRQUFRTSxNQUFNLENBQUNELE1BQU07QUFDakNMLDZHQUF1QjtBQUN2QkcsT0FBT00sRUFBRSxHQUFHVCxRQUFRUSxJQUFJLENBQUNILE1BQU07QUFDL0JMLGdIQUF3QjtBQUN4QkcsT0FBT1EsRUFBRSxHQUFHWCxRQUFRVSxLQUFLLENBQUNMLE1BQU07QUFDaENMLHFJQUErQjtBQUMvQkEsNEhBQTRCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIvbGliL25vZGUtc3lsdmVzdGVyL2luZGV4LmpzPzM4YzIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbFxuXG5leHBvcnRzLlZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XG5nbG9iYWwuJFYgPSBleHBvcnRzLlZlY3Rvci5jcmVhdGU7XG5leHBvcnRzLk1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG5nbG9iYWwuJE0gPSBleHBvcnRzLk1hdHJpeC5jcmVhdGU7XG5leHBvcnRzLkxpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcbmdsb2JhbC4kTCA9IGV4cG9ydHMuTGluZS5jcmVhdGU7XG5leHBvcnRzLlBsYW5lID0gcmVxdWlyZSgnLi9wbGFuZScpO1xuZ2xvYmFsLiRQID0gZXhwb3J0cy5QbGFuZS5jcmVhdGU7XG5leHBvcnRzLkxpbmUuU2VnbWVudCA9IHJlcXVpcmUoJy4vbGluZS5zZWdtZW50Jyk7XG5leHBvcnRzLlN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyk7XG4iXSwibmFtZXMiOlsiZXhwb3J0cyIsIlZlY3RvciIsInJlcXVpcmUiLCJnbG9iYWwiLCIkViIsImNyZWF0ZSIsIk1hdHJpeCIsIiRNIiwiTGluZSIsIiRMIiwiUGxhbmUiLCIkUCIsIlNlZ21lbnQiLCJTeWx2ZXN0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/line.js":
/*!***********************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/line.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n\nvar Vector = __webpack_require__(/*! ./vector */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nvar Matrix = __webpack_require__(/*! ./matrix */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nvar Plane = __webpack_require__(/*! ./plane */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/plane.js\");\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\n// Line class - depends on Vector, and some methods require Matrix and Plane.\nfunction Line() {}\nLine.prototype = {\n    // Returns true if the argument occupies the same space as the line\n    eql: function(line) {\n        return this.isParallelTo(line) && this.contains(line.anchor);\n    },\n    // Returns a copy of the line\n    dup: function() {\n        return Line.create(this.anchor, this.direction);\n    },\n    // Returns the result of translating the line by the given vector/array\n    translate: function(vector) {\n        var V = vector.elements || vector;\n        return Line.create([\n            this.anchor.elements[0] + V[0],\n            this.anchor.elements[1] + V[1],\n            this.anchor.elements[2] + (V[2] || 0)\n        ], this.direction);\n    },\n    // Returns true if the line is parallel to the argument. Here, 'parallel to'\n    // means that the argument's direction is either parallel or antiparallel to\n    // the line's own direction. A line is parallel to a plane if the two do not\n    // have a unique intersection.\n    isParallelTo: function(obj) {\n        if (obj.normal || obj.start && obj.end) {\n            return obj.isParallelTo(this);\n        }\n        var theta = this.direction.angleFrom(obj.direction);\n        return Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision;\n    },\n    // Returns the line's perpendicular distance from the argument,\n    // which can be a point, a line or a plane\n    distanceFrom: function(obj) {\n        if (obj.normal || obj.start && obj.end) {\n            return obj.distanceFrom(this);\n        }\n        if (obj.direction) {\n            // obj is a line\n            if (this.isParallelTo(obj)) {\n                return this.distanceFrom(obj.anchor);\n            }\n            var N = this.direction.cross(obj.direction).toUnitVector().elements;\n            var A = this.anchor.elements, B = obj.anchor.elements;\n            return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n        } else {\n            // obj is a point\n            var P = obj.elements || obj;\n            var A = this.anchor.elements, D = this.direction.elements;\n            var PA1 = P[0] - A[0], PA2 = P[1] - A[1], PA3 = (P[2] || 0) - A[2];\n            var modPA = Math.sqrt(PA1 * PA1 + PA2 * PA2 + PA3 * PA3);\n            if (modPA === 0) return 0;\n            // Assumes direction vector is normalized\n            var cosTheta = (PA1 * D[0] + PA2 * D[1] + PA3 * D[2]) / modPA;\n            var sin2 = 1 - cosTheta * cosTheta;\n            return Math.abs(modPA * Math.sqrt(sin2 < 0 ? 0 : sin2));\n        }\n    },\n    // Returns true iff the argument is a point on the line, or if the argument\n    // is a line segment lying within the receiver\n    contains: function(obj) {\n        if (obj.start && obj.end) {\n            return this.contains(obj.start) && this.contains(obj.end);\n        }\n        var dist = this.distanceFrom(obj);\n        return dist !== null && dist <= Sylvester.precision;\n    },\n    // Returns the distance from the anchor of the given point. Negative values are\n    // returned for points that are in the opposite direction to the line's direction from\n    // the line's anchor point.\n    positionOf: function(point) {\n        if (!this.contains(point)) {\n            return null;\n        }\n        var P = point.elements || point;\n        var A = this.anchor.elements, D = this.direction.elements;\n        return (P[0] - A[0]) * D[0] + (P[1] - A[1]) * D[1] + ((P[2] || 0) - A[2]) * D[2];\n    },\n    // Returns true iff the line lies in the given plane\n    liesIn: function(plane) {\n        return plane.contains(this);\n    },\n    // Returns true iff the line has a unique point of intersection with the argument\n    intersects: function(obj) {\n        if (obj.normal) {\n            return obj.intersects(this);\n        }\n        return !this.isParallelTo(obj) && this.distanceFrom(obj) <= Sylvester.precision;\n    },\n    // Returns the unique intersection point with the argument, if one exists\n    intersectionWith: function(obj) {\n        if (obj.normal || obj.start && obj.end) {\n            return obj.intersectionWith(this);\n        }\n        if (!this.intersects(obj)) {\n            return null;\n        }\n        var P = this.anchor.elements, X = this.direction.elements, Q = obj.anchor.elements, Y = obj.direction.elements;\n        var X1 = X[0], X2 = X[1], X3 = X[2], Y1 = Y[0], Y2 = Y[1], Y3 = Y[2];\n        var PsubQ1 = P[0] - Q[0], PsubQ2 = P[1] - Q[1], PsubQ3 = P[2] - Q[2];\n        var XdotQsubP = -X1 * PsubQ1 - X2 * PsubQ2 - X3 * PsubQ3;\n        var YdotPsubQ = Y1 * PsubQ1 + Y2 * PsubQ2 + Y3 * PsubQ3;\n        var XdotX = X1 * X1 + X2 * X2 + X3 * X3;\n        var YdotY = Y1 * Y1 + Y2 * Y2 + Y3 * Y3;\n        var XdotY = X1 * Y1 + X2 * Y2 + X3 * Y3;\n        var k = (XdotQsubP * YdotY / XdotX + XdotY * YdotPsubQ) / (YdotY - XdotY * XdotY);\n        return Vector.create([\n            P[0] + k * X1,\n            P[1] + k * X2,\n            P[2] + k * X3\n        ]);\n    },\n    // Returns the point on the line that is closest to the given point or line/line segment\n    pointClosestTo: function(obj) {\n        if (obj.start && obj.end) {\n            // obj is a line segment\n            var P = obj.pointClosestTo(this);\n            return P === null ? null : this.pointClosestTo(P);\n        } else if (obj.direction) {\n            // obj is a line\n            if (this.intersects(obj)) {\n                return this.intersectionWith(obj);\n            }\n            if (this.isParallelTo(obj)) {\n                return null;\n            }\n            var D = this.direction.elements, E = obj.direction.elements;\n            var D1 = D[0], D2 = D[1], D3 = D[2], E1 = E[0], E2 = E[1], E3 = E[2];\n            // Create plane containing obj and the shared normal and intersect this with it\n            // Thank you: http://www.cgafaq.info/wiki/Line-line_distance\n            var x = D3 * E1 - D1 * E3, y = D1 * E2 - D2 * E1, z = D2 * E3 - D3 * E2;\n            var N = [\n                x * E3 - y * E2,\n                y * E1 - z * E3,\n                z * E2 - x * E1\n            ];\n            var P = Plane.create(obj.anchor, N);\n            return P.intersectionWith(this);\n        } else {\n            // obj is a point\n            var P = obj.elements || obj;\n            if (this.contains(P)) {\n                return Vector.create(P);\n            }\n            var A = this.anchor.elements, D = this.direction.elements;\n            var D1 = D[0], D2 = D[1], D3 = D[2], A1 = A[0], A2 = A[1], A3 = A[2];\n            var x = D1 * (P[1] - A2) - D2 * (P[0] - A1), y = D2 * ((P[2] || 0) - A3) - D3 * (P[1] - A2), z = D3 * (P[0] - A1) - D1 * ((P[2] || 0) - A3);\n            var V = Vector.create([\n                D2 * x - D3 * z,\n                D3 * y - D1 * x,\n                D1 * z - D2 * y\n            ]);\n            var k = this.distanceFrom(P) / V.modulus();\n            return Vector.create([\n                P[0] + V.elements[0] * k,\n                P[1] + V.elements[1] * k,\n                (P[2] || 0) + V.elements[2] * k\n            ]);\n        }\n    },\n    // Returns a copy of the line rotated by t radians about the given line. Works by\n    // finding the argument's closest point to this line's anchor point (call this C) and\n    // rotating the anchor about C. Also rotates the line's direction about the argument's.\n    // Be careful with this - the rotation axis' direction affects the outcome!\n    rotate: function(t, line) {\n        // If we're working in 2D\n        if (typeof line.direction == \"undefined\") {\n            line = Line.create(line.to3D(), Vector.k);\n        }\n        var R = Matrix.Rotation(t, line.direction).elements;\n        var C = line.pointClosestTo(this.anchor).elements;\n        var A = this.anchor.elements, D = this.direction.elements;\n        var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n        var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n        return Line.create([\n            C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n            C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n            C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n        ], [\n            R[0][0] * D[0] + R[0][1] * D[1] + R[0][2] * D[2],\n            R[1][0] * D[0] + R[1][1] * D[1] + R[1][2] * D[2],\n            R[2][0] * D[0] + R[2][1] * D[1] + R[2][2] * D[2]\n        ]);\n    },\n    // Returns a copy of the line with its direction vector reversed.\n    // Useful when using lines for rotations.\n    reverse: function() {\n        return Line.create(this.anchor, this.direction.x(-1));\n    },\n    // Returns the line's reflection in the given point or line\n    reflectionIn: function(obj) {\n        if (obj.normal) {\n            // obj is a plane\n            var A = this.anchor.elements, D = this.direction.elements;\n            var A1 = A[0], A2 = A[1], A3 = A[2], D1 = D[0], D2 = D[1], D3 = D[2];\n            var newA = this.anchor.reflectionIn(obj).elements;\n            // Add the line's direction vector to its anchor, then mirror that in the plane\n            var AD1 = A1 + D1, AD2 = A2 + D2, AD3 = A3 + D3;\n            var Q = obj.pointClosestTo([\n                AD1,\n                AD2,\n                AD3\n            ]).elements;\n            var newD = [\n                Q[0] + (Q[0] - AD1) - newA[0],\n                Q[1] + (Q[1] - AD2) - newA[1],\n                Q[2] + (Q[2] - AD3) - newA[2]\n            ];\n            return Line.create(newA, newD);\n        } else if (obj.direction) {\n            // obj is a line - reflection obtained by rotating PI radians about obj\n            return this.rotate(Math.PI, obj);\n        } else {\n            // obj is a point - just reflect the line's anchor in it\n            var P = obj.elements || obj;\n            return Line.create(this.anchor.reflectionIn([\n                P[0],\n                P[1],\n                P[2] || 0\n            ]), this.direction);\n        }\n    },\n    // Set the line's anchor point and direction.\n    setVectors: function(anchor, direction) {\n        // Need to do this so that line's properties are not\n        // references to the arguments passed in\n        anchor = Vector.create(anchor);\n        direction = Vector.create(direction);\n        if (anchor.elements.length == 2) {\n            anchor.elements.push(0);\n        }\n        if (direction.elements.length == 2) {\n            direction.elements.push(0);\n        }\n        if (anchor.elements.length > 3 || direction.elements.length > 3) {\n            return null;\n        }\n        var mod = direction.modulus();\n        if (mod === 0) {\n            return null;\n        }\n        this.anchor = anchor;\n        this.direction = Vector.create([\n            direction.elements[0] / mod,\n            direction.elements[1] / mod,\n            direction.elements[2] / mod\n        ]);\n        return this;\n    }\n};\n// Constructor function\nLine.create = function(anchor, direction) {\n    var L = new Line();\n    return L.setVectors(anchor, direction);\n};\n// Axes\nLine.X = Line.create(Vector.Zero(3), Vector.i);\nLine.Y = Line.create(Vector.Zero(3), Vector.j);\nLine.Z = Line.create(Vector.Zero(3), Vector.k);\nmodule.exports = Line;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9saW5lLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdEQUFnRDs7QUFDaEQsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFDckIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFDckIsSUFBSUUsUUFBUUYsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUcsWUFBWUgsbUJBQU9BLENBQUM7QUFFeEIsNkVBQTZFO0FBRTdFLFNBQVNJLFFBQVE7QUFDakJBLEtBQUtDLFNBQVMsR0FBRztJQUVmLG1FQUFtRTtJQUNuRUMsS0FBSyxTQUFTQyxJQUFJO1FBQ2hCLE9BQVEsSUFBSSxDQUFDQyxZQUFZLENBQUNELFNBQVMsSUFBSSxDQUFDRSxRQUFRLENBQUNGLEtBQUtHLE1BQU07SUFDOUQ7SUFFQSw2QkFBNkI7SUFDN0JDLEtBQUs7UUFDSCxPQUFPUCxLQUFLUSxNQUFNLENBQUMsSUFBSSxDQUFDRixNQUFNLEVBQUUsSUFBSSxDQUFDRyxTQUFTO0lBQ2hEO0lBRUEsdUVBQXVFO0lBQ3ZFQyxXQUFXLFNBQVNDLE1BQU07UUFDeEIsSUFBSUMsSUFBSUQsT0FBT0UsUUFBUSxJQUFJRjtRQUMzQixPQUFPWCxLQUFLUSxNQUFNLENBQUM7WUFDakIsSUFBSSxDQUFDRixNQUFNLENBQUNPLFFBQVEsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQ04sTUFBTSxDQUFDTyxRQUFRLENBQUMsRUFBRSxHQUFHRCxDQUFDLENBQUMsRUFBRTtZQUM5QixJQUFJLENBQUNOLE1BQU0sQ0FBQ08sUUFBUSxDQUFDLEVBQUUsR0FBSUQsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsSUFBSTtTQUNwQyxFQUFFLElBQUksQ0FBQ0gsU0FBUztJQUNuQjtJQUVBLDRFQUE0RTtJQUM1RSw0RUFBNEU7SUFDNUUsNEVBQTRFO0lBQzVFLDhCQUE4QjtJQUM5QkwsY0FBYyxTQUFTVSxHQUFHO1FBQ3hCLElB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QUcsS0FBS3ZGLFVBQVVJLFFBQVEsQ0FBQ21GLE1BQU0sR0FBRyxHQUFHO1lBQUUsT0FBTztRQUFNO1FBQ2hGLElBQUlFLE1BQU16RixVQUFVcUUsT0FBTztRQUMzQixJQUFJb0IsUUFBUSxHQUFHO1lBQUUsT0FBTztRQUFNO1FBQzlCLElBQUksQ0FBQzVGLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNHLFNBQVMsR0FBR2QsT0FBT2EsTUFBTSxDQUFDO1lBQzdCQyxVQUFVSSxRQUFRLENBQUMsRUFBRSxHQUFHcUY7WUFDeEJ6RixVQUFVSSxRQUFRLENBQUMsRUFBRSxHQUFHcUY7WUFDeEJ6RixVQUFVSSxRQUFRLENBQUMsRUFBRSxHQUFHcUY7U0FDekI7UUFDRCxPQUFPLElBQUk7SUFDYjtBQUNGO0FBRUEsdUJBQXVCO0FBQ3ZCbEcsS0FBS1EsTUFBTSxHQUFHLFNBQVNGLE1BQU0sRUFBRUcsU0FBUztJQUN0QyxJQUFJMEYsSUFBSSxJQUFJbkc7SUFDWixPQUFPbUcsRUFBRUosVUFBVSxDQUFDekYsUUFBUUc7QUFDOUI7QUFFQSxPQUFPO0FBQ1BULEtBQUs4QyxDQUFDLEdBQUc5QyxLQUFLUSxNQUFNLENBQUNiLE9BQU95RyxJQUFJLENBQUMsSUFBSXpHLE9BQU8wRyxDQUFDO0FBQzdDckcsS0FBS2dELENBQUMsR0FBR2hELEtBQUtRLE1BQU0sQ0FBQ2IsT0FBT3lHLElBQUksQ0FBQyxJQUFJekcsT0FBTzJHLENBQUM7QUFDN0N0RyxLQUFLdUcsQ0FBQyxHQUFHdkcsS0FBS1EsTUFBTSxDQUFDYixPQUFPeUcsSUFBSSxDQUFDLElBQUl6RyxPQUFPb0UsQ0FBQztBQUU3Q3lDLE9BQU9DLE9BQU8sR0FBR3pHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIvbGliL25vZGUtc3lsdmVzdGVyL2xpbmUuanM/MzdhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsLCBKYW1lcyBDb2dsYW5cbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xudmFyIE1hdHJpeCA9IHJlcXVpcmUoJy4vbWF0cml4Jyk7XG52YXIgUGxhbmUgPSByZXF1aXJlKCcuL3BsYW5lJyk7XG52YXIgU3lsdmVzdGVyID0gcmVxdWlyZSgnLi9zeWx2ZXN0ZXInKTtcblxuLy8gTGluZSBjbGFzcyAtIGRlcGVuZHMgb24gVmVjdG9yLCBhbmQgc29tZSBtZXRob2RzIHJlcXVpcmUgTWF0cml4IGFuZCBQbGFuZS5cblxuZnVuY3Rpb24gTGluZSgpIHt9XG5MaW5lLnByb3RvdHlwZSA9IHtcblxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGFyZ3VtZW50IG9jY3VwaWVzIHRoZSBzYW1lIHNwYWNlIGFzIHRoZSBsaW5lXG4gIGVxbDogZnVuY3Rpb24obGluZSkge1xuICAgIHJldHVybiAodGhpcy5pc1BhcmFsbGVsVG8obGluZSkgJiYgdGhpcy5jb250YWlucyhsaW5lLmFuY2hvcikpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaW5lXG4gIGR1cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIExpbmUuY3JlYXRlKHRoaXMuYW5jaG9yLCB0aGlzLmRpcmVjdGlvbik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRyYW5zbGF0aW5nIHRoZSBsaW5lIGJ5IHRoZSBnaXZlbiB2ZWN0b3IvYXJyYXlcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbih2ZWN0b3IpIHtcbiAgICB2YXIgViA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XG4gICAgcmV0dXJuIExpbmUuY3JlYXRlKFtcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzBdICsgVlswXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzFdICsgVlsxXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzJdICsgKFZbMl0gfHwgMClcbiAgICBdLCB0aGlzLmRpcmVjdGlvbik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSBsaW5lIGlzIHBhcmFsbGVsIHRvIHRoZSBhcmd1bWVudC4gSGVyZSwgJ3BhcmFsbGVsIHRvJ1xuICAvLyBtZWFucyB0aGF0IHRoZSBhcmd1bWVudCdzIGRpcmVjdGlvbiBpcyBlaXRoZXIgcGFyYWxsZWwgb3IgYW50aXBhcmFsbGVsIHRvXG4gIC8vIHRoZSBsaW5lJ3Mgb3duIGRpcmVjdGlvbi4gQSBsaW5lIGlzIHBhcmFsbGVsIHRvIGEgcGxhbmUgaWYgdGhlIHR3byBkbyBub3RcbiAgLy8gaGF2ZSBhIHVuaXF1ZSBpbnRlcnNlY3Rpb24uXG4gIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwgfHwgKG9iai5zdGFydCAmJiBvYmouZW5kKSkgeyByZXR1cm4gb2JqLmlzUGFyYWxsZWxUbyh0aGlzKTsgfVxuICAgIHZhciB0aGV0YSA9IHRoaXMuZGlyZWN0aW9uLmFuZ2xlRnJvbShvYmouZGlyZWN0aW9uKTtcbiAgICByZXR1cm4gKE1hdGguYWJzKHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoZXRhIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgbGluZSdzIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSB0aGUgYXJndW1lbnQsXG4gIC8vIHdoaWNoIGNhbiBiZSBhIHBvaW50LCBhIGxpbmUgb3IgYSBwbGFuZVxuICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsIHx8IChvYmouc3RhcnQgJiYgb2JqLmVuZCkpIHsgcmV0dXJuIG9iai5kaXN0YW5jZUZyb20odGhpcyk7IH1cbiAgICBpZiAob2JqLmRpcmVjdGlvbikge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZVxuICAgICAgaWYgKHRoaXMuaXNQYXJhbGxlbFRvKG9iaikpIHsgcmV0dXJuIHRoaXMuZGlzdGFuY2VGcm9tKG9iai5hbmNob3IpOyB9XG4gICAgICB2YXIgTiA9IHRoaXMuZGlyZWN0aW9uLmNyb3NzKG9iai5kaXJlY3Rpb24pLnRvVW5pdFZlY3RvcigpLmVsZW1lbnRzO1xuICAgICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgQiA9IG9iai5hbmNob3IuZWxlbWVudHM7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoKEFbMF0gLSBCWzBdKSAqIE5bMF0gKyAoQVsxXSAtIEJbMV0pICogTlsxXSArIChBWzJdIC0gQlsyXSkgKiBOWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgcG9pbnRcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEQgPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICAgIHZhciBQQTEgPSBQWzBdIC0gQVswXSwgUEEyID0gUFsxXSAtIEFbMV0sIFBBMyA9IChQWzJdIHx8IDApIC0gQVsyXTtcbiAgICAgIHZhciBtb2RQQSA9IE1hdGguc3FydChQQTEqUEExICsgUEEyKlBBMiArIFBBMypQQTMpO1xuICAgICAgaWYgKG1vZFBBID09PSAwKSByZXR1cm4gMDtcbiAgICAgIC8vIEFzc3VtZXMgZGlyZWN0aW9uIHZlY3RvciBpcyBub3JtYWxpemVkXG4gICAgICB2YXIgY29zVGhldGEgPSAoUEExICogRFswXSArIFBBMiAqIERbMV0gKyBQQTMgKiBEWzJdKSAvIG1vZFBBO1xuICAgICAgdmFyIHNpbjIgPSAxIC0gY29zVGhldGEqY29zVGhldGE7XG4gICAgICByZXR1cm4gTWF0aC5hYnMobW9kUEEgKiBNYXRoLnNxcnQoc2luMiA8IDAgPyAwIDogc2luMikpO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBhcmd1bWVudCBpcyBhIHBvaW50IG9uIHRoZSBsaW5lLCBvciBpZiB0aGUgYXJndW1lbnRcbiAgLy8gaXMgYSBsaW5lIHNlZ21lbnQgbHlpbmcgd2l0aGluIHRoZSByZWNlaXZlclxuICBjb250YWluczogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5zdGFydCAmJiBvYmouZW5kKSB7IHJldHVybiB0aGlzLmNvbnRhaW5zKG9iai5zdGFydCkgJiYgdGhpcy5jb250YWlucyhvYmouZW5kKTsgfVxuICAgIHZhciBkaXN0ID0gdGhpcy5kaXN0YW5jZUZyb20ob2JqKTtcbiAgICByZXR1cm4gKGRpc3QgIT09IG51bGwgJiYgZGlzdCA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBhbmNob3Igb2YgdGhlIGdpdmVuIHBvaW50LiBOZWdhdGl2ZSB2YWx1ZXMgYXJlXG4gIC8vIHJldHVybmVkIGZvciBwb2ludHMgdGhhdCBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiB0byB0aGUgbGluZSdzIGRpcmVjdGlvbiBmcm9tXG4gIC8vIHRoZSBsaW5lJ3MgYW5jaG9yIHBvaW50LlxuICBwb3NpdGlvbk9mOiBmdW5jdGlvbihwb2ludCkge1xuICAgIGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgUCA9IHBvaW50LmVsZW1lbnRzIHx8IHBvaW50O1xuICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEQgPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICByZXR1cm4gKFBbMF0gLSBBWzBdKSAqIERbMF0gKyAoUFsxXSAtIEFbMV0pICogRFsxXSArICgoUFsyXSB8fCAwKSAtIEFbMl0pICogRFsyXTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIGxpZXMgaW4gdGhlIGdpdmVuIHBsYW5lXG4gIGxpZXNJbjogZnVuY3Rpb24ocGxhbmUpIHtcbiAgICByZXR1cm4gcGxhbmUuY29udGFpbnModGhpcyk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbGluZSBoYXMgYSB1bmlxdWUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGFyZ3VtZW50XG4gIGludGVyc2VjdHM6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsKSB7IHJldHVybiBvYmouaW50ZXJzZWN0cyh0aGlzKTsgfVxuICAgIHJldHVybiAoIXRoaXMuaXNQYXJhbGxlbFRvKG9iaikgJiYgdGhpcy5kaXN0YW5jZUZyb20ob2JqKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSB1bmlxdWUgaW50ZXJzZWN0aW9uIHBvaW50IHdpdGggdGhlIGFyZ3VtZW50LCBpZiBvbmUgZXhpc3RzXG4gIGludGVyc2VjdGlvbldpdGg6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsIHx8IChvYmouc3RhcnQgJiYgb2JqLmVuZCkpIHsgcmV0dXJuIG9iai5pbnRlcnNlY3Rpb25XaXRoKHRoaXMpOyB9XG4gICAgaWYgKCF0aGlzLmludGVyc2VjdHMob2JqKSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHZhciBQID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIFggPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cyxcbiAgICAgICAgUSA9IG9iai5hbmNob3IuZWxlbWVudHMsIFkgPSBvYmouZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgIHZhciBYMSA9IFhbMF0sIFgyID0gWFsxXSwgWDMgPSBYWzJdLCBZMSA9IFlbMF0sIFkyID0gWVsxXSwgWTMgPSBZWzJdO1xuICAgIHZhciBQc3ViUTEgPSBQWzBdIC0gUVswXSwgUHN1YlEyID0gUFsxXSAtIFFbMV0sIFBzdWJRMyA9IFBbMl0gLSBRWzJdO1xuICAgIHZhciBYZG90UXN1YlAgPSAtIFgxKlBzdWJRMSAtIFgyKlBzdWJRMiAtIFgzKlBzdWJRMztcbiAgICB2YXIgWWRvdFBzdWJRID0gWTEqUHN1YlExICsgWTIqUHN1YlEyICsgWTMqUHN1YlEzO1xuICAgIHZhciBYZG90WCA9IFgxKlgxICsgWDIqWDIgKyBYMypYMztcbiAgICB2YXIgWWRvdFkgPSBZMSpZMSArIFkyKlkyICsgWTMqWTM7XG4gICAgdmFyIFhkb3RZID0gWDEqWTEgKyBYMipZMiArIFgzKlkzO1xuICAgIHZhciBrID0gKFhkb3RRc3ViUCAqIFlkb3RZIC8gWGRvdFggKyBYZG90WSAqIFlkb3RQc3ViUSkgLyAoWWRvdFkgLSBYZG90WSAqIFhkb3RZKTtcbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbUFswXSArIGsqWDEsIFBbMV0gKyBrKlgyLCBQWzJdICsgaypYM10pO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBsaW5lIHRoYXQgaXMgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gcG9pbnQgb3IgbGluZS9saW5lIHNlZ21lbnRcbiAgcG9pbnRDbG9zZXN0VG86IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouc3RhcnQgJiYgb2JqLmVuZCkge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZSBzZWdtZW50XG4gICAgICB2YXIgUCA9IG9iai5wb2ludENsb3Nlc3RUbyh0aGlzKTtcbiAgICAgIHJldHVybiAoUCA9PT0gbnVsbCkgPyBudWxsIDogdGhpcy5wb2ludENsb3Nlc3RUbyhQKTtcbiAgICB9IGVsc2UgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIC8vIG9iaiBpcyBhIGxpbmVcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHMob2JqKSkgeyByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25XaXRoKG9iaik7IH1cbiAgICAgIGlmICh0aGlzLmlzUGFyYWxsZWxUbyhvYmopKSB7IHJldHVybiBudWxsOyB9XG4gICAgICB2YXIgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzLCBFID0gb2JqLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICAgIHZhciBEMSA9IERbMF0sIEQyID0gRFsxXSwgRDMgPSBEWzJdLCBFMSA9IEVbMF0sIEUyID0gRVsxXSwgRTMgPSBFWzJdO1xuICAgICAgLy8gQ3JlYXRlIHBsYW5lIGNvbnRhaW5pbmcgb2JqIGFuZCB0aGUgc2hhcmVkIG5vcm1hbCBhbmQgaW50ZXJzZWN0IHRoaXMgd2l0aCBpdFxuICAgICAgLy8gVGhhbmsgeW91OiBodHRwOi8vd3d3LmNnYWZhcS5pbmZvL3dpa2kvTGluZS1saW5lX2Rpc3RhbmNlXG4gICAgICB2YXIgeCA9IChEMyAqIEUxIC0gRDEgKiBFMyksIHkgPSAoRDEgKiBFMiAtIEQyICogRTEpLCB6ID0gKEQyICogRTMgLSBEMyAqIEUyKTtcbiAgICAgIHZhciBOID0gW3ggKiBFMyAtIHkgKiBFMiwgeSAqIEUxIC0geiAqIEUzLCB6ICogRTIgLSB4ICogRTFdO1xuICAgICAgdmFyIFAgPSBQbGFuZS5jcmVhdGUob2JqLmFuY2hvciwgTik7XG4gICAgICByZXR1cm4gUC5pbnRlcnNlY3Rpb25XaXRoKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvYmogaXMgYSBwb2ludFxuICAgICAgdmFyIFAgPSBvYmouZWxlbWVudHMgfHwgb2JqO1xuICAgICAgaWYgKHRoaXMuY29udGFpbnMoUCkpIHsgcmV0dXJuIFZlY3Rvci5jcmVhdGUoUCk7IH1cbiAgICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIEQgPSB0aGlzLmRpcmVjdGlvbi5lbGVtZW50cztcbiAgICAgIHZhciBEMSA9IERbMF0sIEQyID0gRFsxXSwgRDMgPSBEWzJdLCBBMSA9IEFbMF0sIEEyID0gQVsxXSwgQTMgPSBBWzJdO1xuICAgICAgdmFyIHggPSBEMSAqIChQWzFdLUEyKSAtIEQyICogKFBbMF0tQTEpLCB5ID0gRDIgKiAoKFBbMl0gfHwgMCkgLSBBMykgLSBEMyAqIChQWzFdLUEyKSxcbiAgICAgICAgICB6ID0gRDMgKiAoUFswXS1BMSkgLSBEMSAqICgoUFsyXSB8fCAwKSAtIEEzKTtcbiAgICAgIHZhciBWID0gVmVjdG9yLmNyZWF0ZShbRDIgKiB4IC0gRDMgKiB6LCBEMyAqIHkgLSBEMSAqIHgsIEQxICogeiAtIEQyICogeV0pO1xuICAgICAgdmFyIGsgPSB0aGlzLmRpc3RhbmNlRnJvbShQKSAvIFYubW9kdWx1cygpO1xuICAgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUoW1xuICAgICAgICBQWzBdICsgVi5lbGVtZW50c1swXSAqIGssXG4gICAgICAgIFBbMV0gKyBWLmVsZW1lbnRzWzFdICogayxcbiAgICAgICAgKFBbMl0gfHwgMCkgKyBWLmVsZW1lbnRzWzJdICoga1xuICAgICAgXSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBsaW5lIHJvdGF0ZWQgYnkgdCByYWRpYW5zIGFib3V0IHRoZSBnaXZlbiBsaW5lLiBXb3JrcyBieVxuICAvLyBmaW5kaW5nIHRoZSBhcmd1bWVudCdzIGNsb3Nlc3QgcG9pbnQgdG8gdGhpcyBsaW5lJ3MgYW5jaG9yIHBvaW50IChjYWxsIHRoaXMgQykgYW5kXG4gIC8vIHJvdGF0aW5nIHRoZSBhbmNob3IgYWJvdXQgQy4gQWxzbyByb3RhdGVzIHRoZSBsaW5lJ3MgZGlyZWN0aW9uIGFib3V0IHRoZSBhcmd1bWVudCdzLlxuICAvLyBCZSBjYXJlZnVsIHdpdGggdGhpcyAtIHRoZSByb3RhdGlvbiBheGlzJyBkaXJlY3Rpb24gYWZmZWN0cyB0aGUgb3V0Y29tZSFcbiAgcm90YXRlOiBmdW5jdGlvbih0LCBsaW5lKSB7XG4gICAgLy8gSWYgd2UncmUgd29ya2luZyBpbiAyRFxuICAgIGlmICh0eXBlb2YobGluZS5kaXJlY3Rpb24pID09ICd1bmRlZmluZWQnKSB7IGxpbmUgPSBMaW5lLmNyZWF0ZShsaW5lLnRvM0QoKSwgVmVjdG9yLmspOyB9XG4gICAgdmFyIFIgPSBNYXRyaXguUm90YXRpb24odCwgbGluZS5kaXJlY3Rpb24pLmVsZW1lbnRzO1xuICAgIHZhciBDID0gbGluZS5wb2ludENsb3Nlc3RUbyh0aGlzLmFuY2hvcikuZWxlbWVudHM7XG4gICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgIHZhciBDMSA9IENbMF0sIEMyID0gQ1sxXSwgQzMgPSBDWzJdLCBBMSA9IEFbMF0sIEEyID0gQVsxXSwgQTMgPSBBWzJdO1xuICAgIHZhciB4ID0gQTEgLSBDMSwgeSA9IEEyIC0gQzIsIHogPSBBMyAtIEMzO1xuICAgIHJldHVybiBMaW5lLmNyZWF0ZShbXG4gICAgICBDMSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcbiAgICAgIEMyICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuICAgICAgQzMgKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICBdLCBbXG4gICAgICBSWzBdWzBdICogRFswXSArIFJbMF1bMV0gKiBEWzFdICsgUlswXVsyXSAqIERbMl0sXG4gICAgICBSWzFdWzBdICogRFswXSArIFJbMV1bMV0gKiBEWzFdICsgUlsxXVsyXSAqIERbMl0sXG4gICAgICBSWzJdWzBdICogRFswXSArIFJbMl1bMV0gKiBEWzFdICsgUlsyXVsyXSAqIERbMl1cbiAgICBdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGluZSB3aXRoIGl0cyBkaXJlY3Rpb24gdmVjdG9yIHJldmVyc2VkLlxuICAvLyBVc2VmdWwgd2hlbiB1c2luZyBsaW5lcyBmb3Igcm90YXRpb25zLlxuICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gTGluZS5jcmVhdGUodGhpcy5hbmNob3IsIHRoaXMuZGlyZWN0aW9uLngoLTEpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBsaW5lJ3MgcmVmbGVjdGlvbiBpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgbGluZVxuICByZWZsZWN0aW9uSW46IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmoubm9ybWFsKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZVxuICAgICAgdmFyIEEgPSB0aGlzLmFuY2hvci5lbGVtZW50cywgRCA9IHRoaXMuZGlyZWN0aW9uLmVsZW1lbnRzO1xuICAgICAgdmFyIEExID0gQVswXSwgQTIgPSBBWzFdLCBBMyA9IEFbMl0sIEQxID0gRFswXSwgRDIgPSBEWzFdLCBEMyA9IERbMl07XG4gICAgICB2YXIgbmV3QSA9IHRoaXMuYW5jaG9yLnJlZmxlY3Rpb25JbihvYmopLmVsZW1lbnRzO1xuICAgICAgLy8gQWRkIHRoZSBsaW5lJ3MgZGlyZWN0aW9uIHZlY3RvciB0byBpdHMgYW5jaG9yLCB0aGVuIG1pcnJvciB0aGF0IGluIHRoZSBwbGFuZVxuICAgICAgdmFyIEFEMSA9IEExICsgRDEsIEFEMiA9IEEyICsgRDIsIEFEMyA9IEEzICsgRDM7XG4gICAgICB2YXIgUSA9IG9iai5wb2ludENsb3Nlc3RUbyhbQUQxLCBBRDIsIEFEM10pLmVsZW1lbnRzO1xuICAgICAgdmFyIG5ld0QgPSBbUVswXSArIChRWzBdIC0gQUQxKSAtIG5ld0FbMF0sIFFbMV0gKyAoUVsxXSAtIEFEMikgLSBuZXdBWzFdLCBRWzJdICsgKFFbMl0gLSBBRDMpIC0gbmV3QVsyXV07XG4gICAgICByZXR1cm4gTGluZS5jcmVhdGUobmV3QSwgbmV3RCk7XG4gICAgfSBlbHNlIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lIC0gcmVmbGVjdGlvbiBvYnRhaW5lZCBieSByb3RhdGluZyBQSSByYWRpYW5zIGFib3V0IG9ialxuICAgICAgcmV0dXJuIHRoaXMucm90YXRlKE1hdGguUEksIG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBvaW50IC0ganVzdCByZWZsZWN0IHRoZSBsaW5lJ3MgYW5jaG9yIGluIGl0XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICByZXR1cm4gTGluZS5jcmVhdGUodGhpcy5hbmNob3IucmVmbGVjdGlvbkluKFtQWzBdLCBQWzFdLCAoUFsyXSB8fCAwKV0pLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNldCB0aGUgbGluZSdzIGFuY2hvciBwb2ludCBhbmQgZGlyZWN0aW9uLlxuICBzZXRWZWN0b3JzOiBmdW5jdGlvbihhbmNob3IsIGRpcmVjdGlvbikge1xuICAgIC8vIE5lZWQgdG8gZG8gdGhpcyBzbyB0aGF0IGxpbmUncyBwcm9wZXJ0aWVzIGFyZSBub3RcbiAgICAvLyByZWZlcmVuY2VzIHRvIHRoZSBhcmd1bWVudHMgcGFzc2VkIGluXG4gICAgYW5jaG9yID0gVmVjdG9yLmNyZWF0ZShhbmNob3IpO1xuICAgIGRpcmVjdGlvbiA9IFZlY3Rvci5jcmVhdGUoZGlyZWN0aW9uKTtcbiAgICBpZiAoYW5jaG9yLmVsZW1lbnRzLmxlbmd0aCA9PSAyKSB7YW5jaG9yLmVsZW1lbnRzLnB1c2goMCk7IH1cbiAgICBpZiAoZGlyZWN0aW9uLmVsZW1lbnRzLmxlbmd0aCA9PSAyKSB7IGRpcmVjdGlvbi5lbGVtZW50cy5wdXNoKDApOyB9XG4gICAgaWYgKGFuY2hvci5lbGVtZW50cy5sZW5ndGggPiAzIHx8IGRpcmVjdGlvbi5lbGVtZW50cy5sZW5ndGggPiAzKSB7IHJldHVybiBudWxsOyB9XG4gICAgdmFyIG1vZCA9IGRpcmVjdGlvbi5tb2R1bHVzKCk7XG4gICAgaWYgKG1vZCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gVmVjdG9yLmNyZWF0ZShbXG4gICAgICBkaXJlY3Rpb24uZWxlbWVudHNbMF0gLyBtb2QsXG4gICAgICBkaXJlY3Rpb24uZWxlbWVudHNbMV0gLyBtb2QsXG4gICAgICBkaXJlY3Rpb24uZWxlbWVudHNbMl0gLyBtb2RcbiAgICBdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0b3IgZnVuY3Rpb25cbkxpbmUuY3JlYXRlID0gZnVuY3Rpb24oYW5jaG9yLCBkaXJlY3Rpb24pIHtcbiAgdmFyIEwgPSBuZXcgTGluZSgpO1xuICByZXR1cm4gTC5zZXRWZWN0b3JzKGFuY2hvciwgZGlyZWN0aW9uKTtcbn07XG5cbi8vIEF4ZXNcbkxpbmUuWCA9IExpbmUuY3JlYXRlKFZlY3Rvci5aZXJvKDMpLCBWZWN0b3IuaSk7XG5MaW5lLlkgPSBMaW5lLmNyZWF0ZShWZWN0b3IuWmVybygzKSwgVmVjdG9yLmopO1xuTGluZS5aID0gTGluZS5jcmVhdGUoVmVjdG9yLlplcm8oMyksIFZlY3Rvci5rKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuIl0sIm5hbWVzIjpbIlZlY3RvciIsInJlcXVpcmUiLCJNYXRyaXgiLCJQbGFuZSIsIlN5bHZlc3RlciIsIkxpbmUiLCJwcm90b3R5cGUiLCJlcWwiLCJsaW5lIiwiaXNQYXJhbGxlbFRvIiwiY29udGFpbnMiLCJhbmNob3IiLCJkdXAiLCJjcmVhdGUiLCJkaXJlY3Rpb24iLCJ0cmFuc2xhdGUiLCJ2ZWN0b3IiLCJWIiwiZWxlbWVudHMiLCJvYmoiLCJub3JtYWwiLCJzdGFydCIsImVuZCIsInRoZXRhIiwiYW5nbGVGcm9tIiwiTWF0aCIsImFicyIsInByZWNpc2lvbiIsIlBJIiwiZGlzdGFuY2VGcm9tIiwiTiIsImNyb3NzIiwidG9Vbml0VmVjdG9yIiwiQSIsIkIiLCJQIiwiRCIsIlBBMSIsIlBBMiIsIlBBMyIsIm1vZFBBIiwic3FydCIsImNvc1RoZXRhIiwic2luMiIsImRpc3QiLCJwb3NpdGlvbk9mIiwicG9pbnQiLCJsaWVzSW4iLCJwbGFuZSIsImludGVyc2VjdHMiLCJpbnRlcnNlY3Rpb25XaXRoIiwiWCIsIlEiLCJZIiwiWDEiLCJYMiIsIlgzIiwiWTEiLCJZMiIsIlkzIiwiUHN1YlExIiwiUHN1YlEyIiwiUHN1YlEzIiwiWGRvdFFzdWJQIiwiWWRvdFBzdWJRIiwiWGRvdFgiLCJZZG90WSIsIlhkb3RZIiwiayIsInBvaW50Q2xvc2VzdFRvIiwiRSIsIkQxIiwiRDIiLCJEMyIsIkUxIiwiRTIiLCJFMyIsIngiLCJ5IiwieiIsIkExIiwiQTIiLCJBMyIsIm1vZHVsdXMiLCJyb3RhdGUiLCJ0IiwidG8zRCIsIlIiLCJSb3RhdGlvbiIsIkMiLCJDMSIsIkMyIiwiQzMiLCJyZXZlcnNlIiwicmVmbGVjdGlvbkluIiwibmV3QSIsIkFEMSIsIkFEMiIsIkFEMyIsIm5ld0QiLCJzZXRWZWN0b3JzIiwibGVuZ3RoIiwicHVzaCIsIm1vZCIsIkwiLCJaZXJvIiwiaSIsImoiLCJaIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/line.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/line.segment.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/line.segment.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// Line.Segment class - depends on Line and its dependencies.\n\nvar Line = __webpack_require__(/*! ./line */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/line.js\");\nvar Vector = __webpack_require__(/*! ./vector */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nLine.Segment = function() {};\nLine.Segment.prototype = {\n    // Returns true iff the line segment is equal to the argument\n    eql: function(segment) {\n        return this.start.eql(segment.start) && this.end.eql(segment.end) || this.start.eql(segment.end) && this.end.eql(segment.start);\n    },\n    // Returns a copy of the line segment\n    dup: function() {\n        return Line.Segment.create(this.start, this.end);\n    },\n    // Returns the length of the line segment\n    length: function() {\n        var A = this.start.elements, B = this.end.elements;\n        var C1 = B[0] - A[0], C2 = B[1] - A[1], C3 = B[2] - A[2];\n        return Math.sqrt(C1 * C1 + C2 * C2 + C3 * C3);\n    },\n    // Returns the line segment as a vector equal to its\n    // end point relative to its endpoint\n    toVector: function() {\n        var A = this.start.elements, B = this.end.elements;\n        return Vector.create([\n            B[0] - A[0],\n            B[1] - A[1],\n            B[2] - A[2]\n        ]);\n    },\n    // Returns the segment's midpoint as a vector\n    midpoint: function() {\n        var A = this.start.elements, B = this.end.elements;\n        return Vector.create([\n            (B[0] + A[0]) / 2,\n            (B[1] + A[1]) / 2,\n            (B[2] + A[2]) / 2\n        ]);\n    },\n    // Returns the plane that bisects the segment\n    bisectingPlane: function() {\n        return Plane.create(this.midpoint(), this.toVector());\n    },\n    // Returns the result of translating the line by the given vector/array\n    translate: function(vector) {\n        var V = vector.elements || vector;\n        var S = this.start.elements, E = this.end.elements;\n        return Line.Segment.create([\n            S[0] + V[0],\n            S[1] + V[1],\n            S[2] + (V[2] || 0)\n        ], [\n            E[0] + V[0],\n            E[1] + V[1],\n            E[2] + (V[2] || 0)\n        ]);\n    },\n    // Returns true iff the line segment is parallel to the argument. It simply forwards\n    // the method call onto its line property.\n    isParallelTo: function(obj) {\n        return this.line.isParallelTo(obj);\n    },\n    // Returns the distance between the argument and the line segment's closest point to the argument\n    distanceFrom: function(obj) {\n        var P = this.pointClosestTo(obj);\n        return P === null ? null : P.distanceFrom(obj);\n    },\n    // Returns true iff the given point lies on the segment\n    contains: function(obj) {\n        if (obj.start && obj.end) {\n            return this.contains(obj.start) && this.contains(obj.end);\n        }\n        var P = (obj.elements || obj).slice();\n        if (P.length == 2) {\n            P.push(0);\n        }\n        if (this.start.eql(P)) {\n            return true;\n        }\n        var S = this.start.elements;\n        var V = Vector.create([\n            S[0] - P[0],\n            S[1] - P[1],\n            S[2] - (P[2] || 0)\n        ]);\n        var vect = this.toVector();\n        return V.isAntiparallelTo(vect) && V.modulus() <= vect.modulus();\n    },\n    // Returns true iff the line segment intersects the argument\n    intersects: function(obj) {\n        return this.intersectionWith(obj) !== null;\n    },\n    // Returns the unique point of intersection with the argument\n    intersectionWith: function(obj) {\n        if (!this.line.intersects(obj)) {\n            return null;\n        }\n        var P = this.line.intersectionWith(obj);\n        return this.contains(P) ? P : null;\n    },\n    // Returns the point on the line segment closest to the given object\n    pointClosestTo: function(obj) {\n        if (obj.normal) {\n            // obj is a plane\n            var V = this.line.intersectionWith(obj);\n            if (V === null) {\n                return null;\n            }\n            return this.pointClosestTo(V);\n        } else {\n            // obj is a line (segment) or point\n            var P = this.line.pointClosestTo(obj);\n            if (P === null) {\n                return null;\n            }\n            if (this.contains(P)) {\n                return P;\n            }\n            return (this.line.positionOf(P) < 0 ? this.start : this.end).dup();\n        }\n    },\n    // Set the start and end-points of the segment\n    setPoints: function(startPoint, endPoint) {\n        startPoint = Vector.create(startPoint).to3D();\n        endPoint = Vector.create(endPoint).to3D();\n        if (startPoint === null || endPoint === null) {\n            return null;\n        }\n        this.line = Line.create(startPoint, endPoint.subtract(startPoint));\n        this.start = startPoint;\n        this.end = endPoint;\n        return this;\n    }\n};\n// Constructor function\nLine.Segment.create = function(v1, v2) {\n    var S = new Line.Segment();\n    return S.setPoints(v1, v2);\n};\nmodule.exports = Line.Segment;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9saW5lLnNlZ21lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0RBQWdEO0FBQ2hELDZEQUE2RDs7QUFFN0QsSUFBSUEsT0FBT0MsbUJBQU9BLENBQUM7QUFDbkIsSUFBSUMsU0FBU0QsbUJBQU9BLENBQUM7QUFFckJELEtBQUtHLE9BQU8sR0FBRyxZQUFZO0FBQzNCSCxLQUFLRyxPQUFPLENBQUNDLFNBQVMsR0FBRztJQUV2Qiw2REFBNkQ7SUFDN0RDLEtBQUssU0FBU0MsT0FBTztRQUNuQixPQUFPLElBQUssQ0FBQ0MsS0FBSyxDQUFDRixHQUFHLENBQUNDLFFBQVFDLEtBQUssS0FBSyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0gsR0FBRyxDQUFDQyxRQUFRRSxHQUFHLEtBQzVELElBQUksQ0FBQ0QsS0FBSyxDQUFDRixHQUFHLENBQUNDLFFBQVFFLEdBQUcsS0FBSyxJQUFJLENBQUNBLEdBQUcsQ0FBQ0gsR0FBRyxDQUFDQyxRQUFRQyxLQUFLO0lBQ2hFO0lBRUEscUNBQXFDO0lBQ3JDRSxLQUFLO1FBQ0gsT0FBT1QsS0FBS0csT0FBTyxDQUFDTyxNQUFNLENBQUMsSUFBSSxDQUFDSCxLQUFLLEVBQUUsSUFBSSxDQUFDQyxHQUFHO0lBQ2pEO0lBRUEseUNBQXlDO0lBQ3pDRyxRQUFRO1FBQ04sSUFBSUMsSUFBSSxJQUFJLENBQUNMLEtBQUssQ0FBQ00sUUFBUSxFQUFFQyxJQUFJLElBQUksQ0FBQ04sR0FBRyxDQUFDSyxRQUFRO1FBQ2xELElBQUlFLEtBQUtELENBQUMsQ0FBQyxFQUFFLEdBQUdGLENBQUMsQ0FBQyxFQUFFLEVBQUVJLEtBQUtGLENBQUMsQ0FBQyxFQUFFLEdBQUdGLENBQUMsQ0FBQyxFQUFFLEVBQUVLLEtBQUtILENBQUMsQ0FBQyxFQUFFLEdBQUdGLENBQUMsQ0FBQyxFQUFFO1FBQ3hELE9BQU9NLEtBQUtDLElBQUksQ0FBQ0osS0FBR0EsS0FBS0MsS0FBR0Es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TTtZQUMvQixJQUFJLElBQUksQ0FBQ0UsUUFBUSxDQUFDRixJQUFJO2dCQUFFLE9BQU9BO1lBQUc7WUFDbEMsT0FBTyxDQUFDLElBQUksQ0FBQ0YsSUFBSSxDQUFDYSxVQUFVLENBQUNYLEtBQUssSUFBSSxJQUFJLENBQUMxQixLQUFLLEdBQUcsSUFBSSxDQUFDQyxHQUFHLEVBQUVDLEdBQUc7UUFDbEU7SUFDRjtJQUVBLDhDQUE4QztJQUM5Q29DLFdBQVcsU0FBU0MsVUFBVSxFQUFFQyxRQUFRO1FBQ3RDRCxhQUFhNUMsT0FBT1EsTUFBTSxDQUFDb0MsWUFBWUUsSUFBSTtRQUMzQ0QsV0FBVzdDLE9BQU9RLE1BQU0sQ0FBQ3FDLFVBQVVDLElBQUk7UUFDdkMsSUFBSUYsZUFBZSxRQUFRQyxhQUFhLE1BQU07WUFBRSxPQUFPO1FBQU07UUFDN0QsSUFBSSxDQUFDaEIsSUFBSSxHQUFHL0IsS0FBS1UsTUFBTSxDQUFDb0MsWUFBWUMsU0FBU0UsUUFBUSxDQUFDSDtRQUN0RCxJQUFJLENBQUN2QyxLQUFLLEdBQUd1QztRQUNiLElBQUksQ0FBQ3RDLEdBQUcsR0FBR3VDO1FBQ1gsT0FBTyxJQUFJO0lBQ2I7QUFDRjtBQUVBLHVCQUF1QjtBQUN2Qi9DLEtBQUtHLE9BQU8sQ0FBQ08sTUFBTSxHQUFHLFNBQVN3QyxFQUFFLEVBQUVDLEVBQUU7SUFDbkMsSUFBSXhCLElBQUksSUFBSTNCLEtBQUtHLE9BQU87SUFDeEIsT0FBT3dCLEVBQUVrQixTQUFTLENBQUNLLElBQUlDO0FBQ3pCO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3JELEtBQUtHLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW9uZXotbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3N5bHZlc3Rlci9saWIvbm9kZS1zeWx2ZXN0ZXIvbGluZS5zZWdtZW50LmpzPzc3YzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbCwgSmFtZXMgQ29nbGFuXG4vLyBMaW5lLlNlZ21lbnQgY2xhc3MgLSBkZXBlbmRzIG9uIExpbmUgYW5kIGl0cyBkZXBlbmRlbmNpZXMuXG5cbnZhciBMaW5lID0gcmVxdWlyZSgnLi9saW5lJyk7XG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcblxuTGluZS5TZWdtZW50ID0gZnVuY3Rpb24oKSB7fTtcbkxpbmUuU2VnbWVudC5wcm90b3R5cGUgPSB7XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbGluZSBzZWdtZW50IGlzIGVxdWFsIHRvIHRoZSBhcmd1bWVudFxuICBlcWw6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcbiAgICByZXR1cm4gKHRoaXMuc3RhcnQuZXFsKHNlZ21lbnQuc3RhcnQpICYmIHRoaXMuZW5kLmVxbChzZWdtZW50LmVuZCkpIHx8XG4gICAgICAgICh0aGlzLnN0YXJ0LmVxbChzZWdtZW50LmVuZCkgJiYgdGhpcy5lbmQuZXFsKHNlZ21lbnQuc3RhcnQpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgbGluZSBzZWdtZW50XG4gIGR1cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIExpbmUuU2VnbWVudC5jcmVhdGUodGhpcy5zdGFydCwgdGhpcy5lbmQpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50XG4gIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEEgPSB0aGlzLnN0YXJ0LmVsZW1lbnRzLCBCID0gdGhpcy5lbmQuZWxlbWVudHM7XG4gICAgdmFyIEMxID0gQlswXSAtIEFbMF0sIEMyID0gQlsxXSAtIEFbMV0sIEMzID0gQlsyXSAtIEFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydChDMSpDMSArIEMyKkMyICsgQzMqQzMpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIGxpbmUgc2VnbWVudCBhcyBhIHZlY3RvciBlcXVhbCB0byBpdHNcbiAgLy8gZW5kIHBvaW50IHJlbGF0aXZlIHRvIGl0cyBlbmRwb2ludFxuICB0b1ZlY3RvcjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIEEgPSB0aGlzLnN0YXJ0LmVsZW1lbnRzLCBCID0gdGhpcy5lbmQuZWxlbWVudHM7XG4gICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUoW0JbMF0gLSBBWzBdLCBCWzFdIC0gQVsxXSwgQlsyXSAtIEFbMl1dKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBzZWdtZW50J3MgbWlkcG9pbnQgYXMgYSB2ZWN0b3JcbiAgbWlkcG9pbnQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBBID0gdGhpcy5zdGFydC5lbGVtZW50cywgQiA9IHRoaXMuZW5kLmVsZW1lbnRzO1xuICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFsoQlswXSArIEFbMF0pLzIsIChCWzFdICsgQVsxXSkvMiwgKEJbMl0gKyBBWzJdKS8yXSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgcGxhbmUgdGhhdCBiaXNlY3RzIHRoZSBzZWdtZW50XG4gIGJpc2VjdGluZ1BsYW5lOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUGxhbmUuY3JlYXRlKHRoaXMubWlkcG9pbnQoKSwgdGhpcy50b1ZlY3RvcigpKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdHJhbnNsYXRpbmcgdGhlIGxpbmUgYnkgdGhlIGdpdmVuIHZlY3Rvci9hcnJheVxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICB2YXIgUyA9IHRoaXMuc3RhcnQuZWxlbWVudHMsIEUgPSB0aGlzLmVuZC5lbGVtZW50cztcbiAgICByZXR1cm4gTGluZS5TZWdtZW50LmNyZWF0ZShcbiAgICAgIFtTWzBdICsgVlswXSwgU1sxXSArIFZbMV0sIFNbMl0gKyAoVlsyXSB8fCAwKV0sXG4gICAgICBbRVswXSArIFZbMF0sIEVbMV0gKyBWWzFdLCBFWzJdICsgKFZbMl0gfHwgMCldXG4gICAgKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIHNlZ21lbnQgaXMgcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50LiBJdCBzaW1wbHkgZm9yd2FyZHNcbiAgLy8gdGhlIG1ldGhvZCBjYWxsIG9udG8gaXRzIGxpbmUgcHJvcGVydHkuXG4gIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMubGluZS5pc1BhcmFsbGVsVG8ob2JqKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBhcmd1bWVudCBhbmQgdGhlIGxpbmUgc2VnbWVudCdzIGNsb3Nlc3QgcG9pbnQgdG8gdGhlIGFyZ3VtZW50XG4gIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIFAgPSB0aGlzLnBvaW50Q2xvc2VzdFRvKG9iaik7XG4gICAgcmV0dXJuIChQID09PSBudWxsKSA/IG51bGwgOiBQLmRpc3RhbmNlRnJvbShvYmopO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGdpdmVuIHBvaW50IGxpZXMgb24gdGhlIHNlZ21lbnRcbiAgY29udGFpbnM6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmouc3RhcnQgJiYgb2JqLmVuZCkgeyByZXR1cm4gdGhpcy5jb250YWlucyhvYmouc3RhcnQpICYmIHRoaXMuY29udGFpbnMob2JqLmVuZCk7IH1cbiAgICB2YXIgUCA9IChvYmouZWxlbWVudHMgfHwgb2JqKS5zbGljZSgpO1xuICAgIGlmIChQLmxlbmd0aCA9PSAyKSB7IFAucHVzaCgwKTsgfVxuICAgIGlmICh0aGlzLnN0YXJ0LmVxbChQKSkgeyByZXR1cm4gdHJ1ZTsgfVxuICAgIHZhciBTID0gdGhpcy5zdGFydC5lbGVtZW50cztcbiAgICB2YXIgViA9IFZlY3Rvci5jcmVhdGUoW1NbMF0gLSBQWzBdLCBTWzFdIC0gUFsxXSwgU1syXSAtIChQWzJdIHx8IDApXSk7XG4gICAgdmFyIHZlY3QgPSB0aGlzLnRvVmVjdG9yKCk7XG4gICAgcmV0dXJuIFYuaXNBbnRpcGFyYWxsZWxUbyh2ZWN0KSAmJiBWLm1vZHVsdXMoKSA8PSB2ZWN0Lm1vZHVsdXMoKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBsaW5lIHNlZ21lbnQgaW50ZXJzZWN0cyB0aGUgYXJndW1lbnRcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICh0aGlzLmludGVyc2VjdGlvbldpdGgob2JqKSAhPT0gbnVsbCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIHBvaW50IG9mIGludGVyc2VjdGlvbiB3aXRoIHRoZSBhcmd1bWVudFxuICBpbnRlcnNlY3Rpb25XaXRoOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMubGluZS5pbnRlcnNlY3RzKG9iaikpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgUCA9IHRoaXMubGluZS5pbnRlcnNlY3Rpb25XaXRoKG9iaik7XG4gICAgcmV0dXJuICh0aGlzLmNvbnRhaW5zKFApID8gUCA6IG51bGwpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBvaW50IG9uIHRoZSBsaW5lIHNlZ21lbnQgY2xvc2VzdCB0byB0aGUgZ2l2ZW4gb2JqZWN0XG4gIHBvaW50Q2xvc2VzdFRvOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHZhciBWID0gdGhpcy5saW5lLmludGVyc2VjdGlvbldpdGgob2JqKTtcbiAgICAgIGlmIChWID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgICByZXR1cm4gdGhpcy5wb2ludENsb3Nlc3RUbyhWKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZSAoc2VnbWVudCkgb3IgcG9pbnRcbiAgICAgIHZhciBQID0gdGhpcy5saW5lLnBvaW50Q2xvc2VzdFRvKG9iaik7XG4gICAgICBpZiAoUCA9PT0gbnVsbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgaWYgKHRoaXMuY29udGFpbnMoUCkpIHsgcmV0dXJuIFA7IH1cbiAgICAgIHJldHVybiAodGhpcy5saW5lLnBvc2l0aW9uT2YoUCkgPCAwID8gdGhpcy5zdGFydCA6IHRoaXMuZW5kKS5kdXAoKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gU2V0IHRoZSBzdGFydCBhbmQgZW5kLXBvaW50cyBvZiB0aGUgc2VnbWVudFxuICBzZXRQb2ludHM6IGZ1bmN0aW9uKHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG4gICAgc3RhcnRQb2ludCA9IFZlY3Rvci5jcmVhdGUoc3RhcnRQb2ludCkudG8zRCgpO1xuICAgIGVuZFBvaW50ID0gVmVjdG9yLmNyZWF0ZShlbmRQb2ludCkudG8zRCgpO1xuICAgIGlmIChzdGFydFBvaW50ID09PSBudWxsIHx8IGVuZFBvaW50ID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgdGhpcy5saW5lID0gTGluZS5jcmVhdGUoc3RhcnRQb2ludCwgZW5kUG9pbnQuc3VidHJhY3Qoc3RhcnRQb2ludCkpO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydFBvaW50O1xuICAgIHRoaXMuZW5kID0gZW5kUG9pbnQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5MaW5lLlNlZ21lbnQuY3JlYXRlID0gZnVuY3Rpb24odjEsIHYyKSB7XG4gIHZhciBTID0gbmV3IExpbmUuU2VnbWVudCgpO1xuICByZXR1cm4gUy5zZXRQb2ludHModjEsIHYyKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGluZS5TZWdtZW50O1xuIl0sIm5hbWVzIjpbIkxpbmUiLCJyZXF1aXJlIiwiVmVjdG9yIiwiU2VnbWVudCIsInByb3RvdHlwZSIsImVxbCIsInNlZ21lbnQiLCJzdGFydCIsImVuZCIsImR1cCIsImNyZWF0ZSIsImxlbmd0aCIsIkEiLCJlbGVtZW50cyIsIkIiLCJDMSIsIkMyIiwiQzMiLCJNYXRoIiwic3FydCIsInRvVmVjdG9yIiwibWlkcG9pbnQiLCJiaXNlY3RpbmdQbGFuZSIsIlBsYW5lIiwidHJhbnNsYXRlIiwidmVjdG9yIiwiViIsIlMiLCJFIiwiaXNQYXJhbGxlbFRvIiwib2JqIiwibGluZSIsImRpc3RhbmNlRnJvbSIsIlAiLCJwb2ludENsb3Nlc3RUbyIsImNvbnRhaW5zIiwic2xpY2UiLCJwdXNoIiwidmVjdCIsImlzQW50aXBhcmFsbGVsVG8iLCJtb2R1bHVzIiwiaW50ZXJzZWN0cyIsImludGVyc2VjdGlvbldpdGgiLCJub3JtYWwiLCJwb3NpdGlvbk9mIiwic2V0UG9pbnRzIiwic3RhcnRQb2ludCIsImVuZFBvaW50IiwidG8zRCIsInN1YnRyYWN0IiwidjEiLCJ2MiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/line.segment.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/matrix.js":
/*!*************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/matrix.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// Matrix class - depends on Vector.\n\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\nvar Vector = __webpack_require__(/*! ./vector */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\n// augment a matrix M with identity rows/cols\nfunction identSize(M, m, n, k) {\n    var e = M.elements;\n    var i1 = k - 1;\n    while(i1--){\n        var row = [];\n        for(var j1 = 0; j1 < n; j1++)row.push(j1 == i1 ? 1 : 0);\n        e.unshift(row);\n    }\n    for(var i1 = k - 1; i1 < m; i1++){\n        while(e[i1].length < n)e[i1].unshift(0);\n    }\n    return $M(e);\n}\nfunction pca(X) {\n    var Sigma = X.transpose().x(X).x(1 / X.rows());\n    var svd = Sigma.svd();\n    return {\n        U: svd.U,\n        S: svd.S\n    };\n}\nfunction Matrix() {}\nMatrix.prototype = {\n    pcaProject: function(k, U) {\n        var U = U || pca(this).U;\n        var Ureduce = U.slice(1, U.rows(), 1, k);\n        return {\n            Z: this.x(Ureduce),\n            U: U\n        };\n    },\n    pcaRecover: function(U) {\n        var k = this.cols();\n        var Ureduce = U.slice(1, U.rows(), 1, k);\n        return this.x(Ureduce.transpose());\n    },\n    triu: function(k) {\n        if (!k) k = 0;\n        return this.map(function(x, i1, j1) {\n            return j1 - i1 >= k ? x : 0;\n        });\n    },\n    svd: function() {\n        var A = this;\n        var U = Matrix.I(A.rows());\n        var S = A.transpose();\n        var V = Matrix.I(A.cols());\n        var err = Number.MAX_VALUE;\n        var i1 = 0;\n        var maxLoop = 100;\n        while(err > 2.2737e-13 && i1 < maxLoop){\n            var qr = S.transpose().qr();\n            S = qr.R;\n            U = U.x(qr.Q);\n            qr = S.transpose().qr();\n            V = V.x(qr.Q);\n            S = qr.R;\n            var e = S.triu(1).unroll().norm();\n            var f = S.diagonal().norm();\n            if (f == 0) f = 1;\n            err = e / f;\n            i1++;\n        }\n        var ss = S.diagonal();\n        var s = [];\n        for(var i1 = 1; i1 <= ss.cols(); i1++){\n            var ssn = ss.e(i1);\n            s.push(Math.abs(ssn));\n            if (ssn < 0) {\n                for(var j1 = 0; j1 < U.rows(); j1++){\n                    U.elements[j1][i1 - 1] = -U.elements[j1][i1 - 1];\n                }\n            }\n        }\n        return {\n            U: U,\n            S: $V(s).toDiagonalMatrix(),\n            V: V\n        };\n    },\n    unroll: function() {\n        var v = [];\n        for(var i1 = 1; i1 <= this.cols(); i1++){\n            for(var j1 = 1; j1 <= this.rows(); j1++){\n                v.push(this.e(j1, i1));\n            }\n        }\n        return $V(v);\n    },\n    qr: function() {\n        var m = this.rows();\n        var n = this.cols();\n        var Q = Matrix.I(m);\n        var A = this;\n        for(var k = 1; k < Math.min(m, n); k++){\n            var ak = A.slice(k, 0, k, k).col(1);\n            var oneZero = [\n                1\n            ];\n            while(oneZero.length <= m - k)oneZero.push(0);\n            oneZero = $V(oneZero);\n            var vk = ak.add(oneZero.x(ak.norm() * Math.sign(ak.e(1))));\n            var Vk = $M(vk);\n            var Hk = Matrix.I(m - k + 1).subtract(Vk.x(2).x(Vk.transpose()).div(Vk.transpose().x(Vk).e(1, 1)));\n            var Qk = identSize(Hk, m, n, k);\n            A = Qk.x(A);\n            Q = Q.x(Qk);\n        }\n        return {\n            Q: Q,\n            R: A\n        };\n    },\n    slice: function(startRow, endRow, startCol, endCol) {\n        var x = [];\n        if (endRow == 0) endRow = this.rows();\n        if (endCol == 0) endCol = this.cols();\n        for(i = startRow; i <= endRow; i++){\n            var row = [];\n            for(j = startCol; j <= endCol; j++){\n                row.push(this.e(i, j));\n            }\n            x.push(row);\n        }\n        return $M(x);\n    },\n    // Returns element (i,j) of the matrix\n    e: function(i1, j1) {\n        if (i1 < 1 || i1 > this.elements.length || j1 < 1 || j1 > this.elements[0].length) {\n            return null;\n        }\n        return this.elements[i1 - 1][j1 - 1];\n    },\n    // Returns row k of the matrix as a vector\n    row: function(i1) {\n        if (i1 > this.elements.length) {\n            return null;\n        }\n        return $V(this.elements[i1 - 1]);\n    },\n    // Returns column k of the matrix as a vector\n    col: function(j1) {\n        if (j1 > this.elements[0].length) {\n            return null;\n        }\n        var col = [], n = this.elements.length;\n        for(var i1 = 0; i1 < n; i1++){\n            col.push(this.elements[i1][j1 - 1]);\n        }\n        return $V(col);\n    },\n    // Returns the number of rows/columns the matrix has\n    dimensions: function() {\n        return {\n            rows: this.elements.length,\n            cols: this.elements[0].length\n        };\n    },\n    // Returns the number of rows in the matrix\n    rows: function() {\n        return this.elements.length;\n    },\n    // Returns the number of columns in the matrix\n    cols: function() {\n        return this.elements[0].length;\n    },\n    // Returns true iff the matrix is equal to the argument. You can supply\n    // a vector as the argument, in which case the receiver must be a\n    // one-column matrix equal to the vector.\n    eql: function(matrix) {\n        var M = matrix.elements || matrix;\n        if (typeof M[0][0] == \"undefined\") {\n            M = Matrix.create(M).elements;\n        }\n        if (this.elements.length != M.length || this.elements[0].length != M[0].length) {\n            return false;\n        }\n        var i1 = this.elements.length, nj = this.elements[0].length, j1;\n        while(i1--){\n            j1 = nj;\n            while(j1--){\n                if (Math.abs(this.elements[i1][j1] - M[i1][j1]) > Sylvester.precision) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    },\n    // Returns a copy of the matrix\n    dup: function() {\n        return Matrix.create(this.elements);\n    },\n    // Maps the matrix to another matrix (of the same dimensions) according to the given function\n    map: function(fn) {\n        var els = [], i1 = this.elements.length, nj = this.elements[0].length, j1;\n        while(i1--){\n            j1 = nj;\n            els[i1] = [];\n            while(j1--){\n                els[i1][j1] = fn(this.elements[i1][j1], i1 + 1, j1 + 1);\n            }\n        }\n        return Matrix.create(els);\n    },\n    // Returns true iff the argument has the same dimensions as the matrix\n    isSameSizeAs: function(matrix) {\n        var M = matrix.elements || matrix;\n        if (typeof M[0][0] == \"undefined\") {\n            M = Matrix.create(M).elements;\n        }\n        return this.elements.length == M.length && this.elements[0].length == M[0].length;\n    },\n    // Returns the result of adding the argument to the matrix\n    add: function(matrix) {\n        if (typeof matrix == \"number\") {\n            return this.map(function(x, i1, j1) {\n                return x + matrix;\n            });\n        } else {\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] == \"undefined\") {\n                M = Matrix.create(M).elements;\n            }\n            if (!this.isSameSizeAs(M)) {\n                return null;\n            }\n            return this.map(function(x, i1, j1) {\n                return x + M[i1 - 1][j1 - 1];\n            });\n        }\n    },\n    // Returns the result of subtracting the argument from the matrix\n    subtract: function(matrix) {\n        if (typeof matrix == \"number\") {\n            return this.map(function(x, i1, j1) {\n                return x - matrix;\n            });\n        } else {\n            var M = matrix.elements || matrix;\n            if (typeof M[0][0] == \"undefined\") {\n                M = Matrix.create(M).elements;\n            }\n            if (!this.isSameSizeAs(M)) {\n                return null;\n            }\n            return this.map(function(x, i1, j1) {\n                return x - M[i1 - 1][j1 - 1];\n            });\n        }\n    },\n    // Returns true iff the matrix can multiply the argument from the left\n    canMultiplyFromLeft: function(matrix) {\n        var M = matrix.elements || matrix;\n        if (typeof M[0][0] == \"undefined\") {\n            M = Matrix.create(M).elements;\n        }\n        // this.columns should equal matrix.rows\n        return this.elements[0].length == M.length;\n    },\n    // Returns the result of a multiplication-style operation the matrix from the right by the argument.\n    // If the argument is a scalar then just operate on all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    mulOp: function(matrix, op) {\n        if (!matrix.elements) {\n            return this.map(function(x) {\n                return op(x, matrix);\n            });\n        }\n        var returnVector = matrix.modulus ? true : false;\n        var M = matrix.elements || matrix;\n        if (typeof M[0][0] == \"undefined\") M = Matrix.create(M).elements;\n        if (!this.canMultiplyFromLeft(M)) return null;\n        var e = this.elements, rowThis, rowElem, elements = [], sum, m = e.length, n = M[0].length, o = e[0].length, i1 = m, j1, k;\n        while(i1--){\n            rowElem = [];\n            rowThis = e[i1];\n            j1 = n;\n            while(j1--){\n                sum = 0;\n                k = o;\n                while(k--){\n                    sum += op(rowThis[k], M[k][j1]);\n                }\n                rowElem[j1] = sum;\n            }\n            elements[i1] = rowElem;\n        }\n        var M = Matrix.create(elements);\n        return returnVector ? M.col(1) : M;\n    },\n    // Returns the result of dividing the matrix from the right by the argument.\n    // If the argument is a scalar then just divide all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    div: function(matrix) {\n        return this.mulOp(matrix, function(x, y) {\n            return x / y;\n        });\n    },\n    // Returns the result of multiplying the matrix from the right by the argument.\n    // If the argument is a scalar then just multiply all the elements. If the argument is\n    // a vector, a vector is returned, which saves you having to remember calling\n    // col(1) on the result.\n    multiply: function(matrix) {\n        return this.mulOp(matrix, function(x, y) {\n            return x * y;\n        });\n    },\n    x: function(matrix) {\n        return this.multiply(matrix);\n    },\n    elementMultiply: function(v) {\n        return this.map(function(k, i1, j1) {\n            return v.e(i1, j1) * k;\n        });\n    },\n    sum: function() {\n        var sum = 0;\n        this.map(function(x) {\n            sum += x;\n        });\n        return sum;\n    },\n    // Returns a Vector of each colum averaged.\n    mean: function() {\n        var dim = this.dimensions();\n        var r = [];\n        for(var i1 = 1; i1 <= dim.cols; i1++){\n            r.push(this.col(i1).sum() / dim.rows);\n        }\n        return $V(r);\n    },\n    column: function(n) {\n        return this.col(n);\n    },\n    log: function() {\n        return this.map(function(x) {\n            return Math.log(x);\n        });\n    },\n    // Returns a submatrix taken from the matrix\n    // Argument order is: start row, start col, nrows, ncols\n    // Element selection wraps if the required index is outside the matrix's bounds, so you could\n    // use this to perform row/column cycling or copy-augmenting.\n    minor: function(a, b, c, d) {\n        var elements = [], ni = c, i1, nj, j1;\n        var rows = this.elements.length, cols = this.elements[0].length;\n        while(ni--){\n            i1 = c - ni - 1;\n            elements[i1] = [];\n            nj = d;\n            while(nj--){\n                j1 = d - nj - 1;\n                elements[i1][j1] = this.elements[(a + i1 - 1) % rows][(b + j1 - 1) % cols];\n            }\n        }\n        return Matrix.create(elements);\n    },\n    // Returns the transpose of the matrix\n    transpose: function() {\n        var rows = this.elements.length, i1, cols = this.elements[0].length, j1;\n        var elements = [], i1 = cols;\n        while(i1--){\n            j1 = rows;\n            elements[i1] = [];\n            while(j1--){\n                elements[i1][j1] = this.elements[j1][i1];\n            }\n        }\n        return Matrix.create(elements);\n    },\n    // Returns true iff the matrix is square\n    isSquare: function() {\n        return this.elements.length == this.elements[0].length;\n    },\n    // Returns the (absolute) largest element of the matrix\n    max: function() {\n        var m = 0, i1 = this.elements.length, nj = this.elements[0].length, j1;\n        while(i1--){\n            j1 = nj;\n            while(j1--){\n                if (Math.abs(this.elements[i1][j1]) > Math.abs(m)) {\n                    m = this.elements[i1][j1];\n                }\n            }\n        }\n        return m;\n    },\n    // Returns the indeces of the first match found by reading row-by-row from left to right\n    indexOf: function(x) {\n        var index = null, ni = this.elements.length, i1, nj = this.elements[0].length, j1;\n        for(i1 = 0; i1 < ni; i1++){\n            for(j1 = 0; j1 < nj; j1++){\n                if (this.elements[i1][j1] == x) {\n                    return {\n                        i: i1 + 1,\n                        j: j1 + 1\n                    };\n                }\n            }\n        }\n        return null;\n    },\n    // If the matrix is square, returns the diagonal elements as a vector.\n    // Otherwise, returns null.\n    diagonal: function() {\n        if (!this.isSquare) {\n            return null;\n        }\n        var els = [], n = this.elements.length;\n        for(var i1 = 0; i1 < n; i1++){\n            els.push(this.elements[i1][i1]);\n        }\n        return $V(els);\n    },\n    // Make the matrix upper (right) triangular by Gaussian elimination.\n    // This method only adds multiples of rows to other rows. No rows are\n    // scaled up or switched, and the determinant is preserved.\n    toRightTriangular: function() {\n        var M = this.dup(), els;\n        var n = this.elements.length, i1, j1, np = this.elements[0].length, p;\n        for(i1 = 0; i1 < n; i1++){\n            if (M.elements[i1][i1] == 0) {\n                for(j1 = i1 + 1; j1 < n; j1++){\n                    if (M.elements[j1][i1] != 0) {\n                        els = [];\n                        for(p = 0; p < np; p++){\n                            els.push(M.elements[i1][p] + M.elements[j1][p]);\n                        }\n                        M.elements[i1] = els;\n                        break;\n                    }\n                }\n            }\n            if (M.elements[i1][i1] != 0) {\n                for(j1 = i1 + 1; j1 < n; j1++){\n                    var multiplier = M.elements[j1][i1] / M.elements[i1][i1];\n                    els = [];\n                    for(p = 0; p < np; p++){\n                        // Elements with column numbers up to an including the number\n                        // of the row that we're subtracting can safely be set straight to\n                        // zero, since that's the point of this routine and it avoids having\n                        // to loop over and correct rounding errors later\n                        els.push(p <= i1 ? 0 : M.elements[j1][p] - M.elements[i1][p] * multiplier);\n                    }\n                    M.elements[j1] = els;\n                }\n            }\n        }\n        return M;\n    },\n    toUpperTriangular: function() {\n        return this.toRightTriangular();\n    },\n    // Returns the determinant for square matrices\n    determinant: function() {\n        if (!this.isSquare()) {\n            return null;\n        }\n        if (this.cols == 1 && this.rows == 1) {\n            return this.row(1);\n        }\n        if (this.cols == 0 && this.rows == 0) {\n            return 1;\n        }\n        var M = this.toRightTriangular();\n        var det = M.elements[0][0], n = M.elements.length;\n        for(var i1 = 1; i1 < n; i1++){\n            det = det * M.elements[i1][i1];\n        }\n        return det;\n    },\n    det: function() {\n        return this.determinant();\n    },\n    // Returns true iff the matrix is singular\n    isSingular: function() {\n        return this.isSquare() && this.determinant() === 0;\n    },\n    // Returns the trace for square matrices\n    trace: function() {\n        if (!this.isSquare()) {\n            return null;\n        }\n        var tr = this.elements[0][0], n = this.elements.length;\n        for(var i1 = 1; i1 < n; i1++){\n            tr += this.elements[i1][i1];\n        }\n        return tr;\n    },\n    tr: function() {\n        return this.trace();\n    },\n    // Returns the rank of the matrix\n    rank: function() {\n        var M = this.toRightTriangular(), rank = 0;\n        var i1 = this.elements.length, nj = this.elements[0].length, j1;\n        while(i1--){\n            j1 = nj;\n            while(j1--){\n                if (Math.abs(M.elements[i1][j1]) > Sylvester.precision) {\n                    rank++;\n                    break;\n                }\n            }\n        }\n        return rank;\n    },\n    rk: function() {\n        return this.rank();\n    },\n    // Returns the result of attaching the given argument to the right-hand side of the matrix\n    augment: function(matrix) {\n        var M = matrix.elements || matrix;\n        if (typeof M[0][0] == \"undefined\") {\n            M = Matrix.create(M).elements;\n        }\n        var T = this.dup(), cols = T.elements[0].length;\n        var i1 = T.elements.length, nj = M[0].length, j1;\n        if (i1 != M.length) {\n            return null;\n        }\n        while(i1--){\n            j1 = nj;\n            while(j1--){\n                T.elements[i1][cols + j1] = M[i1][j1];\n            }\n        }\n        return T;\n    },\n    // Returns the inverse (if one exists) using Gauss-Jordan\n    inverse: function() {\n        if (!this.isSquare() || this.isSingular()) {\n            return null;\n        }\n        var n = this.elements.length, i1 = n, j1;\n        var M = this.augment(Matrix.I(n)).toRightTriangular();\n        var np = M.elements[0].length, p, els, divisor;\n        var inverse_elements = [], new_element;\n        // Matrix is non-singular so there will be no zeros on the diagonal\n        // Cycle through rows from last to first\n        while(i1--){\n            // First, normalise diagonal elements to 1\n            els = [];\n            inverse_elements[i1] = [];\n            divisor = M.elements[i1][i1];\n            for(p = 0; p < np; p++){\n                new_element = M.elements[i1][p] / divisor;\n                els.push(new_element);\n                // Shuffle off the current row of the right hand side into the results\n                // array as it will not be modified by later runs through this loop\n                if (p >= n) {\n                    inverse_elements[i1].push(new_element);\n                }\n            }\n            M.elements[i1] = els;\n            // Then, subtract this row from those above it to\n            // give the identity matrix on the left hand side\n            j1 = i1;\n            while(j1--){\n                els = [];\n                for(p = 0; p < np; p++){\n                    els.push(M.elements[j1][p] - M.elements[i1][p] * M.elements[j1][i1]);\n                }\n                M.elements[j1] = els;\n            }\n        }\n        return Matrix.create(inverse_elements);\n    },\n    inv: function() {\n        return this.inverse();\n    },\n    // Returns the result of rounding all the elements\n    round: function() {\n        return this.map(function(x) {\n            return Math.round(x);\n        });\n    },\n    // Returns a copy of the matrix with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n        return this.map(function(p) {\n            return Math.abs(p - x) <= Sylvester.precision ? x : p;\n        });\n    },\n    // Returns a string representation of the matrix\n    inspect: function() {\n        var matrix_rows = [];\n        var n = this.elements.length;\n        for(var i1 = 0; i1 < n; i1++){\n            matrix_rows.push($V(this.elements[i1]).inspect());\n        }\n        return matrix_rows.join(\"\\n\");\n    },\n    // Returns a array representation of the matrix\n    toArray: function() {\n        var matrix_rows = [];\n        var n = this.elements.length;\n        for(var i1 = 0; i1 < n; i1++){\n            matrix_rows.push(this.elements[i1]);\n        }\n        return matrix_rows;\n    },\n    // Set the matrix's elements from an array. If the argument passed\n    // is a vector, the resulting matrix will be a single column.\n    setElements: function(els) {\n        var i1, j1, elements = els.elements || els;\n        if (typeof elements[0][0] != \"undefined\") {\n            i1 = elements.length;\n            this.elements = [];\n            while(i1--){\n                j1 = elements[i1].length;\n                this.elements[i1] = [];\n                while(j1--){\n                    this.elements[i1][j1] = elements[i1][j1];\n                }\n            }\n            return this;\n        }\n        var n = elements.length;\n        this.elements = [];\n        for(i1 = 0; i1 < n; i1++){\n            this.elements.push([\n                elements[i1]\n            ]);\n        }\n        return this;\n    },\n    maxColumnIndexes: function() {\n        var maxes = [];\n        for(var i1 = 1; i1 <= this.rows(); i1++){\n            var max = null;\n            var maxIndex = -1;\n            for(var j1 = 1; j1 <= this.cols(); j1++){\n                if (max === null || this.e(i1, j1) > max) {\n                    max = this.e(i1, j1);\n                    maxIndex = j1;\n                }\n            }\n            maxes.push(maxIndex);\n        }\n        return $V(maxes);\n    },\n    maxColumns: function() {\n        var maxes = [];\n        for(var i1 = 1; i1 <= this.rows(); i1++){\n            var max = null;\n            for(var j1 = 1; j1 <= this.cols(); j1++){\n                if (max === null || this.e(i1, j1) > max) {\n                    max = this.e(i1, j1);\n                }\n            }\n            maxes.push(max);\n        }\n        return $V(maxes);\n    },\n    minColumnIndexes: function() {\n        var mins = [];\n        for(var i1 = 1; i1 <= this.rows(); i1++){\n            var min = null;\n            var minIndex = -1;\n            for(var j1 = 1; j1 <= this.cols(); j1++){\n                if (min === null || this.e(i1, j1) < min) {\n                    min = this.e(i1, j1);\n                    minIndex = j1;\n                }\n            }\n            mins.push(minIndex);\n        }\n        return $V(mins);\n    },\n    minColumns: function() {\n        var mins = [];\n        for(var i1 = 1; i1 <= this.rows(); i1++){\n            var min = null;\n            for(var j1 = 1; j1 <= this.cols(); j1++){\n                if (min === null || this.e(i1, j1) < min) {\n                    min = this.e(i1, j1);\n                }\n            }\n            mins.push(min);\n        }\n        return $V(mins);\n    }\n};\n// Constructor function\nMatrix.create = function(elements) {\n    var M = new Matrix();\n    return M.setElements(elements);\n};\n// Identity matrix of size n\nMatrix.I = function(n) {\n    var els = [], i1 = n, j1;\n    while(i1--){\n        j1 = n;\n        els[i1] = [];\n        while(j1--){\n            els[i1][j1] = i1 == j1 ? 1 : 0;\n        }\n    }\n    return Matrix.create(els);\n};\nMatrix.loadFile = function(file) {\n    var contents = fs.readFileSync(file, \"utf-8\");\n    var matrix = [];\n    var rowArray = contents.split(\"\\n\");\n    for(var i1 = 0; i1 < rowArray.length; i1++){\n        var d = rowArray[i1].split(\",\");\n        if (d.length > 1) {\n            matrix.push(d);\n        }\n    }\n    var M = new Matrix();\n    return M.setElements(matrix);\n};\n// Diagonal matrix - all off-diagonal elements are zero\nMatrix.Diagonal = function(elements) {\n    var i1 = elements.length;\n    var M = Matrix.I(i1);\n    while(i1--){\n        M.elements[i1][i1] = elements[i1];\n    }\n    return M;\n};\n// Rotation matrix about some axis. If no axis is\n// supplied, assume we're after a 2D transform\nMatrix.Rotation = function(theta, a) {\n    if (!a) {\n        return Matrix.create([\n            [\n                Math.cos(theta),\n                -Math.sin(theta)\n            ],\n            [\n                Math.sin(theta),\n                Math.cos(theta)\n            ]\n        ]);\n    }\n    var axis = a.dup();\n    if (axis.elements.length != 3) {\n        return null;\n    }\n    var mod = axis.modulus();\n    var x = axis.elements[0] / mod, y = axis.elements[1] / mod, z = axis.elements[2] / mod;\n    var s = Math.sin(theta), c = Math.cos(theta), t = 1 - c;\n    // Formula derived here: http://www.gamedev.net/reference/articles/article1199.asp\n    // That proof rotates the co-ordinate system so theta\n    // becomes -theta and sin becomes -sin here.\n    return Matrix.create([\n        [\n            t * x * x + c,\n            t * x * y - s * z,\n            t * x * z + s * y\n        ],\n        [\n            t * x * y + s * z,\n            t * y * y + c,\n            t * y * z - s * x\n        ],\n        [\n            t * x * z - s * y,\n            t * y * z + s * x,\n            t * z * z + c\n        ]\n    ]);\n};\n// Special case rotations\nMatrix.RotationX = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n        [\n            1,\n            0,\n            0\n        ],\n        [\n            0,\n            c,\n            -s\n        ],\n        [\n            0,\n            s,\n            c\n        ]\n    ]);\n};\nMatrix.RotationY = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n        [\n            c,\n            0,\n            s\n        ],\n        [\n            0,\n            1,\n            0\n        ],\n        [\n            -s,\n            0,\n            c\n        ]\n    ]);\n};\nMatrix.RotationZ = function(t) {\n    var c = Math.cos(t), s = Math.sin(t);\n    return Matrix.create([\n        [\n            c,\n            -s,\n            0\n        ],\n        [\n            s,\n            c,\n            0\n        ],\n        [\n            0,\n            0,\n            1\n        ]\n    ]);\n};\n// Random matrix of n rows, m columns\nMatrix.Random = function(n, m) {\n    if (arguments.length === 1) m = n;\n    return Matrix.Zero(n, m).map(function() {\n        return Math.random();\n    });\n};\nMatrix.Fill = function(n, m, v) {\n    if (arguments.length === 2) {\n        v = m;\n        m = n;\n    }\n    var els = [], i1 = n, j1;\n    while(i1--){\n        j1 = m;\n        els[i1] = [];\n        while(j1--){\n            els[i1][j1] = v;\n        }\n    }\n    return Matrix.create(els);\n};\n// Matrix filled with zeros\nMatrix.Zero = function(n, m) {\n    return Matrix.Fill(n, m, 0);\n};\n// Matrix filled with zeros\nMatrix.Zeros = function(n, m) {\n    return Matrix.Zero(n, m);\n};\n// Matrix filled with ones\nMatrix.One = function(n, m) {\n    return Matrix.Fill(n, m, 1);\n};\n// Matrix filled with ones\nMatrix.Ones = function(n, m) {\n    return Matrix.One(n, m);\n};\nmodule.exports = Matrix;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9tYXRyaXguanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0RBQWdEO0FBQ2hELG9DQUFvQzs7QUFFcEMsSUFBSUEsS0FBS0MsbUJBQU9BLENBQUM7QUFDakIsSUFBSUMsWUFBWUQsbUJBQU9BLENBQUM7QUFDeEIsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUM7QUFFckIsNkNBQTZDO0FBQzdDLFNBQVNHLFVBQVVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUM7SUFDekIsSUFBSUMsSUFBSUosRUFBRUssUUFBUTtJQUNsQixJQUFJQyxLQUFJSCxJQUFJO0lBRVosTUFBTUcsS0FBSztRQUNkLElBQUlDLE1BQU0sRUFBRTtRQUVaLElBQUksSUFBSUMsS0FBSSxHQUFHQSxLQUFJTixHQUFHTSxLQUNsQkQsSUFBSUUsSUFBSSxDQUFDRCxNQUFLRixLQUFJLElBQUk7UUFFbkJGLEVBQUVNLE9BQU8sQ0FBQ0g7SUFDZDtJQUVBLElBQUksSUFBSUQsS0FBSUgsSUFBSSxHQUFHRyxLQUFJTCxHQUFHSyxLQUFLO1FBQzNCLE1BQU1GLENBQUMsQ0FBQ0UsR0FBRSxDQUFDSyxNQUFNLEdBQUdULEVBQ2hCRSxDQUFDLENBQUNFLEdBQUUsQ0FBQ0ksT0FBTyxDQUFDO0lBQ3JCO0lBRUEsT0FBT0UsR0FBR1I7QUFDZDtBQUVBLFNBQVNTLElBQUlDLENBQUM7SUFDVixJQUFJQyxRQUFRRCxFQUFFRSxTQUFTLEdBQUdDLENBQUMsQ0FBQ0gsR0FBR0csQ0FBQyxDQUFDLElBQUlILEVBQUVJLElBQUk7SUFDM0MsSUFBSUMsTUFBTUosTUFBTUksR0FBRztJQUNuQixPQUFPO1FBQUNDLEdBQUdELElBQUlDLENBQUM7UUFBRUMsR0FBR0YsSUFBSUUsQ0FBQztJQUFBO0FBQzlCO0FBRUEsU0FBU0MsVUFBVTtBQUNuQkEsT0FBT0MsU0FBUyxHQUFHO0lBQ2ZDLFlBQVksU0FBU3JCLENBQUMsRUFB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QU9nSixJQUFJLEdBQUcsU0FBU3BLLENBQUMsRUFBRUQsQ0FBQztJQUN2QixPQUFPcUIsT0FBTytJLEdBQUcsQ0FBQ25LLEdBQUdEO0FBQ3pCO0FBRUFzSyxPQUFPQyxPQUFPLEdBQUdsSiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpb25lei1uZXh0anMvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9tYXRyaXguanM/YWM4MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIDIwMTEsIENocmlzIFVtYmVsLCBKYW1lcyBDb2dsYW5cbi8vIE1hdHJpeCBjbGFzcyAtIGRlcGVuZHMgb24gVmVjdG9yLlxuXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyk7XG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcblxuLy8gYXVnbWVudCBhIG1hdHJpeCBNIHdpdGggaWRlbnRpdHkgcm93cy9jb2xzXG5mdW5jdGlvbiBpZGVudFNpemUoTSwgbSwgbiwgaykge1xuICAgIHZhciBlID0gTS5lbGVtZW50cztcbiAgICB2YXIgaSA9IGsgLSAxO1xuXG4gICAgd2hpbGUoaS0tKSB7XG5cdHZhciByb3cgPSBbXTtcblx0XG5cdGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKyspXG5cdCAgICByb3cucHVzaChqID09IGkgPyAxIDogMCk7XG5cdFxuICAgICAgICBlLnVuc2hpZnQocm93KTtcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBpID0gayAtIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgd2hpbGUoZVtpXS5sZW5ndGggPCBuKVxuICAgICAgICAgICAgZVtpXS51bnNoaWZ0KDApO1xuICAgIH1cblxuICAgIHJldHVybiAkTShlKTtcbn1cblxuZnVuY3Rpb24gcGNhKFgpIHtcbiAgICB2YXIgU2lnbWEgPSBYLnRyYW5zcG9zZSgpLngoWCkueCgxIC8gWC5yb3dzKCkpO1xuICAgIHZhciBzdmQgPSBTaWdtYS5zdmQoKTtcbiAgICByZXR1cm4ge1U6IHN2ZC5VLCBTOiBzdmQuU307XG59XG5cbmZ1bmN0aW9uIE1hdHJpeCgpIHt9XG5NYXRyaXgucHJvdG90eXBlID0ge1xuICAgIHBjYVByb2plY3Q6IGZ1bmN0aW9uKGssIFUpIHtcblx0dmFyIFUgPSBVIHx8IHBjYSh0aGlzKS5VO1xuXHR2YXIgVXJlZHVjZT0gVS5zbGljZSgxLCBVLnJvd3MoKSwgMSwgayk7XG5cdHJldHVybiB7WjogdGhpcy54KFVyZWR1Y2UpLCBVOiBVfTtcbiAgICB9LFxuXG4gICAgcGNhUmVjb3ZlcjogZnVuY3Rpb24oVSkge1xuXHR2YXIgayA9IHRoaXMuY29scygpO1xuXHR2YXIgVXJlZHVjZSA9IFUuc2xpY2UoMSwgVS5yb3dzKCksIDEsIGspO1xuXHRyZXR1cm4gdGhpcy54KFVyZWR1Y2UudHJhbnNwb3NlKCkpO1xuICAgIH0sICAgIFxuXG4gICAgdHJpdTogZnVuY3Rpb24oaykge1xuXHRpZighaylcblx0ICAgIGsgPSAwO1xuXHRcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGksIGopIHtcblx0ICAgIHJldHVybiBqIC0gaSA+PSBrID8geCA6IDA7XG5cdH0pO1xuICAgIH0sXG5cbiAgICBzdmQ6IGZ1bmN0aW9uKCkge1xuXHR2YXIgQSA9IHRoaXM7XG5cdHZhciBVID0gTWF0cml4LkkoQS5yb3dzKCkpO1xuXHR2YXIgUyA9IEEudHJhbnNwb3NlKCk7XG5cdHZhciBWID0gTWF0cml4LkkoQS5jb2xzKCkpO1xuXHR2YXIgZXJyID0gTnVtYmVyLk1BWF9WQUxVRTtcblx0dmFyIGkgPSAwO1xuXHR2YXIgbWF4TG9vcCA9IDEwMDtcblxuXHR3aGlsZShlcnIgPiAyLjI3MzdlLTEzICYmIGkgPCBtYXhMb29wKSB7XG5cdCAgICB2YXIgcXIgPSBTLnRyYW5zcG9zZSgpLnFyKCk7XG5cdCAgICBTID0gcXIuUjtcblx0ICAgIFUgPSBVLngocXIuUSk7XG5cdCAgICBxciA9IFMudHJhbnNwb3NlKCkucXIoKTtcblx0ICAgIFYgPSBWLngocXIuUSk7XG5cdCAgICBTID0gcXIuUjtcblxuXHQgICAgdmFyIGUgPSBTLnRyaXUoMSkudW5yb2xsKCkubm9ybSgpO1xuXHQgICAgdmFyIGYgPSBTLmRpYWdvbmFsKCkubm9ybSgpO1xuXG5cdCAgICBpZihmID09IDApXG5cdFx0ZiA9IDE7XG5cblx0ICAgIGVyciA9IGUgLyBmO1xuXG5cdCAgICBpKys7XG5cdH1cblxuXHR2YXIgc3MgPSBTLmRpYWdvbmFsKCk7XG5cdHZhciBzID0gW107XG5cblx0Zm9yKHZhciBpID0gMTsgaSA8PSBzcy5jb2xzKCk7IGkrKykge1xuXHQgICAgdmFyIHNzbiA9IHNzLmUoaSk7XG5cdCAgICBzLnB1c2goTWF0aC5hYnMoc3NuKSk7XG5cblx0ICAgIGlmKHNzbiA8IDApIHtcblx0XHRmb3IodmFyIGogPSAwOyBqIDwgVS5yb3dzKCk7IGorKykge1xuXHRcdCAgICBVLmVsZW1lbnRzW2pdW2kgLSAxXSA9IC0oVS5lbGVtZW50c1tqXVtpIC0gMV0pO1xuXHRcdH1cblx0ICAgIH1cblx0fVxuXG5cdHJldHVybiB7VTogVSwgUzogJFYocykudG9EaWFnb25hbE1hdHJpeCgpLCBWOiBWfTtcbiAgICB9LFxuXG4gICAgdW5yb2xsOiBmdW5jdGlvbigpIHtcblx0dmFyIHYgPSBbXTtcblx0XG5cdGZvcih2YXIgaSA9IDE7IGkgPD0gdGhpcy5jb2xzKCk7IGkrKykge1xuXHQgICAgZm9yKHZhciBqID0gMTsgaiA8PSB0aGlzLnJvd3MoKTsgaisrKSB7XG5cdFx0di5wdXNoKHRoaXMuZShqLCBpKSk7XG5cdCAgICB9XG5cdH1cblxuXHRyZXR1cm4gJFYodik7XG4gICAgfSxcblxuICAgIHFyOiBmdW5jdGlvbigpIHtcblx0dmFyIG0gPSB0aGlzLnJvd3MoKTtcblx0dmFyIG4gPSB0aGlzLmNvbHMoKTtcblx0dmFyIFEgPSBNYXRyaXguSShtKTtcblx0dmFyIEEgPSB0aGlzO1xuXHRcblx0Zm9yKHZhciBrID0gMTsgayA8IE1hdGgubWluKG0sIG4pOyBrKyspIHtcblx0ICAgIHZhciBhayA9IEEuc2xpY2UoaywgMCwgaywgaykuY29sKDEpO1xuXHQgICAgdmFyIG9uZVplcm8gPSBbMV07XG5cdCAgICBcblx0ICAgIHdoaWxlKG9uZVplcm8ubGVuZ3RoIDw9ICBtIC0gaylcblx0XHRvbmVaZXJvLnB1c2goMCk7XG5cdCAgICBcblx0ICAgIG9uZVplcm8gPSAkVihvbmVaZXJvKTtcblx0ICAgIHZhciB2ayA9IGFrLmFkZChvbmVaZXJvLngoYWsubm9ybSgpICogTWF0aC5zaWduKGFrLmUoMSkpKSk7XG5cdCAgICB2YXIgVmsgPSAkTSh2ayk7XG5cdCAgICB2YXIgSGsgPSBNYXRyaXguSShtIC0gayArIDEpLnN1YnRyYWN0KFZrLngoMikueChWay50cmFuc3Bvc2UoKSkuZGl2KFZrLnRyYW5zcG9zZSgpLngoVmspLmUoMSwgMSkpKTtcblx0ICAgIHZhciBRayA9IGlkZW50U2l6ZShIaywgbSwgbiwgayk7XG5cdCAgICBBID0gUWsueChBKTtcblx0ICAgIFEgPSBRLngoUWspO1xuXHR9XG5cblx0cmV0dXJuIHtROiBRLCBSOiBBfTtcbiAgICB9LFxuXG5cbiAgICBzbGljZTogZnVuY3Rpb24oc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2wsIGVuZENvbCkge1xuXHR2YXIgeCA9IFtdO1xuXHRcblx0aWYoZW5kUm93ID09IDApXG5cdCAgICBlbmRSb3cgPSB0aGlzLnJvd3MoKTtcblx0XG5cdGlmKGVuZENvbCA9PSAwKVxuXHQgICAgZW5kQ29sID0gdGhpcy5jb2xzKCk7XG5cblx0Zm9yKGkgPSBzdGFydFJvdzsgaSA8PSBlbmRSb3c7IGkrKykge1xuXHQgICAgdmFyIHJvdyA9IFtdO1xuXG5cdCAgICBmb3IoaiA9IHN0YXJ0Q29sOyBqIDw9IGVuZENvbDsgaisrKSB7XG5cdFx0cm93LnB1c2godGhpcy5lKGksIGopKTtcblx0ICAgIH1cblxuXHQgICAgeC5wdXNoKHJvdyk7XG5cdH1cblxuXHRyZXR1cm4gJE0oeCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZWxlbWVudCAoaSxqKSBvZiB0aGUgbWF0cml4XG4gICAgZTogZnVuY3Rpb24oaSxqKSB7XG5cdGlmIChpIDwgMSB8fCBpID4gdGhpcy5lbGVtZW50cy5sZW5ndGggfHwgaiA8IDEgfHwgaiA+IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHJldHVybiB0aGlzLmVsZW1lbnRzW2kgLSAxXVtqIC0gMV07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgcm93IGsgb2YgdGhlIG1hdHJpeCBhcyBhIHZlY3RvclxuICAgIHJvdzogZnVuY3Rpb24oaSkge1xuXHRpZiAoaSA+IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHJldHVybiAkVih0aGlzLmVsZW1lbnRzW2kgLSAxXSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgY29sdW1uIGsgb2YgdGhlIG1hdHJpeCBhcyBhIHZlY3RvclxuICAgIGNvbDogZnVuY3Rpb24oaikge1xuXHRpZiAoaiA+IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBjb2wgPSBbXSwgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgeyBjb2wucHVzaCh0aGlzLmVsZW1lbnRzW2ldW2ogLSAxXSk7IH1cblx0cmV0dXJuICRWKGNvbCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzL2NvbHVtbnMgdGhlIG1hdHJpeCBoYXNcbiAgICBkaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHtyb3dzOiB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgY29sczogdGhpcy5lbGVtZW50c1swXS5sZW5ndGh9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgbWF0cml4XG4gICAgcm93czogZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIG1hdHJpeFxuICAgIGNvbHM6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5lbGVtZW50c1swXS5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1hdHJpeCBpcyBlcXVhbCB0byB0aGUgYXJndW1lbnQuIFlvdSBjYW4gc3VwcGx5XG4gICAgLy8gYSB2ZWN0b3IgYXMgdGhlIGFyZ3VtZW50LCBpbiB3aGljaCBjYXNlIHRoZSByZWNlaXZlciBtdXN0IGJlIGFcbiAgICAvLyBvbmUtY29sdW1uIG1hdHJpeCBlcXVhbCB0byB0aGUgdmVjdG9yLlxuICAgIGVxbDogZnVuY3Rpb24obWF0cml4KSB7XG5cdHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0aWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHRpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gTS5sZW5ndGggfHxcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoICE9IE1bMF0ubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuXHR2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBuaiA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBqO1xuXHR3aGlsZSAoaS0tKSB7IGogPSBuajtcblx0XHQgICAgICB3aGlsZSAoai0tKSB7XG5cdFx0XHQgIGlmIChNYXRoLmFicyh0aGlzLmVsZW1lbnRzW2ldW2pdIC0gTVtpXVtqXSkgPiBTeWx2ZXN0ZXIucHJlY2lzaW9uKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdCAgICAgIH1cblx0XHQgICAgfVxuXHRyZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIG1hdHJpeFxuICAgIGR1cDogZnVuY3Rpb24oKSB7XG5cdHJldHVybiBNYXRyaXguY3JlYXRlKHRoaXMuZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBNYXBzIHRoZSBtYXRyaXggdG8gYW5vdGhlciBtYXRyaXggKG9mIHRoZSBzYW1lIGRpbWVuc2lvbnMpIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gZnVuY3Rpb25cbiAgICBtYXA6IGZ1bmN0aW9uKGZuKSB7XG4gICAgdmFyIGVscyA9IFtdLCBpID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIG5qID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdHdoaWxlIChpLS0pIHsgaiA9IG5qO1xuXHRcdCAgICAgIGVsc1tpXSA9IFtdO1xuXHRcdCAgICAgIHdoaWxlIChqLS0pIHtcblx0XHRcdCAgZWxzW2ldW2pdID0gZm4odGhpcy5lbGVtZW50c1tpXVtqXSwgaSArIDEsIGogKyAxKTtcblx0XHQgICAgICB9XG5cdFx0ICAgIH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgYXJndW1lbnQgaGFzIHRoZSBzYW1lIGRpbWVuc2lvbnMgYXMgdGhlIG1hdHJpeFxuICAgIGlzU2FtZVNpemVBczogZnVuY3Rpb24obWF0cml4KSB7XG5cdHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0aWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHRyZXR1cm4gKHRoaXMuZWxlbWVudHMubGVuZ3RoID09IE0ubGVuZ3RoICYmXG5cdFx0dGhpcy5lbGVtZW50c1swXS5sZW5ndGggPT0gTVswXS5sZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYWRkaW5nIHRoZSBhcmd1bWVudCB0byB0aGUgbWF0cml4XG4gICAgYWRkOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0aWYodHlwZW9mKG1hdHJpeCkgPT0gJ251bWJlcicpIHtcblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpLCBqKSB7IHJldHVybiB4ICsgbWF0cml4fSk7XG5cdH0gZWxzZSB7XG5cdCAgICB2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdCAgICBpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdCAgICBpZiAoIXRoaXMuaXNTYW1lU2l6ZUFzKE0pKSB7IHJldHVybiBudWxsOyB9XG5cdCAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSwgaikgeyByZXR1cm4geCArIE1baSAtIDFdW2ogLSAxXTsgfSk7XG5cdH1cbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHN1YnRyYWN0aW5nIHRoZSBhcmd1bWVudCBmcm9tIHRoZSBtYXRyaXhcbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24obWF0cml4KSB7XG5cdGlmKHR5cGVvZihtYXRyaXgpID09ICdudW1iZXInKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSwgaikgeyByZXR1cm4geCAtIG1hdHJpeH0pO1xuXHR9IGVsc2Uge1xuXHQgICAgdmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHQgICAgaWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHQgICAgaWYgKCF0aGlzLmlzU2FtZVNpemVBcyhNKSkgeyByZXR1cm4gbnVsbDsgfVxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGksIGopIHsgcmV0dXJuIHggLSBNW2kgLSAxXVtqIC0gMV07IH0pO1xuXHR9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1hdHJpeCBjYW4gbXVsdGlwbHkgdGhlIGFyZ3VtZW50IGZyb20gdGhlIGxlZnRcbiAgICBjYW5NdWx0aXBseUZyb21MZWZ0OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0dmFyIE0gPSBtYXRyaXguZWxlbWVudHMgfHwgbWF0cml4O1xuXHRpZiAodHlwZW9mKE1bMF1bMF0pID09ICd1bmRlZmluZWQnKSB7IE0gPSBNYXRyaXguY3JlYXRlKE0pLmVsZW1lbnRzOyB9XG5cdC8vIHRoaXMuY29sdW1ucyBzaG91bGQgZXF1YWwgbWF0cml4LnJvd3Ncblx0cmV0dXJuICh0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCA9PSBNLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIG11bHRpcGxpY2F0aW9uLXN0eWxlIG9wZXJhdGlvbiB0aGUgbWF0cml4IGZyb20gdGhlIHJpZ2h0IGJ5IHRoZSBhcmd1bWVudC5cbiAgICAvLyBJZiB0aGUgYXJndW1lbnQgaXMgYSBzY2FsYXIgdGhlbiBqdXN0IG9wZXJhdGUgb24gYWxsIHRoZSBlbGVtZW50cy4gSWYgdGhlIGFyZ3VtZW50IGlzXG4gICAgLy8gYSB2ZWN0b3IsIGEgdmVjdG9yIGlzIHJldHVybmVkLCB3aGljaCBzYXZlcyB5b3UgaGF2aW5nIHRvIHJlbWVtYmVyIGNhbGxpbmdcbiAgICAvLyBjb2woMSkgb24gdGhlIHJlc3VsdC5cbiAgICBtdWxPcDogZnVuY3Rpb24obWF0cml4LCBvcCkge1xuXHRpZiAoIW1hdHJpeC5lbGVtZW50cykge1xuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIG9wKHgsIG1hdHJpeCk7IH0pO1xuXHR9XG5cblx0dmFyIHJldHVyblZlY3RvciA9IG1hdHJpeC5tb2R1bHVzID8gdHJ1ZSA6IGZhbHNlO1xuXHR2YXIgTSA9IG1hdHJpeC5lbGVtZW50cyB8fCBtYXRyaXg7XG5cdGlmICh0eXBlb2YoTVswXVswXSkgPT0gJ3VuZGVmaW5lZCcpIFxuXHQgICAgTSA9IE1hdHJpeC5jcmVhdGUoTSkuZWxlbWVudHM7XG5cdGlmICghdGhpcy5jYW5NdWx0aXBseUZyb21MZWZ0KE0pKSBcblx0ICAgIHJldHVybiBudWxsOyBcblx0dmFyIGUgPSB0aGlzLmVsZW1lbnRzLCByb3dUaGlzLCByb3dFbGVtLCBlbGVtZW50cyA9IFtdLFxuICAgICAgICBzdW0sIG0gPSBlLmxlbmd0aCwgbiA9IE1bMF0ubGVuZ3RoLCBvID0gZVswXS5sZW5ndGgsIGkgPSBtLCBqLCBrO1xuXG5cdHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHJvd0VsZW0gPSBbXTtcbiAgICAgICAgICAgIHJvd1RoaXMgPSBlW2ldO1xuICAgICAgICAgICAgaiA9IG47XG5cbiAgICAgICAgICAgIHdoaWxlIChqLS0pIHtcblx0XHRzdW0gPSAwO1xuXHRcdGsgPSBvO1xuXG5cdFx0d2hpbGUgKGstLSkge1xuICAgICAgICAgICAgICAgICAgICBzdW0gKz0gb3Aocm93VGhpc1trXSwgTVtrXVtqXSk7XG5cdFx0fVxuXG5cdFx0cm93RWxlbVtqXSA9IHN1bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWxlbWVudHNbaV0gPSByb3dFbGVtO1xuXHR9XG5cblx0dmFyIE0gPSBNYXRyaXguY3JlYXRlKGVsZW1lbnRzKTtcblx0cmV0dXJuIHJldHVyblZlY3RvciA/IE0uY29sKDEpIDogTTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGRpdmlkaW5nIHRoZSBtYXRyaXggZnJvbSB0aGUgcmlnaHQgYnkgdGhlIGFyZ3VtZW50LlxuICAgIC8vIElmIHRoZSBhcmd1bWVudCBpcyBhIHNjYWxhciB0aGVuIGp1c3QgZGl2aWRlIGFsbCB0aGUgZWxlbWVudHMuIElmIHRoZSBhcmd1bWVudCBpc1xuICAgIC8vIGEgdmVjdG9yLCBhIHZlY3RvciBpcyByZXR1cm5lZCwgd2hpY2ggc2F2ZXMgeW91IGhhdmluZyB0byByZW1lbWJlciBjYWxsaW5nXG4gICAgLy8gY29sKDEpIG9uIHRoZSByZXN1bHQuXG4gICAgZGl2OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0cmV0dXJuIHRoaXMubXVsT3AobWF0cml4LCBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4IC8geX0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgbXVsdGlwbHlpbmcgdGhlIG1hdHJpeCBmcm9tIHRoZSByaWdodCBieSB0aGUgYXJndW1lbnQuXG4gICAgLy8gSWYgdGhlIGFyZ3VtZW50IGlzIGEgc2NhbGFyIHRoZW4ganVzdCBtdWx0aXBseSBhbGwgdGhlIGVsZW1lbnRzLiBJZiB0aGUgYXJndW1lbnQgaXNcbiAgICAvLyBhIHZlY3RvciwgYSB2ZWN0b3IgaXMgcmV0dXJuZWQsIHdoaWNoIHNhdmVzIHlvdSBoYXZpbmcgdG8gcmVtZW1iZXIgY2FsbGluZ1xuICAgIC8vIGNvbCgxKSBvbiB0aGUgcmVzdWx0LlxuICAgIG11bHRpcGx5OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0cmV0dXJuIHRoaXMubXVsT3AobWF0cml4LCBmdW5jdGlvbih4LCB5KSB7IHJldHVybiB4ICogeX0pO1xuICAgIH0sXG5cbiAgICB4OiBmdW5jdGlvbihtYXRyaXgpIHsgcmV0dXJuIHRoaXMubXVsdGlwbHkobWF0cml4KTsgfSxcblxuICAgIGVsZW1lbnRNdWx0aXBseTogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaywgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIHYuZShpLCBqKSAqIGs7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBzdW06IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHN1bSArPSB4O30pO1xuXG4gICAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBWZWN0b3Igb2YgZWFjaCBjb2x1bSBhdmVyYWdlZC5cbiAgICBtZWFuOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkaW0gPSB0aGlzLmRpbWVuc2lvbnMoKTtcbiAgICAgIHZhciByID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBkaW0uY29sczsgaSsrKSB7XG4gICAgICAgIHIucHVzaCh0aGlzLmNvbChpKS5zdW0oKSAvIGRpbS5yb3dzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAkVihyKTtcbiAgICB9LFxuXG4gICAgY29sdW1uOiBmdW5jdGlvbihuKSB7XG5cdHJldHVybiB0aGlzLmNvbChuKTtcbiAgICB9LFxuXG4gICAgbG9nOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIE1hdGgubG9nKHgpOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHN1Ym1hdHJpeCB0YWtlbiBmcm9tIHRoZSBtYXRyaXhcbiAgICAvLyBBcmd1bWVudCBvcmRlciBpczogc3RhcnQgcm93LCBzdGFydCBjb2wsIG5yb3dzLCBuY29sc1xuICAgIC8vIEVsZW1lbnQgc2VsZWN0aW9uIHdyYXBzIGlmIHRoZSByZXF1aXJlZCBpbmRleCBpcyBvdXRzaWRlIHRoZSBtYXRyaXgncyBib3VuZHMsIHNvIHlvdSBjb3VsZFxuICAgIC8vIHVzZSB0aGlzIHRvIHBlcmZvcm0gcm93L2NvbHVtbiBjeWNsaW5nIG9yIGNvcHktYXVnbWVudGluZy5cbiAgICBtaW5vcjogZnVuY3Rpb24oYSwgYiwgYywgZCkge1xuXHR2YXIgZWxlbWVudHMgPSBbXSwgbmkgPSBjLCBpLCBuaiwgajtcblx0dmFyIHJvd3MgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgY29scyA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoO1xuXHR3aGlsZSAobmktLSkge1xuXHQgICAgaSA9IGMgLSBuaSAtIDE7XG5cdCAgICBlbGVtZW50c1tpXSA9IFtdO1xuXHQgICAgbmogPSBkO1xuXHQgICAgd2hpbGUgKG5qLS0pIHtcblx0XHRqID0gZCAtIG5qIC0gMTtcblx0XHRlbGVtZW50c1tpXVtqXSA9IHRoaXMuZWxlbWVudHNbKGEgKyBpIC0gMSkgJSByb3dzXVsoYiArIGogLSAxKSAlIGNvbHNdO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBNYXRyaXguY3JlYXRlKGVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgdHJhbnNwb3NlIG9mIHRoZSBtYXRyaXhcbiAgICB0cmFuc3Bvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByb3dzID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGksIGNvbHMgPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgajtcblx0dmFyIGVsZW1lbnRzID0gW10sIGkgPSBjb2xzO1xuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBqID0gcm93cztcblx0ICAgIGVsZW1lbnRzW2ldID0gW107XG5cdCAgICB3aGlsZSAoai0tKSB7XG5cdFx0ZWxlbWVudHNbaV1bal0gPSB0aGlzLmVsZW1lbnRzW2pdW2ldO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBNYXRyaXguY3JlYXRlKGVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbWF0cml4IGlzIHNxdWFyZVxuICAgIGlzU3F1YXJlOiBmdW5jdGlvbigpIHtcblx0cmV0dXJuICh0aGlzLmVsZW1lbnRzLmxlbmd0aCA9PSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIChhYnNvbHV0ZSkgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSBtYXRyaXhcbiAgICBtYXg6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbSA9IDAsIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgbmogPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgajtcblx0d2hpbGUgKGktLSkge1xuXHQgICAgaiA9IG5qO1xuXHQgICAgd2hpbGUgKGotLSkge1xuXHRcdGlmIChNYXRoLmFicyh0aGlzLmVsZW1lbnRzW2ldW2pdKSA+IE1hdGguYWJzKG0pKSB7IG0gPSB0aGlzLmVsZW1lbnRzW2ldW2pdOyB9XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIG07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGluZGVjZXMgb2YgdGhlIGZpcnN0IG1hdGNoIGZvdW5kIGJ5IHJlYWRpbmcgcm93LWJ5LXJvdyBmcm9tIGxlZnQgdG8gcmlnaHRcbiAgICBpbmRleE9mOiBmdW5jdGlvbih4KSB7XG5cdHZhciBpbmRleCA9IG51bGwsIG5pID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGksIG5qID0gdGhpcy5lbGVtZW50c1swXS5sZW5ndGgsIGo7XG5cdGZvciAoaSA9IDA7IGkgPCBuaTsgaSsrKSB7XG5cdCAgICBmb3IgKGogPSAwOyBqIDwgbmo7IGorKykge1xuXHRcdGlmICh0aGlzLmVsZW1lbnRzW2ldW2pdID09IHgpIHsgcmV0dXJuIHtpOiBpICsgMSwgajogaiArIDF9OyB9XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8vIElmIHRoZSBtYXRyaXggaXMgc3F1YXJlLCByZXR1cm5zIHRoZSBkaWFnb25hbCBlbGVtZW50cyBhcyBhIHZlY3Rvci5cbiAgICAvLyBPdGhlcndpc2UsIHJldHVybnMgbnVsbC5cbiAgICBkaWFnb25hbDogZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1NxdWFyZSkgeyByZXR1cm4gbnVsbDsgfVxuXHR2YXIgZWxzID0gW10sIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGVscy5wdXNoKHRoaXMuZWxlbWVudHNbaV1baV0pO1xuXHR9XG5cdHJldHVybiAkVihlbHMpO1xuICAgIH0sXG5cbiAgICAvLyBNYWtlIHRoZSBtYXRyaXggdXBwZXIgKHJpZ2h0KSB0cmlhbmd1bGFyIGJ5IEdhdXNzaWFuIGVsaW1pbmF0aW9uLlxuICAgIC8vIFRoaXMgbWV0aG9kIG9ubHkgYWRkcyBtdWx0aXBsZXMgb2Ygcm93cyB0byBvdGhlciByb3dzLiBObyByb3dzIGFyZVxuICAgIC8vIHNjYWxlZCB1cCBvciBzd2l0Y2hlZCwgYW5kIHRoZSBkZXRlcm1pbmFudCBpcyBwcmVzZXJ2ZWQuXG4gICAgdG9SaWdodFRyaWFuZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHR2YXIgTSA9IHRoaXMuZHVwKCksIGVscztcblx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aCwgaSwgaiwgbnAgPSB0aGlzLmVsZW1lbnRzWzBdLmxlbmd0aCwgcDtcblx0Zm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgaWYgKE0uZWxlbWVudHNbaV1baV0gPT0gMCkge1xuXHRcdGZvciAoaiA9IGkgKyAxOyBqIDwgbjsgaisrKSB7XG5cdFx0ICAgIGlmIChNLmVsZW1lbnRzW2pdW2ldICE9IDApIHtcblx0XHRcdGVscyA9IFtdO1xuXHRcdFx0Zm9yIChwID0gMDsgcCA8IG5wOyBwKyspIHsgZWxzLnB1c2goTS5lbGVtZW50c1tpXVtwXSArIE0uZWxlbWVudHNbal1bcF0pOyB9XG5cdFx0XHRNLmVsZW1lbnRzW2ldID0gZWxzO1xuXHRcdFx0YnJlYWs7XG5cdFx0ICAgIH1cblx0XHR9XG5cdCAgICB9XG5cdCAgICBpZiAoTS5lbGVtZW50c1tpXVtpXSAhPSAwKSB7XG5cdFx0Zm9yIChqID0gaSArIDE7IGogPCBuOyBqKyspIHtcblx0XHQgICAgdmFyIG11bHRpcGxpZXIgPSBNLmVsZW1lbnRzW2pdW2ldIC8gTS5lbGVtZW50c1tpXVtpXTtcblx0XHQgICAgZWxzID0gW107XG5cdFx0ICAgIGZvciAocCA9IDA7IHAgPCBucDsgcCsrKSB7XG5cdFx0XHQvLyBFbGVtZW50cyB3aXRoIGNvbHVtbiBudW1iZXJzIHVwIHRvIGFuIGluY2x1ZGluZyB0aGUgbnVtYmVyXG5cdFx0XHQvLyBvZiB0aGUgcm93IHRoYXQgd2UncmUgc3VidHJhY3RpbmcgY2FuIHNhZmVseSBiZSBzZXQgc3RyYWlnaHQgdG9cblx0XHRcdC8vIHplcm8sIHNpbmNlIHRoYXQncyB0aGUgcG9pbnQgb2YgdGhpcyByb3V0aW5lIGFuZCBpdCBhdm9pZHMgaGF2aW5nXG5cdFx0XHQvLyB0byBsb29wIG92ZXIgYW5kIGNvcnJlY3Qgcm91bmRpbmcgZXJyb3JzIGxhdGVyXG5cdFx0XHRlbHMucHVzaChwIDw9IGkgPyAwIDogTS5lbGVtZW50c1tqXVtwXSAtIE0uZWxlbWVudHNbaV1bcF0gKiBtdWx0aXBsaWVyKTtcblx0XHQgICAgfVxuXHRcdCAgICBNLmVsZW1lbnRzW2pdID0gZWxzO1xuXHRcdH1cblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gTTtcbiAgICB9LFxuXG4gICAgdG9VcHBlclRyaWFuZ3VsYXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50b1JpZ2h0VHJpYW5ndWxhcigpOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgZGV0ZXJtaW5hbnQgZm9yIHNxdWFyZSBtYXRyaWNlc1xuICAgIGRldGVybWluYW50OiBmdW5jdGlvbigpIHtcblx0aWYgKCF0aGlzLmlzU3F1YXJlKCkpIHsgcmV0dXJuIG51bGw7IH1cblx0aWYgKHRoaXMuY29scyA9PSAxICYmIHRoaXMucm93cyA9PSAxKSB7IHJldHVybiB0aGlzLnJvdygxKTsgfVxuXHRpZiAodGhpcy5jb2xzID09IDAgJiYgdGhpcy5yb3dzID09IDApIHsgcmV0dXJuIDE7IH1cblx0dmFyIE0gPSB0aGlzLnRvUmlnaHRUcmlhbmd1bGFyKCk7XG5cdHZhciBkZXQgPSBNLmVsZW1lbnRzWzBdWzBdLCBuID0gTS5lbGVtZW50cy5sZW5ndGg7XG5cdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdCAgICBkZXQgPSBkZXQgKiBNLmVsZW1lbnRzW2ldW2ldO1xuXHR9XG5cdHJldHVybiBkZXQ7XG4gICAgfSxcbiAgICBkZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kZXRlcm1pbmFudCgpOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgbWF0cml4IGlzIHNpbmd1bGFyXG4gICAgaXNTaW5ndWxhcjogZnVuY3Rpb24oKSB7XG5cdHJldHVybiAodGhpcy5pc1NxdWFyZSgpICYmIHRoaXMuZGV0ZXJtaW5hbnQoKSA9PT0gMCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHRyYWNlIGZvciBzcXVhcmUgbWF0cmljZXNcbiAgICB0cmFjZTogZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1NxdWFyZSgpKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciB0ciA9IHRoaXMuZWxlbWVudHNbMF1bMF0sIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0ICAgIHRyICs9IHRoaXMuZWxlbWVudHNbaV1baV07XG5cdH1cblx0cmV0dXJuIHRyO1xuICAgIH0sXG5cbiAgICB0cjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRyYWNlKCk7IH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByYW5rIG9mIHRoZSBtYXRyaXhcbiAgICByYW5rOiBmdW5jdGlvbigpIHtcblx0dmFyIE0gPSB0aGlzLnRvUmlnaHRUcmlhbmd1bGFyKCksIHJhbmsgPSAwO1xuXHR2YXIgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBuaiA9IHRoaXMuZWxlbWVudHNbMF0ubGVuZ3RoLCBqO1xuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBqID0gbmo7XG5cdCAgICB3aGlsZSAoai0tKSB7XG5cdFx0aWYgKE1hdGguYWJzKE0uZWxlbWVudHNbaV1bal0pID4gU3lsdmVzdGVyLnByZWNpc2lvbikgeyByYW5rKys7IGJyZWFrOyB9XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIHJhbms7XG4gICAgfSxcblxuICAgIHJrOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucmFuaygpOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGF0dGFjaGluZyB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gdGhlIHJpZ2h0LWhhbmQgc2lkZSBvZiB0aGUgbWF0cml4XG4gICAgYXVnbWVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdHZhciBNID0gbWF0cml4LmVsZW1lbnRzIHx8IG1hdHJpeDtcblx0aWYgKHR5cGVvZihNWzBdWzBdKSA9PSAndW5kZWZpbmVkJykgeyBNID0gTWF0cml4LmNyZWF0ZShNKS5lbGVtZW50czsgfVxuXHR2YXIgVCA9IHRoaXMuZHVwKCksIGNvbHMgPSBULmVsZW1lbnRzWzBdLmxlbmd0aDtcblx0dmFyIGkgPSBULmVsZW1lbnRzLmxlbmd0aCwgbmogPSBNWzBdLmxlbmd0aCwgajtcblx0aWYgKGkgIT0gTS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0d2hpbGUgKGktLSkge1xuXHQgICAgaiA9IG5qO1xuXHQgICAgd2hpbGUgKGotLSkge1xuXHRcdFQuZWxlbWVudHNbaV1bY29scyArIGpdID0gTVtpXVtqXTtcblx0ICAgIH1cblx0fVxuXHRyZXR1cm4gVDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgaW52ZXJzZSAoaWYgb25lIGV4aXN0cykgdXNpbmcgR2F1c3MtSm9yZGFuXG4gICAgaW52ZXJzZTogZnVuY3Rpb24oKSB7XG5cdGlmICghdGhpcy5pc1NxdWFyZSgpIHx8IHRoaXMuaXNTaW5ndWxhcigpKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGgsIGkgPSBuLCBqO1xuXHR2YXIgTSA9IHRoaXMuYXVnbWVudChNYXRyaXguSShuKSkudG9SaWdodFRyaWFuZ3VsYXIoKTtcblx0dmFyIG5wID0gTS5lbGVtZW50c1swXS5sZW5ndGgsIHAsIGVscywgZGl2aXNvcjtcblx0dmFyIGludmVyc2VfZWxlbWVudHMgPSBbXSwgbmV3X2VsZW1lbnQ7XG5cdC8vIE1hdHJpeCBpcyBub24tc2luZ3VsYXIgc28gdGhlcmUgd2lsbCBiZSBubyB6ZXJvcyBvbiB0aGUgZGlhZ29uYWxcblx0Ly8gQ3ljbGUgdGhyb3VnaCByb3dzIGZyb20gbGFzdCB0byBmaXJzdFxuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICAvLyBGaXJzdCwgbm9ybWFsaXNlIGRpYWdvbmFsIGVsZW1lbnRzIHRvIDFcblx0ICAgIGVscyA9IFtdO1xuXHQgICAgaW52ZXJzZV9lbGVtZW50c1tpXSA9IFtdO1xuXHQgICAgZGl2aXNvciA9IE0uZWxlbWVudHNbaV1baV07XG5cdCAgICBmb3IgKHAgPSAwOyBwIDwgbnA7IHArKykge1xuICAgICAgICBuZXdfZWxlbWVudCA9IE0uZWxlbWVudHNbaV1bcF0gLyBkaXZpc29yO1xuXHRcdGVscy5wdXNoKG5ld19lbGVtZW50KTtcblx0XHQvLyBTaHVmZmxlIG9mZiB0aGUgY3VycmVudCByb3cgb2YgdGhlIHJpZ2h0IGhhbmQgc2lkZSBpbnRvIHRoZSByZXN1bHRzXG5cdFx0Ly8gYXJyYXkgYXMgaXQgd2lsbCBub3QgYmUgbW9kaWZpZWQgYnkgbGF0ZXIgcnVucyB0aHJvdWdoIHRoaXMgbG9vcFxuXHRcdGlmIChwID49IG4pIHsgaW52ZXJzZV9lbGVtZW50c1tpXS5wdXNoKG5ld19lbGVtZW50KTsgfVxuXHQgICAgfVxuXHQgICAgTS5lbGVtZW50c1tpXSA9IGVscztcblx0ICAgIC8vIFRoZW4sIHN1YnRyYWN0IHRoaXMgcm93IGZyb20gdGhvc2UgYWJvdmUgaXQgdG9cblx0ICAgIC8vIGdpdmUgdGhlIGlkZW50aXR5IG1hdHJpeCBvbiB0aGUgbGVmdCBoYW5kIHNpZGVcblx0ICAgIGogPSBpO1xuXHQgICAgd2hpbGUgKGotLSkge1xuXHRcdGVscyA9IFtdO1xuXHRcdGZvciAocCA9IDA7IHAgPCBucDsgcCsrKSB7XG5cdFx0ICAgIGVscy5wdXNoKE0uZWxlbWVudHNbal1bcF0gLSBNLmVsZW1lbnRzW2ldW3BdICogTS5lbGVtZW50c1tqXVtpXSk7XG5cdFx0fVxuXHRcdE0uZWxlbWVudHNbal0gPSBlbHM7XG5cdCAgICB9XG5cdH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoaW52ZXJzZV9lbGVtZW50cyk7XG4gICAgfSxcblxuICAgIGludjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmludmVyc2UoKTsgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiByb3VuZGluZyBhbGwgdGhlIGVsZW1lbnRzXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSBtYXRyaXggd2l0aCBlbGVtZW50cyBzZXQgdG8gdGhlIGdpdmVuIHZhbHVlIGlmIHRoZXlcbiAgICAvLyBkaWZmZXIgZnJvbSBpdCBieSBsZXNzIHRoYW4gU3lsdmVzdGVyLnByZWNpc2lvblxuICAgIHNuYXBUbzogZnVuY3Rpb24oeCkge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24ocCkge1xuXHQgICAgcmV0dXJuIChNYXRoLmFicyhwIC0geCkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbikgPyB4IDogcDtcblx0fSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICAgIGluc3BlY3Q6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWF0cml4X3Jvd3MgPSBbXTtcblx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIG1hdHJpeF9yb3dzLnB1c2goJFYodGhpcy5lbGVtZW50c1tpXSkuaW5zcGVjdCgpKTtcblx0fVxuXHRyZXR1cm4gbWF0cml4X3Jvd3Muam9pbignXFxuJyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBhcnJheSByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gICAgdG9BcnJheTogZnVuY3Rpb24oKSB7XG4gICAgXHR2YXIgbWF0cml4X3Jvd3MgPSBbXTtcbiAgICBcdHZhciBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBtYXRyaXhfcm93cy5wdXNoKHRoaXMuZWxlbWVudHNbaV0pO1xuICAgIFx0fVxuICAgICAgcmV0dXJuIG1hdHJpeF9yb3dzO1xuICAgIH0sXG5cblxuICAgIC8vIFNldCB0aGUgbWF0cml4J3MgZWxlbWVudHMgZnJvbSBhbiBhcnJheS4gSWYgdGhlIGFyZ3VtZW50IHBhc3NlZFxuICAgIC8vIGlzIGEgdmVjdG9yLCB0aGUgcmVzdWx0aW5nIG1hdHJpeCB3aWxsIGJlIGEgc2luZ2xlIGNvbHVtbi5cbiAgICBzZXRFbGVtZW50czogZnVuY3Rpb24oZWxzKSB7XG5cdHZhciBpLCBqLCBlbGVtZW50cyA9IGVscy5lbGVtZW50cyB8fCBlbHM7XG5cdGlmICh0eXBlb2YoZWxlbWVudHNbMF1bMF0pICE9ICd1bmRlZmluZWQnKSB7XG5cdCAgICBpID0gZWxlbWVudHMubGVuZ3RoO1xuXHQgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xuXHQgICAgd2hpbGUgKGktLSkge1xuXHRcdGogPSBlbGVtZW50c1tpXS5sZW5ndGg7XG5cdFx0dGhpcy5lbGVtZW50c1tpXSA9IFtdO1xuXHRcdHdoaWxlIChqLS0pIHtcblx0XHQgICAgdGhpcy5lbGVtZW50c1tpXVtqXSA9IGVsZW1lbnRzW2ldW2pdO1xuXHRcdH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHR9XG5cdHZhciBuID0gZWxlbWVudHMubGVuZ3RoO1xuXHR0aGlzLmVsZW1lbnRzID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIHRoaXMuZWxlbWVudHMucHVzaChbZWxlbWVudHNbaV1dKTtcblx0fVxuXHRyZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbWF4Q29sdW1uSW5kZXhlczogZnVuY3Rpb24oKSB7XG5cdHZhciBtYXhlcyA9IFtdO1xuXG5cdGZvcih2YXIgaSA9IDE7IGkgPD0gdGhpcy5yb3dzKCk7IGkrKykge1xuXHQgICAgdmFyIG1heCA9IG51bGw7XG5cdCAgICB2YXIgbWF4SW5kZXggPSAtMTtcblxuXHQgICAgZm9yKHZhciBqID0gMTsgaiA8PSB0aGlzLmNvbHMoKTsgaisrKSB7XG5cdFx0aWYobWF4ID09PSBudWxsIHx8IHRoaXMuZShpLCBqKSA+IG1heCkge1xuXHRcdCAgICBtYXggPSB0aGlzLmUoaSwgaik7XG5cdFx0ICAgIG1heEluZGV4ID0gajtcblx0XHR9XG5cdCAgICB9XG5cblx0ICAgIG1heGVzLnB1c2gobWF4SW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuICRWKG1heGVzKTtcbiAgICB9LFxuXG4gICAgbWF4Q29sdW1uczogZnVuY3Rpb24oKSB7XG5cdHZhciBtYXhlcyA9IFtdO1xuXG5cdGZvcih2YXIgaSA9IDE7IGkgPD0gdGhpcy5yb3dzKCk7IGkrKykge1xuXHQgICAgdmFyIG1heCA9IG51bGw7XG5cblx0ICAgIGZvcih2YXIgaiA9IDE7IGogPD0gdGhpcy5jb2xzKCk7IGorKykge1xuXHRcdGlmKG1heCA9PT0gbnVsbCB8fCB0aGlzLmUoaSwgaikgPiBtYXgpIHtcblx0XHQgICAgbWF4ID0gdGhpcy5lKGksIGopO1xuXHRcdH1cblx0ICAgIH1cblxuXHQgICAgbWF4ZXMucHVzaChtYXgpO1xuXHR9XG5cblx0cmV0dXJuICRWKG1heGVzKTtcbiAgICB9LFxuXG4gICAgbWluQ29sdW1uSW5kZXhlczogZnVuY3Rpb24oKSB7XG5cdHZhciBtaW5zID0gW107XG5cblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvd3MoKTsgaSsrKSB7XG5cdCAgICB2YXIgbWluID0gbnVsbDtcblx0ICAgIHZhciBtaW5JbmRleCA9IC0xO1xuXG5cdCAgICBmb3IodmFyIGogPSAxOyBqIDw9IHRoaXMuY29scygpOyBqKyspIHtcblx0XHRpZihtaW4gPT09IG51bGwgfHwgdGhpcy5lKGksIGopIDwgbWluKSB7XG5cdFx0ICAgIG1pbiA9IHRoaXMuZShpLCBqKTtcblx0XHQgICAgbWluSW5kZXggPSBqO1xuXHRcdH1cblx0ICAgIH1cblxuXHQgICAgbWlucy5wdXNoKG1pbkluZGV4KTtcblx0fVxuXG5cdHJldHVybiAkVihtaW5zKTtcbiAgICB9LFxuXG4gICAgbWluQ29sdW1uczogZnVuY3Rpb24oKSB7XG5cdHZhciBtaW5zID0gW107XG5cblx0Zm9yKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvd3MoKTsgaSsrKSB7XG5cdCAgICB2YXIgbWluID0gbnVsbDtcblxuXHQgICAgZm9yKHZhciBqID0gMTsgaiA8PSB0aGlzLmNvbHMoKTsgaisrKSB7XG5cdFx0aWYobWluID09PSBudWxsIHx8IHRoaXMuZShpLCBqKSA8IG1pbikge1xuXHRcdCAgICBtaW4gPSB0aGlzLmUoaSwgaik7XG5cdFx0fVxuXHQgICAgfVxuXG5cdCAgICBtaW5zLnB1c2gobWluKTtcblx0fVxuXG5cdHJldHVybiAkVihtaW5zKTtcbiAgICB9XG59O1xuXG4vLyBDb25zdHJ1Y3RvciBmdW5jdGlvblxuTWF0cml4LmNyZWF0ZSA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XG4gICAgcmV0dXJuIE0uc2V0RWxlbWVudHMoZWxlbWVudHMpO1xufTtcblxuLy8gSWRlbnRpdHkgbWF0cml4IG9mIHNpemUgblxuTWF0cml4LkkgPSBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGVscyA9IFtdLCBpID0gbiwgajtcbiAgICB3aGlsZSAoaS0tKSB7XG5cdGogPSBuO1xuXHRlbHNbaV0gPSBbXTtcblx0d2hpbGUgKGotLSkge1xuXHQgICAgZWxzW2ldW2pdID0gKGkgPT0gaikgPyAxIDogMDtcblx0fVxuICAgIH1cbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShlbHMpO1xufTtcblxuTWF0cml4LmxvYWRGaWxlID0gZnVuY3Rpb24oZmlsZSkge1xuICAgIHZhciBjb250ZW50cyA9IGZzLnJlYWRGaWxlU3luYyhmaWxlLCAndXRmLTgnKTtcbiAgICB2YXIgbWF0cml4ID0gW107XG5cbiAgICB2YXIgcm93QXJyYXkgPSBjb250ZW50cy5zcGxpdCgnXFxuJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dBcnJheS5sZW5ndGg7IGkrKykge1xuXHR2YXIgZCA9IHJvd0FycmF5W2ldLnNwbGl0KCcsJyk7XG5cdGlmIChkLmxlbmd0aCA+IDEpIHtcblx0ICAgIG1hdHJpeC5wdXNoKGQpO1xuXHR9XG4gICAgfVxuXG4gICAgdmFyIE0gPSBuZXcgTWF0cml4KCk7XG4gICAgcmV0dXJuIE0uc2V0RWxlbWVudHMobWF0cml4KTtcbn07XG5cbi8vIERpYWdvbmFsIG1hdHJpeCAtIGFsbCBvZmYtZGlhZ29uYWwgZWxlbWVudHMgYXJlIHplcm9cbk1hdHJpeC5EaWFnb25hbCA9IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG4gICAgdmFyIGkgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgdmFyIE0gPSBNYXRyaXguSShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG5cdE0uZWxlbWVudHNbaV1baV0gPSBlbGVtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIE07XG59O1xuXG4vLyBSb3RhdGlvbiBtYXRyaXggYWJvdXQgc29tZSBheGlzLiBJZiBubyBheGlzIGlzXG4vLyBzdXBwbGllZCwgYXNzdW1lIHdlJ3JlIGFmdGVyIGEgMkQgdHJhbnNmb3JtXG5NYXRyaXguUm90YXRpb24gPSBmdW5jdGlvbih0aGV0YSwgYSkge1xuICAgIGlmICghYSkge1xuXHRyZXR1cm4gTWF0cml4LmNyZWF0ZShbXG5cdCAgICBbTWF0aC5jb3ModGhldGEpLCAtTWF0aC5zaW4odGhldGEpXSxcblx0ICAgIFtNYXRoLnNpbih0aGV0YSksIE1hdGguY29zKHRoZXRhKV1cblx0XSk7XG4gIH1cbiAgICB2YXIgYXhpcyA9IGEuZHVwKCk7XG4gICAgaWYgKGF4aXMuZWxlbWVudHMubGVuZ3RoICE9IDMpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB2YXIgbW9kID0gYXhpcy5tb2R1bHVzKCk7XG4gICAgdmFyIHggPSBheGlzLmVsZW1lbnRzWzBdIC8gbW9kLCB5ID0gYXhpcy5lbGVtZW50c1sxXSAvIG1vZCwgeiA9IGF4aXMuZWxlbWVudHNbMl0gLyBtb2Q7XG4gICAgdmFyIHMgPSBNYXRoLnNpbih0aGV0YSksIGMgPSBNYXRoLmNvcyh0aGV0YSksIHQgPSAxIC0gYztcbiAgICAvLyBGb3JtdWxhIGRlcml2ZWQgaGVyZTogaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXG4gICAgLy8gVGhhdCBwcm9vZiByb3RhdGVzIHRoZSBjby1vcmRpbmF0ZSBzeXN0ZW0gc28gdGhldGFcbiAgICAvLyBiZWNvbWVzIC10aGV0YSBhbmQgc2luIGJlY29tZXMgLXNpbiBoZXJlLlxuICAgIHJldHVybiBNYXRyaXguY3JlYXRlKFtcblx0W3QgKiB4ICogeCArIGMsIHQgKiB4ICogeSAtIHMgKiB6LCB0ICogeCAqIHogKyBzICogeV0sXG5cdFt0ICogeCAqIHkgKyBzICogeiwgdCAqIHkgKiB5ICsgYywgdCAqIHkgKiB6IC0gcyAqIHhdLFxuXHRbdCAqIHggKiB6IC0gcyAqIHksIHQgKiB5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjXVxuICAgIF0pO1xufTtcblxuLy8gU3BlY2lhbCBjYXNlIHJvdGF0aW9uc1xuTWF0cml4LlJvdGF0aW9uWCA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKHQpLCBzID0gTWF0aC5zaW4odCk7XG4gICAgcmV0dXJuIE1hdHJpeC5jcmVhdGUoW1xuXHRbMSwgMCwgMF0sXG5cdFswLCBjLCAtc10sXG5cdFswLCBzLCBjXVxuICAgIF0pO1xufTtcblxuTWF0cml4LlJvdGF0aW9uWSA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKHQpLCBzID0gTWF0aC5zaW4odCk7XG4gICAgcmV0dXJuIE1hdHJpeC5jcmVhdGUoW1xuXHRbYywgMCwgc10sXG5cdFswLCAxLCAwXSxcblx0Wy1zLCAwLCBjXVxuICAgIF0pO1xufTtcblxuTWF0cml4LlJvdGF0aW9uWiA9IGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKHQpLCBzID0gTWF0aC5zaW4odCk7XG4gICAgcmV0dXJuIE1hdHJpeC5jcmVhdGUoW1xuXHRbYywgLXMsIDBdLFxuXHRbcywgYywgMF0sXG5cdFswLCAwLCAxXVxuICAgIF0pO1xufTtcblxuLy8gUmFuZG9tIG1hdHJpeCBvZiBuIHJvd3MsIG0gY29sdW1uc1xuTWF0cml4LlJhbmRvbSA9IGZ1bmN0aW9uKG4sIG0pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgbSA9IG47XG4gICAgcmV0dXJuIE1hdHJpeC5aZXJvKG4sIG0pLm1hcChcblx0ZnVuY3Rpb24oKSB7IHJldHVybiBNYXRoLnJhbmRvbSgpOyB9XG4gICk7XG59O1xuXG5NYXRyaXguRmlsbCA9IGZ1bmN0aW9uKG4sIG0sIHYpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuXHR2ID0gbTtcblx0bSA9IG47XG4gICAgfVxuXG4gICAgdmFyIGVscyA9IFtdLCBpID0gbiwgajtcblxuICAgIHdoaWxlIChpLS0pIHtcblx0aiA9IG07XG5cdGVsc1tpXSA9IFtdO1xuXG5cdHdoaWxlIChqLS0pIHtcblx0ICAgIGVsc1tpXVtqXSA9IHY7XG5cdH1cbiAgICB9XG5cbiAgICByZXR1cm4gTWF0cml4LmNyZWF0ZShlbHMpO1xufTtcblxuLy8gTWF0cml4IGZpbGxlZCB3aXRoIHplcm9zXG5NYXRyaXguWmVybyA9IGZ1bmN0aW9uKG4sIG0pIHtcbiAgICByZXR1cm4gTWF0cml4LkZpbGwobiwgbSwgMCk7XG59O1xuXG4vLyBNYXRyaXggZmlsbGVkIHdpdGggemVyb3Ncbk1hdHJpeC5aZXJvcyA9IGZ1bmN0aW9uKG4sIG0pIHtcbiAgICByZXR1cm4gTWF0cml4Llplcm8obiwgbSk7XG59O1xuXG4vLyBNYXRyaXggZmlsbGVkIHdpdGggb25lc1xuTWF0cml4Lk9uZSA9IGZ1bmN0aW9uKG4sIG0pIHtcbiAgICByZXR1cm4gTWF0cml4LkZpbGwobiwgbSwgMSk7XG59O1xuXG4vLyBNYXRyaXggZmlsbGVkIHdpdGggb25lc1xuTWF0cml4Lk9uZXMgPSBmdW5jdGlvbihuLCBtKSB7XG4gICAgcmV0dXJuIE1hdHJpeC5PbmUobiwgbSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdHJpeDtcbiJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJTeWx2ZXN0ZXIiLCJWZWN0b3IiLCJpZGVudFNpemUiLCJNIiwibSIsIm4iLCJrIiwiZSIsImVsZW1lbnRzIiwiaSIsInJvdyIsImoiLCJwdXNoIiwidW5zaGlmdCIsImxlbmd0aCIsIiRNIiwicGNhIiwiWCIsIlNpZ21hIiwidHJhbnNwb3NlIiwieCIsInJvd3MiLCJzdmQiLCJVIiwiUyIsIk1hdHJpeCIsInByb3RvdHlwZSIsInBjYVByb2plY3QiLCJVcmVkdWNlIiwic2xpY2UiLCJaIiwicGNhUmVjb3ZlciIsImNvbHMiLCJ0cml1IiwibWFwIiwiQSIsIkkiLCJWIiwiZXJyIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibWF4TG9vcCIsInFyIiwiUiIsIlEiLCJ1bnJvbGwiLCJub3JtIiwiZiIsImRpYWdvbmFsIiwic3MiLCJzIiwic3NuIiwiTWF0aCIsImFicyIsIiRWIiwidG9EaWFnb25hbE1hdHJpeCIsInYiLCJtaW4iLCJhayIsImNvbCIsIm9uZVplcm8iLCJ2ayIsImFkZCIsInNpZ24iLCJWayIsIkhrIiwic3VidHJhY3QiLCJkaXYiLCJRayIsInN0YXJ0Um93IiwiZW5kUm93Iiwic3RhcnRDb2wiLCJlbmRDb2wiLCJkaW1lbnNpb25zIiwiZXFsIiwibWF0cml4IiwiY3JlYXRlIiwibmoiLCJwcmVjaXNpb24iLCJkdXAiLCJmbiIsImVscyIsImlzU2FtZVNpemVBcyIsImNhbk11bHRpcGx5RnJvbUxlZnQiLCJtdWxPcCIsIm9wIiwicmV0dXJuVmVjdG9yIiwibW9kdWx1cyIsInJvd1RoaXMiLCJyb3dFbGVtIiwic3VtIiwibyIsInkiLCJtdWx0aXBseSIsImVsZW1lbnRNdWx0aXBseSIsIm1lYW4iLCJkaW0iLCJyIiwiY29sdW1uIiwibG9nIiwibWlub3IiLCJhIiwiYiIsImMiLCJkIiwibmkiLCJpc1NxdWFyZSIsIm1heCIsImluZGV4T2YiLCJpbmRleCIsInRvUmlnaHRUcmlhbmd1bGFyIiwibnAiLCJwIiwibXVsdGlwbGllciIsInRvVXBwZXJUcmlhbmd1bGFyIiwiZGV0ZXJtaW5hbnQiLCJkZXQiLCJpc1Npbmd1bGFyIiwidHJhY2UiLCJ0ciIsInJhbmsiLCJyayIsImF1Z21lbnQiLCJUIiwiaW52ZXJzZSIsImRpdmlzb3IiLCJpbnZlcnNlX2VsZW1lbnRzIiwibmV3X2VsZW1lbnQiLCJpbnYiLCJyb3VuZCIsInNuYXBUbyIsImluc3BlY3QiLCJtYXRyaXhfcm93cyIsImpvaW4iLCJ0b0FycmF5Iiwic2V0RWxlbWVudHMiLCJtYXhDb2x1bW5JbmRleGVzIiwibWF4ZXMiLCJtYXhJbmRleCIsIm1heENvbHVtbnMiLCJtaW5Db2x1bW5JbmRleGVzIiwibWlucyIsIm1pbkluZGV4IiwibWluQ29sdW1ucyIsImxvYWRGaWxlIiwiZmlsZSIsImNvbnRlbnRzIiwicmVhZEZpbGVTeW5jIiwicm93QXJyYXkiLCJzcGxpdCIsIkRpYWdvbmFsIiwiUm90YXRpb24iLCJ0aGV0YSIsImNvcyIsInNpbiIsImF4aXMiLCJtb2QiLCJ6IiwidCIsIlJvdGF0aW9uWCIsIlJvdGF0aW9uWSIsIlJvdGF0aW9uWiIsIlJhbmRvbSIsImFyZ3VtZW50cyIsIlplcm8iLCJyYW5kb20iLCJGaWxsIiwiWmVyb3MiLCJPbmUiLCJPbmVzIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/matrix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/plane.js":
/*!************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/plane.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// Plane class - depends on Vector. Some methods require Matrix and Line.\n\nvar Vector = __webpack_require__(/*! ./vector */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js\");\nvar Matrix = __webpack_require__(/*! ./matrix */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nvar Line = __webpack_require__(/*! ./line */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/line.js\");\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\");\nfunction Plane() {}\nPlane.prototype = {\n    // Returns true iff the plane occupies the same space as the argument\n    eql: function(plane) {\n        return this.contains(plane.anchor) && this.isParallelTo(plane);\n    },\n    // Returns a copy of the plane\n    dup: function() {\n        return Plane.create(this.anchor, this.normal);\n    },\n    // Returns the result of translating the plane by the given vector\n    translate: function(vector) {\n        var V = vector.elements || vector;\n        return Plane.create([\n            this.anchor.elements[0] + V[0],\n            this.anchor.elements[1] + V[1],\n            this.anchor.elements[2] + (V[2] || 0)\n        ], this.normal);\n    },\n    // Returns true iff the plane is parallel to the argument. Will return true\n    // if the planes are equal, or if you give a line and it lies in the plane.\n    isParallelTo: function(obj) {\n        var theta;\n        if (obj.normal) {\n            // obj is a plane\n            theta = this.normal.angleFrom(obj.normal);\n            return Math.abs(theta) <= Sylvester.precision || Math.abs(Math.PI - theta) <= Sylvester.precision;\n        } else if (obj.direction) {\n            // obj is a line\n            return this.normal.isPerpendicularTo(obj.direction);\n        }\n        return null;\n    },\n    // Returns true iff the receiver is perpendicular to the argument\n    isPerpendicularTo: function(plane) {\n        var theta = this.normal.angleFrom(plane.normal);\n        return Math.abs(Math.PI / 2 - theta) <= Sylvester.precision;\n    },\n    // Returns the plane's distance from the given object (point, line or plane)\n    distanceFrom: function(obj) {\n        if (this.intersects(obj) || this.contains(obj)) {\n            return 0;\n        }\n        if (obj.anchor) {\n            // obj is a plane or line\n            var A = this.anchor.elements, B = obj.anchor.elements, N = this.normal.elements;\n            return Math.abs((A[0] - B[0]) * N[0] + (A[1] - B[1]) * N[1] + (A[2] - B[2]) * N[2]);\n        } else {\n            // obj is a point\n            var P = obj.elements || obj;\n            var A = this.anchor.elements, N = this.normal.elements;\n            return Math.abs((A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2]);\n        }\n    },\n    // Returns true iff the plane contains the given point or line\n    contains: function(obj) {\n        if (obj.normal) {\n            return null;\n        }\n        if (obj.direction) {\n            return this.contains(obj.anchor) && this.contains(obj.anchor.add(obj.direction));\n        } else {\n            var P = obj.elements || obj;\n            var A = this.anchor.elements, N = this.normal.elements;\n            var diff = Math.abs(N[0] * (A[0] - P[0]) + N[1] * (A[1] - P[1]) + N[2] * (A[2] - (P[2] || 0)));\n            return diff <= Sylvester.precision;\n        }\n    },\n    // Returns true iff the plane has a unique point/line of intersection with the argument\n    intersects: function(obj) {\n        if (typeof obj.direction == \"undefined\" && typeof obj.normal == \"undefined\") {\n            return null;\n        }\n        return !this.isParallelTo(obj);\n    },\n    // Returns the unique intersection with the argument, if one exists. The result\n    // will be a vector if a line is supplied, and a line if a plane is supplied.\n    intersectionWith: function(obj) {\n        if (!this.intersects(obj)) {\n            return null;\n        }\n        if (obj.direction) {\n            // obj is a line\n            var A = obj.anchor.elements, D = obj.direction.elements, P = this.anchor.elements, N = this.normal.elements;\n            var multiplier = (N[0] * (P[0] - A[0]) + N[1] * (P[1] - A[1]) + N[2] * (P[2] - A[2])) / (N[0] * D[0] + N[1] * D[1] + N[2] * D[2]);\n            return Vector.create([\n                A[0] + D[0] * multiplier,\n                A[1] + D[1] * multiplier,\n                A[2] + D[2] * multiplier\n            ]);\n        } else if (obj.normal) {\n            // obj is a plane\n            var direction = this.normal.cross(obj.normal).toUnitVector();\n            // To find an anchor point, we find one co-ordinate that has a value\n            // of zero somewhere on the intersection, and remember which one we picked\n            var N = this.normal.elements, A = this.anchor.elements, O = obj.normal.elements, B = obj.anchor.elements;\n            var solver = Matrix.Zero(2, 2), i = 0;\n            while(solver.isSingular()){\n                i++;\n                solver = Matrix.create([\n                    [\n                        N[i % 3],\n                        N[(i + 1) % 3]\n                    ],\n                    [\n                        O[i % 3],\n                        O[(i + 1) % 3]\n                    ]\n                ]);\n            }\n            // Then we solve the simultaneous equations in the remaining dimensions\n            var inverse = solver.inverse().elements;\n            var x = N[0] * A[0] + N[1] * A[1] + N[2] * A[2];\n            var y = O[0] * B[0] + O[1] * B[1] + O[2] * B[2];\n            var intersection = [\n                inverse[0][0] * x + inverse[0][1] * y,\n                inverse[1][0] * x + inverse[1][1] * y\n            ];\n            var anchor = [];\n            for(var j = 1; j <= 3; j++){\n                // This formula picks the right element from intersection by\n                // cycling depending on which element we set to zero above\n                anchor.push(i == j ? 0 : intersection[(j + (5 - i) % 3) % 3]);\n            }\n            return Line.create(anchor, direction);\n        }\n    },\n    // Returns the point in the plane closest to the given point\n    pointClosestTo: function(point) {\n        var P = point.elements || point;\n        var A = this.anchor.elements, N = this.normal.elements;\n        var dot = (A[0] - P[0]) * N[0] + (A[1] - P[1]) * N[1] + (A[2] - (P[2] || 0)) * N[2];\n        return Vector.create([\n            P[0] + N[0] * dot,\n            P[1] + N[1] * dot,\n            (P[2] || 0) + N[2] * dot\n        ]);\n    },\n    // Returns a copy of the plane, rotated by t radians about the given line\n    // See notes on Line#rotate.\n    rotate: function(t, line) {\n        var R = t.determinant ? t.elements : Matrix.Rotation(t, line.direction).elements;\n        var C = line.pointClosestTo(this.anchor).elements;\n        var A = this.anchor.elements, N = this.normal.elements;\n        var C1 = C[0], C2 = C[1], C3 = C[2], A1 = A[0], A2 = A[1], A3 = A[2];\n        var x = A1 - C1, y = A2 - C2, z = A3 - C3;\n        return Plane.create([\n            C1 + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n            C2 + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n            C3 + R[2][0] * x + R[2][1] * y + R[2][2] * z\n        ], [\n            R[0][0] * N[0] + R[0][1] * N[1] + R[0][2] * N[2],\n            R[1][0] * N[0] + R[1][1] * N[1] + R[1][2] * N[2],\n            R[2][0] * N[0] + R[2][1] * N[1] + R[2][2] * N[2]\n        ]);\n    },\n    // Returns the reflection of the plane in the given point, line or plane.\n    reflectionIn: function(obj) {\n        if (obj.normal) {\n            // obj is a plane\n            var A = this.anchor.elements, N = this.normal.elements;\n            var A1 = A[0], A2 = A[1], A3 = A[2], N1 = N[0], N2 = N[1], N3 = N[2];\n            var newA = this.anchor.reflectionIn(obj).elements;\n            // Add the plane's normal to its anchor, then mirror that in the other plane\n            var AN1 = A1 + N1, AN2 = A2 + N2, AN3 = A3 + N3;\n            var Q = obj.pointClosestTo([\n                AN1,\n                AN2,\n                AN3\n            ]).elements;\n            var newN = [\n                Q[0] + (Q[0] - AN1) - newA[0],\n                Q[1] + (Q[1] - AN2) - newA[1],\n                Q[2] + (Q[2] - AN3) - newA[2]\n            ];\n            return Plane.create(newA, newN);\n        } else if (obj.direction) {\n            // obj is a line\n            return this.rotate(Math.PI, obj);\n        } else {\n            // obj is a point\n            var P = obj.elements || obj;\n            return Plane.create(this.anchor.reflectionIn([\n                P[0],\n                P[1],\n                P[2] || 0\n            ]), this.normal);\n        }\n    },\n    // Sets the anchor point and normal to the plane. If three arguments are specified,\n    // the normal is calculated by assuming the three points should lie in the same plane.\n    // If only two are sepcified, the second is taken to be the normal. Normal vector is\n    // normalised before storage.\n    setVectors: function(anchor, v1, v2) {\n        anchor = Vector.create(anchor);\n        anchor = anchor.to3D();\n        if (anchor === null) {\n            return null;\n        }\n        v1 = Vector.create(v1);\n        v1 = v1.to3D();\n        if (v1 === null) {\n            return null;\n        }\n        if (typeof v2 == \"undefined\") {\n            v2 = null;\n        } else {\n            v2 = Vector.create(v2);\n            v2 = v2.to3D();\n            if (v2 === null) {\n                return null;\n            }\n        }\n        var A1 = anchor.elements[0], A2 = anchor.elements[1], A3 = anchor.elements[2];\n        var v11 = v1.elements[0], v12 = v1.elements[1], v13 = v1.elements[2];\n        var normal, mod;\n        if (v2 !== null) {\n            var v21 = v2.elements[0], v22 = v2.elements[1], v23 = v2.elements[2];\n            normal = Vector.create([\n                (v12 - A2) * (v23 - A3) - (v13 - A3) * (v22 - A2),\n                (v13 - A3) * (v21 - A1) - (v11 - A1) * (v23 - A3),\n                (v11 - A1) * (v22 - A2) - (v12 - A2) * (v21 - A1)\n            ]);\n            mod = normal.modulus();\n            if (mod === 0) {\n                return null;\n            }\n            normal = Vector.create([\n                normal.elements[0] / mod,\n                normal.elements[1] / mod,\n                normal.elements[2] / mod\n            ]);\n        } else {\n            mod = Math.sqrt(v11 * v11 + v12 * v12 + v13 * v13);\n            if (mod === 0) {\n                return null;\n            }\n            normal = Vector.create([\n                v1.elements[0] / mod,\n                v1.elements[1] / mod,\n                v1.elements[2] / mod\n            ]);\n        }\n        this.anchor = anchor;\n        this.normal = normal;\n        return this;\n    }\n};\n// Constructor function\nPlane.create = function(anchor, v1, v2) {\n    var P = new Plane();\n    return P.setVectors(anchor, v1, v2);\n};\n// X-Y-Z planes\nPlane.XY = Plane.create(Vector.Zero(3), Vector.k);\nPlane.YZ = Plane.create(Vector.Zero(3), Vector.i);\nPlane.ZX = Plane.create(Vector.Zero(3), Vector.j);\nPlane.YX = Plane.XY;\nPlane.ZY = Plane.YZ;\nPlane.XZ = Plane.ZX;\n// Returns the plane containing the given points (can be arrays as\n// well as vectors). If the points are not coplanar, returns null.\nPlane.fromPoints = function(points) {\n    var np = points.length, list = [], i, P, n, N, A, B, C, D, theta, prevN, totalN = Vector.Zero(3);\n    for(i = 0; i < np; i++){\n        P = Vector.create(points[i]).to3D();\n        if (P === null) {\n            return null;\n        }\n        list.push(P);\n        n = list.length;\n        if (n > 2) {\n            // Compute plane normal for the latest three points\n            A = list[n - 1].elements;\n            B = list[n - 2].elements;\n            C = list[n - 3].elements;\n            N = Vector.create([\n                (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n                (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n                (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n            ]).toUnitVector();\n            if (n > 3) {\n                // If the latest normal is not (anti)parallel to the previous one, we've strayed off the plane.\n                // This might be a slightly long-winded way of doing things, but we need the sum of all the normals\n                // to find which way the plane normal should point so that the points form an anticlockwise list.\n                theta = N.angleFrom(prevN);\n                if (theta !== null) {\n                    if (!(Math.abs(theta) <= Sylvester.precision || Math.abs(theta - Math.PI) <= Sylvester.precision)) {\n                        return null;\n                    }\n                }\n            }\n            totalN = totalN.add(N);\n            prevN = N;\n        }\n    }\n    // We need to add in the normals at the start and end points, which the above misses out\n    A = list[1].elements;\n    B = list[0].elements;\n    C = list[n - 1].elements;\n    D = list[n - 2].elements;\n    totalN = totalN.add(Vector.create([\n        (A[1] - B[1]) * (C[2] - B[2]) - (A[2] - B[2]) * (C[1] - B[1]),\n        (A[2] - B[2]) * (C[0] - B[0]) - (A[0] - B[0]) * (C[2] - B[2]),\n        (A[0] - B[0]) * (C[1] - B[1]) - (A[1] - B[1]) * (C[0] - B[0])\n    ]).toUnitVector()).add(Vector.create([\n        (B[1] - C[1]) * (D[2] - C[2]) - (B[2] - C[2]) * (D[1] - C[1]),\n        (B[2] - C[2]) * (D[0] - C[0]) - (B[0] - C[0]) * (D[2] - C[2]),\n        (B[0] - C[0]) * (D[1] - C[1]) - (B[1] - C[1]) * (D[0] - C[0])\n    ]).toUnitVector());\n    return Plane.create(list[0], totalN);\n};\nmodule.exports = Plane;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9wbGFuZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxnREFBZ0Q7QUFDaEQseUVBQXlFOztBQUN6RSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUNyQixJQUFJQyxTQUFTRCxtQkFBT0EsQ0FBQztBQUNyQixJQUFJRSxPQUFPRixtQkFBT0EsQ0FBQztBQUVuQixJQUFJRyxZQUFZSCxtQkFBT0EsQ0FBQztBQUV4QixTQUFTSSxTQUFTO0FBQ2xCQSxNQUFNQyxTQUFTLEdBQUc7SUFFaEIscUVBQXFFO0lBQ3JFQyxLQUFLLFNBQVNDLEtBQUs7UUFDakIsT0FBUSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0QsTUFBTUUsTUFBTSxLQUFLLElBQUksQ0FBQ0MsWUFBWSxDQUFDSDtJQUMzRDtJQUVBLDhCQUE4QjtJQUM5QkksS0FBSztRQUNILE9BQU9QLE1BQU1RLE1BQU0sQ0FBQyxJQUFJLENBQUNILE1BQU0sRUFBRSxJQUFJLENBQUNJLE1BQU07SUFDOUM7SUFFQSxrRUFBa0U7SUFDbEVDLFdBQVcsU0FBU0MsTUFBTTtRQUN4QixJQUFJQyxJQUFJRCxPQUFPRSxRQUFRLElBQUlGO1FBQzNCLE9BQU9YLE1BQU1RLE1BQU0sQ0FBQztZQUNsQixJQUFJLENBQUNILE1BQU0sQ0FBQ1EsUUFBUSxDQUFDLEVBQUUsR0FBR0QsQ0FBQyxDQUFDLEVBQUU7WUFDOUIsSUFBSSxDQUFDUCxNQUFNLENBQUNRLFFBQVEsQ0FBQyxFQUFFLEdBQUdELENBQUMsQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQ1AsTUFBTSxDQUFDUSxRQUFRLENBQUMsRUFBRSxHQUFJRCxDQUFBQSxDQUFDLENBQUMsRUFBRSxJQUFJO1NBQ3BDLEVBQUUsSUFBSSxDQUFDSCxNQUFNO0lBQ2hCO0lBRUEsMkVBQTJFO0lBQzNFLDJFQUEyRTtJQUMzRUgsY0FBYyxTQUFTUSxHQUFHO1FBQ3hCLElBQUlDO1FBQ0osSUFBSUQsSUFBSUwsTUFB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QUUsSUFBSzhCLENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUc5QixDQUFDLENBQUMsRUFBRTtRQUMzREQsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDLEVBQUUsSUFBSzhCLENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUc5QixDQUFDLENBQUMsRUFBRSxJQUFJLENBQUNELENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLElBQUs4QixDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHOUIsQ0FBQyxDQUFDLEVBQUU7UUFDM0RELENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUdDLENBQUMsQ0FBQyxFQUFFLElBQUs4QixDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHOUIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDRCxDQUFDLENBQUMsRUFBRSxHQUFHQyxDQUFDLENBQUMsRUFBRSxJQUFLOEIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBRzlCLENBQUMsQ0FBQyxFQUFFO0tBQzdELEVBQUVTLFlBQVksSUFBSU4sR0FBRyxDQUFDbEMsT0FBT2EsTUFBTSxDQUFDO1FBQ2xDa0IsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBRzhCLENBQUMsQ0FBQyxFQUFFLElBQUt4QixDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHd0IsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDOUIsQ0FBQyxDQUFDLEVBQUUsR0FBRzhCLENBQUMsQ0FBQyxFQUFFLElBQUt4QixDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHd0IsQ0FBQyxDQUFDLEVBQUU7UUFDM0Q5QixDQUFBQSxDQUFDLENBQUMsRUFBRSxHQUFHOEIsQ0FBQyxDQUFDLEVBQUUsSUFBS3hCLENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUd3QixDQUFDLENBQUMsRUFBRSxJQUFJLENBQUM5QixDQUFDLENBQUMsRUFBRSxHQUFHOEIsQ0FBQyxDQUFDLEVBQUUsSUFBS3hCLENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUd3QixDQUFDLENBQUMsRUFBRTtRQUMzRDlCLENBQUFBLENBQUMsQ0FBQyxFQUFFLEdBQUc4QixDQUFDLENBQUMsRUFBRSxJQUFLeEIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR3dCLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQzlCLENBQUMsQ0FBQyxFQUFFLEdBQUc4QixDQUFDLENBQUMsRUFBRSxJQUFLeEIsQ0FBQUEsQ0FBQyxDQUFDLEVBQUUsR0FBR3dCLENBQUMsQ0FBQyxFQUFFO0tBQzdELEVBQUVyQixZQUFZO0lBQ2YsT0FBT25DLE1BQU1RLE1BQU0sQ0FBQzBGLElBQUksQ0FBQyxFQUFFLEVBQUVHO0FBQy9CO0FBRUFDLE9BQU9DLE9BQU8sR0FBR3ZHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIvbGliL25vZGUtc3lsdmVzdGVyL3BsYW5lLmpzPzVkZDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbCwgSmFtZXMgQ29nbGFuXG4vLyBQbGFuZSBjbGFzcyAtIGRlcGVuZHMgb24gVmVjdG9yLiBTb21lIG1ldGhvZHMgcmVxdWlyZSBNYXRyaXggYW5kIExpbmUuXG52YXIgVmVjdG9yID0gcmVxdWlyZSgnLi92ZWN0b3InKTtcbnZhciBNYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xudmFyIExpbmUgPSByZXF1aXJlKCcuL2xpbmUnKTtcblxudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyk7XG5cbmZ1bmN0aW9uIFBsYW5lKCkge31cblBsYW5lLnByb3RvdHlwZSA9IHtcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBwbGFuZSBvY2N1cGllcyB0aGUgc2FtZSBzcGFjZSBhcyB0aGUgYXJndW1lbnRcbiAgZXFsOiBmdW5jdGlvbihwbGFuZSkge1xuICAgIHJldHVybiAodGhpcy5jb250YWlucyhwbGFuZS5hbmNob3IpICYmIHRoaXMuaXNQYXJhbGxlbFRvKHBsYW5lKSk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyBhIGNvcHkgb2YgdGhlIHBsYW5lXG4gIGR1cDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFBsYW5lLmNyZWF0ZSh0aGlzLmFuY2hvciwgdGhpcy5ub3JtYWwpO1xuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiB0cmFuc2xhdGluZyB0aGUgcGxhbmUgYnkgdGhlIGdpdmVuIHZlY3RvclxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICByZXR1cm4gUGxhbmUuY3JlYXRlKFtcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzBdICsgVlswXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzFdICsgVlsxXSxcbiAgICAgIHRoaXMuYW5jaG9yLmVsZW1lbnRzWzJdICsgKFZbMl0gfHwgMClcbiAgICBdLCB0aGlzLm5vcm1hbCk7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgcGxhbmUgaXMgcGFyYWxsZWwgdG8gdGhlIGFyZ3VtZW50LiBXaWxsIHJldHVybiB0cnVlXG4gIC8vIGlmIHRoZSBwbGFuZXMgYXJlIGVxdWFsLCBvciBpZiB5b3UgZ2l2ZSBhIGxpbmUgYW5kIGl0IGxpZXMgaW4gdGhlIHBsYW5lLlxuICBpc1BhcmFsbGVsVG86IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0aGV0YTtcbiAgICBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHRoZXRhID0gdGhpcy5ub3JtYWwuYW5nbGVGcm9tKG9iai5ub3JtYWwpO1xuICAgICAgcmV0dXJuIChNYXRoLmFicyh0aGV0YSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbiB8fCBNYXRoLmFicyhNYXRoLlBJIC0gdGhldGEpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICAgIH0gZWxzZSBpZiAob2JqLmRpcmVjdGlvbikge1xuICAgICAgLy8gb2JqIGlzIGEgbGluZVxuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsLmlzUGVycGVuZGljdWxhclRvKG9iai5kaXJlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSByZWNlaXZlciBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhcmd1bWVudFxuICBpc1BlcnBlbmRpY3VsYXJUbzogZnVuY3Rpb24ocGxhbmUpIHtcbiAgICB2YXIgdGhldGEgPSB0aGlzLm5vcm1hbC5hbmdsZUZyb20ocGxhbmUubm9ybWFsKTtcbiAgICByZXR1cm4gKE1hdGguYWJzKE1hdGguUEkvMiAtIHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSBwbGFuZSdzIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIG9iamVjdCAocG9pbnQsIGxpbmUgb3IgcGxhbmUpXG4gIGRpc3RhbmNlRnJvbTogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJzZWN0cyhvYmopIHx8IHRoaXMuY29udGFpbnMob2JqKSkgeyByZXR1cm4gMDsgfVxuICAgIGlmIChvYmouYW5jaG9yKSB7XG4gICAgICAvLyBvYmogaXMgYSBwbGFuZSBvciBsaW5lXG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBCID0gb2JqLmFuY2hvci5lbGVtZW50cywgTiA9IHRoaXMubm9ybWFsLmVsZW1lbnRzO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKChBWzBdIC0gQlswXSkgKiBOWzBdICsgKEFbMV0gLSBCWzFdKSAqIE5bMV0gKyAoQVsyXSAtIEJbMl0pICogTlsyXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBvaW50XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoKEFbMF0gLSBQWzBdKSAqIE5bMF0gKyAoQVsxXSAtIFBbMV0pICogTlsxXSArIChBWzJdIC0gKFBbMl0gfHwgMCkpICogTlsyXSk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHBsYW5lIGNvbnRhaW5zIHRoZSBnaXZlbiBwb2ludCBvciBsaW5lXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqLm5vcm1hbCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gKHRoaXMuY29udGFpbnMob2JqLmFuY2hvcikgJiYgdGhpcy5jb250YWlucyhvYmouYW5jaG9yLmFkZChvYmouZGlyZWN0aW9uKSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgUCA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKE5bMF0qKEFbMF0gLSBQWzBdKSArIE5bMV0qKEFbMV0gLSBQWzFdKSArIE5bMl0qKEFbMl0gLSAoUFsyXSB8fCAwKSkpO1xuICAgICAgcmV0dXJuIChkaWZmIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pO1xuICAgIH1cbiAgfSxcblxuICAvLyBSZXR1cm5zIHRydWUgaWZmIHRoZSBwbGFuZSBoYXMgYSB1bmlxdWUgcG9pbnQvbGluZSBvZiBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgYXJndW1lbnRcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKHR5cGVvZihvYmouZGlyZWN0aW9uKSA9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Yob2JqLm5vcm1hbCkgPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIG51bGw7IH1cbiAgICByZXR1cm4gIXRoaXMuaXNQYXJhbGxlbFRvKG9iaik7XG4gIH0sXG5cbiAgLy8gUmV0dXJucyB0aGUgdW5pcXVlIGludGVyc2VjdGlvbiB3aXRoIHRoZSBhcmd1bWVudCwgaWYgb25lIGV4aXN0cy4gVGhlIHJlc3VsdFxuICAvLyB3aWxsIGJlIGEgdmVjdG9yIGlmIGEgbGluZSBpcyBzdXBwbGllZCwgYW5kIGEgbGluZSBpZiBhIHBsYW5lIGlzIHN1cHBsaWVkLlxuICBpbnRlcnNlY3Rpb25XaXRoOiBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIXRoaXMuaW50ZXJzZWN0cyhvYmopKSB7IHJldHVybiBudWxsOyB9XG4gICAgaWYgKG9iai5kaXJlY3Rpb24pIHtcbiAgICAgIC8vIG9iaiBpcyBhIGxpbmVcbiAgICAgIHZhciBBID0gb2JqLmFuY2hvci5lbGVtZW50cywgRCA9IG9iai5kaXJlY3Rpb24uZWxlbWVudHMsXG4gICAgICAgICAgUCA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICB2YXIgbXVsdGlwbGllciA9IChOWzBdKihQWzBdLUFbMF0pICsgTlsxXSooUFsxXS1BWzFdKSArIE5bMl0qKFBbMl0tQVsyXSkpIC8gKE5bMF0qRFswXSArIE5bMV0qRFsxXSArIE5bMl0qRFsyXSk7XG4gICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbQVswXSArIERbMF0qbXVsdGlwbGllciwgQVsxXSArIERbMV0qbXVsdGlwbGllciwgQVsyXSArIERbMl0qbXVsdGlwbGllcl0pO1xuICAgIH0gZWxzZSBpZiAob2JqLm5vcm1hbCkge1xuICAgICAgLy8gb2JqIGlzIGEgcGxhbmVcbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLm5vcm1hbC5jcm9zcyhvYmoubm9ybWFsKS50b1VuaXRWZWN0b3IoKTtcbiAgICAgIC8vIFRvIGZpbmQgYW4gYW5jaG9yIHBvaW50LCB3ZSBmaW5kIG9uZSBjby1vcmRpbmF0ZSB0aGF0IGhhcyBhIHZhbHVlXG4gICAgICAvLyBvZiB6ZXJvIHNvbWV3aGVyZSBvbiB0aGUgaW50ZXJzZWN0aW9uLCBhbmQgcmVtZW1iZXIgd2hpY2ggb25lIHdlIHBpY2tlZFxuICAgICAgdmFyIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cywgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLFxuICAgICAgICAgIE8gPSBvYmoubm9ybWFsLmVsZW1lbnRzLCBCID0gb2JqLmFuY2hvci5lbGVtZW50cztcbiAgICAgIHZhciBzb2x2ZXIgPSBNYXRyaXguWmVybygyLDIpLCBpID0gMDtcbiAgICAgIHdoaWxlIChzb2x2ZXIuaXNTaW5ndWxhcigpKSB7XG4gICAgICAgIGkrKztcbiAgICAgICAgc29sdmVyID0gTWF0cml4LmNyZWF0ZShbXG4gICAgICAgICAgWyBOW2klM10sIE5bKGkrMSklM10gXSxcbiAgICAgICAgICBbIE9baSUzXSwgT1soaSsxKSUzXSAgXVxuICAgICAgICBdKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZW4gd2Ugc29sdmUgdGhlIHNpbXVsdGFuZW91cyBlcXVhdGlvbnMgaW4gdGhlIHJlbWFpbmluZyBkaW1lbnNpb25zXG4gICAgICB2YXIgaW52ZXJzZSA9IHNvbHZlci5pbnZlcnNlKCkuZWxlbWVudHM7XG4gICAgICB2YXIgeCA9IE5bMF0qQVswXSArIE5bMV0qQVsxXSArIE5bMl0qQVsyXTtcbiAgICAgIHZhciB5ID0gT1swXSpCWzBdICsgT1sxXSpCWzFdICsgT1syXSpCWzJdO1xuICAgICAgdmFyIGludGVyc2VjdGlvbiA9IFtcbiAgICAgICAgaW52ZXJzZVswXVswXSAqIHggKyBpbnZlcnNlWzBdWzFdICogeSxcbiAgICAgICAgaW52ZXJzZVsxXVswXSAqIHggKyBpbnZlcnNlWzFdWzFdICogeVxuICAgICAgXTtcbiAgICAgIHZhciBhbmNob3IgPSBbXTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IDM7IGorKykge1xuICAgICAgICAvLyBUaGlzIGZvcm11bGEgcGlja3MgdGhlIHJpZ2h0IGVsZW1lbnQgZnJvbSBpbnRlcnNlY3Rpb24gYnlcbiAgICAgICAgLy8gY3ljbGluZyBkZXBlbmRpbmcgb24gd2hpY2ggZWxlbWVudCB3ZSBzZXQgdG8gemVybyBhYm92ZVxuICAgICAgICBhbmNob3IucHVzaCgoaSA9PSBqKSA/IDAgOiBpbnRlcnNlY3Rpb25bKGogKyAoNSAtIGkpJTMpJTNdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBMaW5lLmNyZWF0ZShhbmNob3IsIGRpcmVjdGlvbik7XG4gICAgfVxuICB9LFxuXG4gIC8vIFJldHVybnMgdGhlIHBvaW50IGluIHRoZSBwbGFuZSBjbG9zZXN0IHRvIHRoZSBnaXZlbiBwb2ludFxuICBwb2ludENsb3Nlc3RUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgUCA9IHBvaW50LmVsZW1lbnRzIHx8IHBvaW50O1xuICAgIHZhciBBID0gdGhpcy5hbmNob3IuZWxlbWVudHMsIE4gPSB0aGlzLm5vcm1hbC5lbGVtZW50cztcbiAgICB2YXIgZG90ID0gKEFbMF0gLSBQWzBdKSAqIE5bMF0gKyAoQVsxXSAtIFBbMV0pICogTlsxXSArIChBWzJdIC0gKFBbMl0gfHwgMCkpICogTlsyXTtcbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbUFswXSArIE5bMF0gKiBkb3QsIFBbMV0gKyBOWzFdICogZG90LCAoUFsyXSB8fCAwKSArIE5bMl0gKiBkb3RdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgcGxhbmUsIHJvdGF0ZWQgYnkgdCByYWRpYW5zIGFib3V0IHRoZSBnaXZlbiBsaW5lXG4gIC8vIFNlZSBub3RlcyBvbiBMaW5lI3JvdGF0ZS5cbiAgcm90YXRlOiBmdW5jdGlvbih0LCBsaW5lKSB7XG4gICAgdmFyIFIgPSB0LmRldGVybWluYW50ID8gdC5lbGVtZW50cyA6IE1hdHJpeC5Sb3RhdGlvbih0LCBsaW5lLmRpcmVjdGlvbikuZWxlbWVudHM7XG4gICAgdmFyIEMgPSBsaW5lLnBvaW50Q2xvc2VzdFRvKHRoaXMuYW5jaG9yKS5lbGVtZW50cztcbiAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgdmFyIEMxID0gQ1swXSwgQzIgPSBDWzFdLCBDMyA9IENbMl0sIEExID0gQVswXSwgQTIgPSBBWzFdLCBBMyA9IEFbMl07XG4gICAgdmFyIHggPSBBMSAtIEMxLCB5ID0gQTIgLSBDMiwgeiA9IEEzIC0gQzM7XG4gICAgcmV0dXJuIFBsYW5lLmNyZWF0ZShbXG4gICAgICBDMSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcbiAgICAgIEMyICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuICAgICAgQzMgKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICBdLCBbXG4gICAgICBSWzBdWzBdICogTlswXSArIFJbMF1bMV0gKiBOWzFdICsgUlswXVsyXSAqIE5bMl0sXG4gICAgICBSWzFdWzBdICogTlswXSArIFJbMV1bMV0gKiBOWzFdICsgUlsxXVsyXSAqIE5bMl0sXG4gICAgICBSWzJdWzBdICogTlswXSArIFJbMl1bMV0gKiBOWzFdICsgUlsyXVsyXSAqIE5bMl1cbiAgICBdKTtcbiAgfSxcblxuICAvLyBSZXR1cm5zIHRoZSByZWZsZWN0aW9uIG9mIHRoZSBwbGFuZSBpbiB0aGUgZ2l2ZW4gcG9pbnQsIGxpbmUgb3IgcGxhbmUuXG4gIHJlZmxlY3Rpb25JbjogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5ub3JtYWwpIHtcbiAgICAgIC8vIG9iaiBpcyBhIHBsYW5lXG4gICAgICB2YXIgQSA9IHRoaXMuYW5jaG9yLmVsZW1lbnRzLCBOID0gdGhpcy5ub3JtYWwuZWxlbWVudHM7XG4gICAgICB2YXIgQTEgPSBBWzBdLCBBMiA9IEFbMV0sIEEzID0gQVsyXSwgTjEgPSBOWzBdLCBOMiA9IE5bMV0sIE4zID0gTlsyXTtcbiAgICAgIHZhciBuZXdBID0gdGhpcy5hbmNob3IucmVmbGVjdGlvbkluKG9iaikuZWxlbWVudHM7XG4gICAgICAvLyBBZGQgdGhlIHBsYW5lJ3Mgbm9ybWFsIHRvIGl0cyBhbmNob3IsIHRoZW4gbWlycm9yIHRoYXQgaW4gdGhlIG90aGVyIHBsYW5lXG4gICAgICB2YXIgQU4xID0gQTEgKyBOMSwgQU4yID0gQTIgKyBOMiwgQU4zID0gQTMgKyBOMztcbiAgICAgIHZhciBRID0gb2JqLnBvaW50Q2xvc2VzdFRvKFtBTjEsIEFOMiwgQU4zXSkuZWxlbWVudHM7XG4gICAgICB2YXIgbmV3TiA9IFtRWzBdICsgKFFbMF0gLSBBTjEpIC0gbmV3QVswXSwgUVsxXSArIChRWzFdIC0gQU4yKSAtIG5ld0FbMV0sIFFbMl0gKyAoUVsyXSAtIEFOMykgLSBuZXdBWzJdXTtcbiAgICAgIHJldHVybiBQbGFuZS5jcmVhdGUobmV3QSwgbmV3Tik7XG4gICAgfSBlbHNlIGlmIChvYmouZGlyZWN0aW9uKSB7XG4gICAgICAvLyBvYmogaXMgYSBsaW5lXG4gICAgICByZXR1cm4gdGhpcy5yb3RhdGUoTWF0aC5QSSwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2JqIGlzIGEgcG9pbnRcbiAgICAgIHZhciBQID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcbiAgICAgIHJldHVybiBQbGFuZS5jcmVhdGUodGhpcy5hbmNob3IucmVmbGVjdGlvbkluKFtQWzBdLCBQWzFdLCAoUFsyXSB8fCAwKV0pLCB0aGlzLm5vcm1hbCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIFNldHMgdGhlIGFuY2hvciBwb2ludCBhbmQgbm9ybWFsIHRvIHRoZSBwbGFuZS4gSWYgdGhyZWUgYXJndW1lbnRzIGFyZSBzcGVjaWZpZWQsXG4gIC8vIHRoZSBub3JtYWwgaXMgY2FsY3VsYXRlZCBieSBhc3N1bWluZyB0aGUgdGhyZWUgcG9pbnRzIHNob3VsZCBsaWUgaW4gdGhlIHNhbWUgcGxhbmUuXG4gIC8vIElmIG9ubHkgdHdvIGFyZSBzZXBjaWZpZWQsIHRoZSBzZWNvbmQgaXMgdGFrZW4gdG8gYmUgdGhlIG5vcm1hbC4gTm9ybWFsIHZlY3RvciBpc1xuICAvLyBub3JtYWxpc2VkIGJlZm9yZSBzdG9yYWdlLlxuICBzZXRWZWN0b3JzOiBmdW5jdGlvbihhbmNob3IsIHYxLCB2Mikge1xuICAgIGFuY2hvciA9IFZlY3Rvci5jcmVhdGUoYW5jaG9yKTtcbiAgICBhbmNob3IgPSBhbmNob3IudG8zRCgpOyBpZiAoYW5jaG9yID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgdjEgPSBWZWN0b3IuY3JlYXRlKHYxKTtcbiAgICB2MSA9IHYxLnRvM0QoKTsgaWYgKHYxID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgaWYgKHR5cGVvZih2MikgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHYyID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdjIgPSBWZWN0b3IuY3JlYXRlKHYyKTtcbiAgICAgIHYyID0gdjIudG8zRCgpOyBpZiAodjIgPT09IG51bGwpIHsgcmV0dXJuIG51bGw7IH1cbiAgICB9XG4gICAgdmFyIEExID0gYW5jaG9yLmVsZW1lbnRzWzBdLCBBMiA9IGFuY2hvci5lbGVtZW50c1sxXSwgQTMgPSBhbmNob3IuZWxlbWVudHNbMl07XG4gICAgdmFyIHYxMSA9IHYxLmVsZW1lbnRzWzBdLCB2MTIgPSB2MS5lbGVtZW50c1sxXSwgdjEzID0gdjEuZWxlbWVudHNbMl07XG4gICAgdmFyIG5vcm1hbCwgbW9kO1xuICAgIGlmICh2MiAhPT0gbnVsbCkge1xuICAgICAgdmFyIHYyMSA9IHYyLmVsZW1lbnRzWzBdLCB2MjIgPSB2Mi5lbGVtZW50c1sxXSwgdjIzID0gdjIuZWxlbWVudHNbMl07XG4gICAgICBub3JtYWwgPSBWZWN0b3IuY3JlYXRlKFtcbiAgICAgICAgKHYxMiAtIEEyKSAqICh2MjMgLSBBMykgLSAodjEzIC0gQTMpICogKHYyMiAtIEEyKSxcbiAgICAgICAgKHYxMyAtIEEzKSAqICh2MjEgLSBBMSkgLSAodjExIC0gQTEpICogKHYyMyAtIEEzKSxcbiAgICAgICAgKHYxMSAtIEExKSAqICh2MjIgLSBBMikgLSAodjEyIC0gQTIpICogKHYyMSAtIEExKVxuICAgICAgXSk7XG4gICAgICBtb2QgPSBub3JtYWwubW9kdWx1cygpO1xuICAgICAgaWYgKG1vZCA9PT0gMCkgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgbm9ybWFsID0gVmVjdG9yLmNyZWF0ZShbbm9ybWFsLmVsZW1lbnRzWzBdIC8gbW9kLCBub3JtYWwuZWxlbWVudHNbMV0gLyBtb2QsIG5vcm1hbC5lbGVtZW50c1syXSAvIG1vZF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2QgPSBNYXRoLnNxcnQodjExKnYxMSArIHYxMip2MTIgKyB2MTMqdjEzKTtcbiAgICAgIGlmIChtb2QgPT09IDApIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgIG5vcm1hbCA9IFZlY3Rvci5jcmVhdGUoW3YxLmVsZW1lbnRzWzBdIC8gbW9kLCB2MS5lbGVtZW50c1sxXSAvIG1vZCwgdjEuZWxlbWVudHNbMl0gLyBtb2RdKTtcbiAgICB9XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5ub3JtYWwgPSBub3JtYWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5QbGFuZS5jcmVhdGUgPSBmdW5jdGlvbihhbmNob3IsIHYxLCB2Mikge1xuICB2YXIgUCA9IG5ldyBQbGFuZSgpO1xuICByZXR1cm4gUC5zZXRWZWN0b3JzKGFuY2hvciwgdjEsIHYyKTtcbn07XG5cbi8vIFgtWS1aIHBsYW5lc1xuUGxhbmUuWFkgPSBQbGFuZS5jcmVhdGUoVmVjdG9yLlplcm8oMyksIFZlY3Rvci5rKTtcblBsYW5lLllaID0gUGxhbmUuY3JlYXRlKFZlY3Rvci5aZXJvKDMpLCBWZWN0b3IuaSk7XG5QbGFuZS5aWCA9IFBsYW5lLmNyZWF0ZShWZWN0b3IuWmVybygzKSwgVmVjdG9yLmopO1xuUGxhbmUuWVggPSBQbGFuZS5YWTsgUGxhbmUuWlkgPSBQbGFuZS5ZWjsgUGxhbmUuWFogPSBQbGFuZS5aWDtcblxuLy8gUmV0dXJucyB0aGUgcGxhbmUgY29udGFpbmluZyB0aGUgZ2l2ZW4gcG9pbnRzIChjYW4gYmUgYXJyYXlzIGFzXG4vLyB3ZWxsIGFzIHZlY3RvcnMpLiBJZiB0aGUgcG9pbnRzIGFyZSBub3QgY29wbGFuYXIsIHJldHVybnMgbnVsbC5cblBsYW5lLmZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgdmFyIG5wID0gcG9pbnRzLmxlbmd0aCwgbGlzdCA9IFtdLCBpLCBQLCBuLCBOLCBBLCBCLCBDLCBELCB0aGV0YSwgcHJldk4sIHRvdGFsTiA9IFZlY3Rvci5aZXJvKDMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbnA7IGkrKykge1xuICAgIFAgPSBWZWN0b3IuY3JlYXRlKHBvaW50c1tpXSkudG8zRCgpO1xuICAgIGlmIChQID09PSBudWxsKSB7IHJldHVybiBudWxsOyB9XG4gICAgbGlzdC5wdXNoKFApO1xuICAgIG4gPSBsaXN0Lmxlbmd0aDtcbiAgICBpZiAobiA+IDIpIHtcbiAgICAgIC8vIENvbXB1dGUgcGxhbmUgbm9ybWFsIGZvciB0aGUgbGF0ZXN0IHRocmVlIHBvaW50c1xuICAgICAgQSA9IGxpc3Rbbi0xXS5lbGVtZW50czsgQiA9IGxpc3Rbbi0yXS5lbGVtZW50czsgQyA9IGxpc3Rbbi0zXS5lbGVtZW50cztcbiAgICAgIE4gPSBWZWN0b3IuY3JlYXRlKFtcbiAgICAgICAgKEFbMV0gLSBCWzFdKSAqIChDWzJdIC0gQlsyXSkgLSAoQVsyXSAtIEJbMl0pICogKENbMV0gLSBCWzFdKSxcbiAgICAgICAgKEFbMl0gLSBCWzJdKSAqIChDWzBdIC0gQlswXSkgLSAoQVswXSAtIEJbMF0pICogKENbMl0gLSBCWzJdKSxcbiAgICAgICAgKEFbMF0gLSBCWzBdKSAqIChDWzFdIC0gQlsxXSkgLSAoQVsxXSAtIEJbMV0pICogKENbMF0gLSBCWzBdKVxuICAgICAgXSkudG9Vbml0VmVjdG9yKCk7XG4gICAgICBpZiAobiA+IDMpIHtcbiAgICAgICAgLy8gSWYgdGhlIGxhdGVzdCBub3JtYWwgaXMgbm90IChhbnRpKXBhcmFsbGVsIHRvIHRoZSBwcmV2aW91cyBvbmUsIHdlJ3ZlIHN0cmF5ZWQgb2ZmIHRoZSBwbGFuZS5cbiAgICAgICAgLy8gVGhpcyBtaWdodCBiZSBhIHNsaWdodGx5IGxvbmctd2luZGVkIHdheSBvZiBkb2luZyB0aGluZ3MsIGJ1dCB3ZSBuZWVkIHRoZSBzdW0gb2YgYWxsIHRoZSBub3JtYWxzXG4gICAgICAgIC8vIHRvIGZpbmQgd2hpY2ggd2F5IHRoZSBwbGFuZSBub3JtYWwgc2hvdWxkIHBvaW50IHNvIHRoYXQgdGhlIHBvaW50cyBmb3JtIGFuIGFudGljbG9ja3dpc2UgbGlzdC5cbiAgICAgICAgdGhldGEgPSBOLmFuZ2xlRnJvbShwcmV2Tik7XG4gICAgICAgIGlmICh0aGV0YSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICghKE1hdGguYWJzKHRoZXRhKSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uIHx8IE1hdGguYWJzKHRoZXRhIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbikpIHsgcmV0dXJuIG51bGw7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdG90YWxOID0gdG90YWxOLmFkZChOKTtcbiAgICAgIHByZXZOID0gTjtcbiAgICB9XG4gIH1cbiAgLy8gV2UgbmVlZCB0byBhZGQgaW4gdGhlIG5vcm1hbHMgYXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLCB3aGljaCB0aGUgYWJvdmUgbWlzc2VzIG91dFxuICBBID0gbGlzdFsxXS5lbGVtZW50czsgQiA9IGxpc3RbMF0uZWxlbWVudHM7IEMgPSBsaXN0W24tMV0uZWxlbWVudHM7IEQgPSBsaXN0W24tMl0uZWxlbWVudHM7XG4gIHRvdGFsTiA9IHRvdGFsTi5hZGQoVmVjdG9yLmNyZWF0ZShbXG4gICAgKEFbMV0gLSBCWzFdKSAqIChDWzJdIC0gQlsyXSkgLSAoQVsyXSAtIEJbMl0pICogKENbMV0gLSBCWzFdKSxcbiAgICAoQVsyXSAtIEJbMl0pICogKENbMF0gLSBCWzBdKSAtIChBWzBdIC0gQlswXSkgKiAoQ1syXSAtIEJbMl0pLFxuICAgIChBWzBdIC0gQlswXSkgKiAoQ1sxXSAtIEJbMV0pIC0gKEFbMV0gLSBCWzFdKSAqIChDWzBdIC0gQlswXSlcbiAgXSkudG9Vbml0VmVjdG9yKCkpLmFkZChWZWN0b3IuY3JlYXRlKFtcbiAgICAoQlsxXSAtIENbMV0pICogKERbMl0gLSBDWzJdKSAtIChCWzJdIC0gQ1syXSkgKiAoRFsxXSAtIENbMV0pLFxuICAgIChCWzJdIC0gQ1syXSkgKiAoRFswXSAtIENbMF0pIC0gKEJbMF0gLSBDWzBdKSAqIChEWzJdIC0gQ1syXSksXG4gICAgKEJbMF0gLSBDWzBdKSAqIChEWzFdIC0gQ1sxXSkgLSAoQlsxXSAtIENbMV0pICogKERbMF0gLSBDWzBdKVxuICBdKS50b1VuaXRWZWN0b3IoKSk7XG4gIHJldHVybiBQbGFuZS5jcmVhdGUobGlzdFswXSwgdG90YWxOKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGxhbmU7XG4iXSwibmFtZXMiOlsiVmVjdG9yIiwicmVxdWlyZSIsIk1hdHJpeCIsIkxpbmUiLCJTeWx2ZXN0ZXIiLCJQbGFuZSIsInByb3RvdHlwZSIsImVxbCIsInBsYW5lIiwiY29udGFpbnMiLCJhbmNob3IiLCJpc1BhcmFsbGVsVG8iLCJkdXAiLCJjcmVhdGUiLCJub3JtYWwiLCJ0cmFuc2xhdGUiLCJ2ZWN0b3IiLCJWIiwiZWxlbWVudHMiLCJvYmoiLCJ0aGV0YSIsImFuZ2xlRnJvbSIsIk1hdGgiLCJhYnMiLCJwcmVjaXNpb24iLCJQSSIsImRpcmVjdGlvbiIsImlzUGVycGVuZGljdWxhclRvIiwiZGlzdGFuY2VGcm9tIiwiaW50ZXJzZWN0cyIsIkEiLCJCIiwiTiIsIlAiLCJhZGQiLCJkaWZmIiwiaW50ZXJzZWN0aW9uV2l0aCIsIkQiLCJtdWx0aXBsaWVyIiwiY3Jvc3MiLCJ0b1VuaXRWZWN0b3IiLCJPIiwic29sdmVyIiwiWmVybyIsImkiLCJpc1Npbmd1bGFyIiwiaW52ZXJzZSIsIngiLCJ5IiwiaW50ZXJzZWN0aW9uIiwiaiIsInB1c2giLCJwb2ludENsb3Nlc3RUbyIsInBvaW50IiwiZG90Iiwicm90YXRlIiwidCIsImxpbmUiLCJSIiwiZGV0ZXJtaW5hbnQiLCJSb3RhdGlvbiIsIkMiLCJDMSIsIkMyIiwiQzMiLCJBMSIsIkEyIiwiQTMiLCJ6IiwicmVmbGVjdGlvbkluIiwiTjEiLCJOMiIsIk4zIiwibmV3QSIsIkFOMSIsIkFOMiIsIkFOMyIsIlEiLCJuZXdOIiwic2V0VmVjdG9ycyIsInYxIiwidjIiLCJ0bzNEIiwidjExIiwidjEyIiwidjEzIiwibW9kIiwidjIxIiwidjIyIiwidjIzIiwibW9kdWx1cyIsInNxcnQiLCJYWSIsImsiLCJZWiIsIlpYIiwiWVgiLCJaWSIsIlhaIiwiZnJvbVBvaW50cyIsInBvaW50cyIsIm5wIiwibGVuZ3RoIiwibGlzdCIsIm4iLCJwcmV2TiIsInRvdGFsTiIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/plane.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js":
/*!****************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/sylvester.js ***!
  \****************************************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// This file is required in order for any other classes to work. Some Vector methods work with the\n// other Sylvester classes and are useless unless they are included. Other classes such as Line and\n// Plane will not function at all without Vector being loaded first.           \n\nMath.sign = function(x) {\n    return x < 0 ? -1 : 1;\n};\nvar Sylvester = {\n    precision: 1e-6\n};\nmodule.exports = Sylvester;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci9zeWx2ZXN0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0RBQWdEO0FBQ2hELGtHQUFrRztBQUNsRyxtR0FBbUc7QUFDbkcsK0VBQStFOztBQUUvRUEsS0FBS0MsSUFBSSxHQUFHLFNBQVNDLENBQUM7SUFDbEIsT0FBT0EsSUFBSSxJQUFJLENBQUMsSUFBRztBQUN2QjtBQUVBLElBQUlDLFlBQVk7SUFDWkMsV0FBVztBQUNmO0FBRUFDLE9BQU9DLE9BQU8sR0FBR0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9saW9uZXotbmV4dGpzLy4vbm9kZV9tb2R1bGVzL3N5bHZlc3Rlci9saWIvbm9kZS1zeWx2ZXN0ZXIvc3lsdmVzdGVyLmpzPzIzOTMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IChjKSAyMDExLCBDaHJpcyBVbWJlbCwgSmFtZXMgQ29nbGFuXG4vLyBUaGlzIGZpbGUgaXMgcmVxdWlyZWQgaW4gb3JkZXIgZm9yIGFueSBvdGhlciBjbGFzc2VzIHRvIHdvcmsuIFNvbWUgVmVjdG9yIG1ldGhvZHMgd29yayB3aXRoIHRoZVxuLy8gb3RoZXIgU3lsdmVzdGVyIGNsYXNzZXMgYW5kIGFyZSB1c2VsZXNzIHVubGVzcyB0aGV5IGFyZSBpbmNsdWRlZC4gT3RoZXIgY2xhc3NlcyBzdWNoIGFzIExpbmUgYW5kXG4vLyBQbGFuZSB3aWxsIG5vdCBmdW5jdGlvbiBhdCBhbGwgd2l0aG91dCBWZWN0b3IgYmVpbmcgbG9hZGVkIGZpcnN0LiAgICAgICAgICAgXG5cbk1hdGguc2lnbiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geCA8IDAgPyAtMTogMTtcbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbnZhciBTeWx2ZXN0ZXIgPSB7XG4gICAgcHJlY2lzaW9uOiAxZS02XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bHZlc3RlcjtcbiJdLCJuYW1lcyI6WyJNYXRoIiwic2lnbiIsIngiLCJTeWx2ZXN0ZXIiLCJwcmVjaXNpb24iLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js":
/*!*************************************************************!*\
  !*** ./node_modules/sylvester/lib/node-sylvester/vector.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Copyright (c) 2011, Chris Umbel, James Coglan\n// This file is required in order for any other classes to work. Some Vector methods work with the\n// other Sylvester classes and are useless unless they are included. Other classes such as Line and\n// Plane will not function at all without Vector being loaded first.\n\nvar Sylvester = __webpack_require__(/*! ./sylvester */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/sylvester.js\"), Matrix = __webpack_require__(/*! ./matrix */ \"(ssr)/./node_modules/sylvester/lib/node-sylvester/matrix.js\");\nfunction Vector() {}\nVector.prototype = {\n    norm: function() {\n        var n = this.elements.length;\n        var sum = 0;\n        while(n--){\n            sum += Math.pow(this.elements[n], 2);\n        }\n        return Math.sqrt(sum);\n    },\n    // Returns element i of the vector\n    e: function(i) {\n        return i < 1 || i > this.elements.length ? null : this.elements[i - 1];\n    },\n    // Returns the number of rows/columns the vector has\n    dimensions: function() {\n        return {\n            rows: 1,\n            cols: this.elements.length\n        };\n    },\n    // Returns the number of rows in the vector\n    rows: function() {\n        return 1;\n    },\n    // Returns the number of columns in the vector\n    cols: function() {\n        return this.elements.length;\n    },\n    // Returns the modulus ('length') of the vector\n    modulus: function() {\n        return Math.sqrt(this.dot(this));\n    },\n    // Returns true iff the vector is equal to the argument\n    eql: function(vector) {\n        var n = this.elements.length;\n        var V = vector.elements || vector;\n        if (n != V.length) {\n            return false;\n        }\n        while(n--){\n            if (Math.abs(this.elements[n] - V[n]) > Sylvester.precision) {\n                return false;\n            }\n        }\n        return true;\n    },\n    // Returns a copy of the vector\n    dup: function() {\n        return Vector.create(this.elements);\n    },\n    // Maps the vector to another vector according to the given function\n    map: function(fn) {\n        var elements = [];\n        this.each(function(x, i) {\n            elements.push(fn(x, i));\n        });\n        return Vector.create(elements);\n    },\n    // Calls the iterator for each element of the vector in turn\n    each: function(fn) {\n        var n = this.elements.length;\n        for(var i = 0; i < n; i++){\n            fn(this.elements[i], i + 1);\n        }\n    },\n    // Returns a new vector created by normalizing the receiver\n    toUnitVector: function() {\n        var r = this.modulus();\n        if (r === 0) {\n            return this.dup();\n        }\n        return this.map(function(x) {\n            return x / r;\n        });\n    },\n    // Returns the angle between the vector and the argument (also a vector)\n    angleFrom: function(vector) {\n        var V = vector.elements || vector;\n        var n = this.elements.length, k = n, i;\n        if (n != V.length) {\n            return null;\n        }\n        var dot = 0, mod1 = 0, mod2 = 0;\n        // Work things out in parallel to save time\n        this.each(function(x, i) {\n            dot += x * V[i - 1];\n            mod1 += x * x;\n            mod2 += V[i - 1] * V[i - 1];\n        });\n        mod1 = Math.sqrt(mod1);\n        mod2 = Math.sqrt(mod2);\n        if (mod1 * mod2 === 0) {\n            return null;\n        }\n        var theta = dot / (mod1 * mod2);\n        if (theta < -1) {\n            theta = -1;\n        }\n        if (theta > 1) {\n            theta = 1;\n        }\n        return Math.acos(theta);\n    },\n    // Returns true iff the vector is parallel to the argument\n    isParallelTo: function(vector) {\n        var angle = this.angleFrom(vector);\n        return angle === null ? null : angle <= Sylvester.precision;\n    },\n    // Returns true iff the vector is antiparallel to the argument\n    isAntiparallelTo: function(vector) {\n        var angle = this.angleFrom(vector);\n        return angle === null ? null : Math.abs(angle - Math.PI) <= Sylvester.precision;\n    },\n    // Returns true iff the vector is perpendicular to the argument\n    isPerpendicularTo: function(vector) {\n        var dot = this.dot(vector);\n        return dot === null ? null : Math.abs(dot) <= Sylvester.precision;\n    },\n    // Returns the result of adding the argument to the vector\n    add: function(value) {\n        var V = value.elements || value;\n        if (this.elements.length != V.length) return this.map(function(v) {\n            return v + value;\n        });\n        else return this.map(function(x, i) {\n            return x + V[i - 1];\n        });\n    },\n    // Returns the result of subtracting the argument from the vector\n    subtract: function(v) {\n        if (typeof v == \"number\") return this.map(function(k) {\n            return k - v;\n        });\n        var V = v.elements || v;\n        if (this.elements.length != V.length) {\n            return null;\n        }\n        return this.map(function(x, i) {\n            return x - V[i - 1];\n        });\n    },\n    // Returns the result of multiplying the elements of the vector by the argument\n    multiply: function(k) {\n        return this.map(function(x) {\n            return x * k;\n        });\n    },\n    elementMultiply: function(v) {\n        return this.map(function(k, i) {\n            return v.e(i) * k;\n        });\n    },\n    sum: function() {\n        var sum = 0;\n        this.map(function(x) {\n            sum += x;\n        });\n        return sum;\n    },\n    chomp: function(n) {\n        var elements = [];\n        for(var i = n; i < this.elements.length; i++){\n            elements.push(this.elements[i]);\n        }\n        return Vector.create(elements);\n    },\n    top: function(n) {\n        var elements = [];\n        for(var i = 0; i < n; i++){\n            elements.push(this.elements[i]);\n        }\n        return Vector.create(elements);\n    },\n    augment: function(elements) {\n        var newElements = this.elements;\n        for(var i = 0; i < elements.length; i++){\n            newElements.push(elements[i]);\n        }\n        return Vector.create(newElements);\n    },\n    x: function(k) {\n        return this.multiply(k);\n    },\n    log: function() {\n        return Vector.log(this);\n    },\n    elementDivide: function(vector) {\n        return this.map(function(v, i) {\n            return v / vector.e(i);\n        });\n    },\n    product: function() {\n        var p = 1;\n        this.map(function(v) {\n            p *= v;\n        });\n        return p;\n    },\n    // Returns the scalar product of the vector with the argument\n    // Both vectors must have equal dimensionality\n    dot: function(vector) {\n        var V = vector.elements || vector;\n        var i, product = 0, n = this.elements.length;\n        if (n != V.length) {\n            return null;\n        }\n        while(n--){\n            product += this.elements[n] * V[n];\n        }\n        return product;\n    },\n    // Returns the vector product of the vector with the argument\n    // Both vectors must have dimensionality 3\n    cross: function(vector) {\n        var B = vector.elements || vector;\n        if (this.elements.length != 3 || B.length != 3) {\n            return null;\n        }\n        var A = this.elements;\n        return Vector.create([\n            A[1] * B[2] - A[2] * B[1],\n            A[2] * B[0] - A[0] * B[2],\n            A[0] * B[1] - A[1] * B[0]\n        ]);\n    },\n    // Returns the (absolute) largest element of the vector\n    max: function() {\n        var m = 0, i = this.elements.length;\n        while(i--){\n            if (Math.abs(this.elements[i]) > Math.abs(m)) {\n                m = this.elements[i];\n            }\n        }\n        return m;\n    },\n    maxIndex: function() {\n        var m = 0, i = this.elements.length;\n        var maxIndex = -1;\n        while(i--){\n            if (Math.abs(this.elements[i]) > Math.abs(m)) {\n                m = this.elements[i];\n                maxIndex = i + 1;\n            }\n        }\n        return maxIndex;\n    },\n    // Returns the index of the first match found\n    indexOf: function(x) {\n        var index = null, n = this.elements.length;\n        for(var i = 0; i < n; i++){\n            if (index === null && this.elements[i] == x) {\n                index = i + 1;\n            }\n        }\n        return index;\n    },\n    // Returns a diagonal matrix with the vector's elements as its diagonal elements\n    toDiagonalMatrix: function() {\n        return Matrix.Diagonal(this.elements);\n    },\n    // Returns the result of rounding the elements of the vector\n    round: function() {\n        return this.map(function(x) {\n            return Math.round(x);\n        });\n    },\n    // Transpose a Vector, return a 1xn Matrix\n    transpose: function() {\n        var rows = this.elements.length;\n        var elements = [];\n        for(var i = 0; i < rows; i++){\n            elements.push([\n                this.elements[i]\n            ]);\n        }\n        return Matrix.create(elements);\n    },\n    // Returns a copy of the vector with elements set to the given value if they\n    // differ from it by less than Sylvester.precision\n    snapTo: function(x) {\n        return this.map(function(y) {\n            return Math.abs(y - x) <= Sylvester.precision ? x : y;\n        });\n    },\n    // Returns the vector's distance from the argument, when considered as a point in space\n    distanceFrom: function(obj) {\n        if (obj.anchor || obj.start && obj.end) {\n            return obj.distanceFrom(this);\n        }\n        var V = obj.elements || obj;\n        if (V.length != this.elements.length) {\n            return null;\n        }\n        var sum = 0, part;\n        this.each(function(x, i) {\n            part = x - V[i - 1];\n            sum += part * part;\n        });\n        return Math.sqrt(sum);\n    },\n    // Returns true if the vector is point on the given line\n    liesOn: function(line) {\n        return line.contains(this);\n    },\n    // Return true iff the vector is a point in the given plane\n    liesIn: function(plane) {\n        return plane.contains(this);\n    },\n    // Rotates the vector about the given object. The object should be a\n    // point if the vector is 2D, and a line if it is 3D. Be careful with line directions!\n    rotate: function(t, obj) {\n        var V, R = null, x, y, z;\n        if (t.determinant) {\n            R = t.elements;\n        }\n        switch(this.elements.length){\n            case 2:\n                V = obj.elements || obj;\n                if (V.length != 2) {\n                    return null;\n                }\n                if (!R) {\n                    R = Matrix.Rotation(t).elements;\n                }\n                x = this.elements[0] - V[0];\n                y = this.elements[1] - V[1];\n                return Vector.create([\n                    V[0] + R[0][0] * x + R[0][1] * y,\n                    V[1] + R[1][0] * x + R[1][1] * y\n                ]);\n                break;\n            case 3:\n                if (!obj.direction) {\n                    return null;\n                }\n                var C = obj.pointClosestTo(this).elements;\n                if (!R) {\n                    R = Matrix.Rotation(t, obj.direction).elements;\n                }\n                x = this.elements[0] - C[0];\n                y = this.elements[1] - C[1];\n                z = this.elements[2] - C[2];\n                return Vector.create([\n                    C[0] + R[0][0] * x + R[0][1] * y + R[0][2] * z,\n                    C[1] + R[1][0] * x + R[1][1] * y + R[1][2] * z,\n                    C[2] + R[2][0] * x + R[2][1] * y + R[2][2] * z\n                ]);\n                break;\n            default:\n                return null;\n        }\n    },\n    // Returns the result of reflecting the point in the given point, line or plane\n    reflectionIn: function(obj) {\n        if (obj.anchor) {\n            // obj is a plane or line\n            var P = this.elements.slice();\n            var C = obj.pointClosestTo(P).elements;\n            return Vector.create([\n                C[0] + (C[0] - P[0]),\n                C[1] + (C[1] - P[1]),\n                C[2] + (C[2] - (P[2] || 0))\n            ]);\n        } else {\n            // obj is a point\n            var Q = obj.elements || obj;\n            if (this.elements.length != Q.length) {\n                return null;\n            }\n            return this.map(function(x, i) {\n                return Q[i - 1] + (Q[i - 1] - x);\n            });\n        }\n    },\n    // Utility to make sure vectors are 3D. If they are 2D, a zero z-component is added\n    to3D: function() {\n        var V = this.dup();\n        switch(V.elements.length){\n            case 3:\n                break;\n            case 2:\n                V.elements.push(0);\n                break;\n            default:\n                return null;\n        }\n        return V;\n    },\n    // Returns a string representation of the vector\n    inspect: function() {\n        return \"[\" + this.elements.join(\", \") + \"]\";\n    },\n    // Set vector's elements from an array\n    setElements: function(els) {\n        this.elements = (els.elements || els).slice();\n        return this;\n    }\n};\n// Constructor function\nVector.create = function(elements) {\n    var V = new Vector();\n    return V.setElements(elements);\n};\n// i, j, k unit vectors\nVector.i = Vector.create([\n    1,\n    0,\n    0\n]);\nVector.j = Vector.create([\n    0,\n    1,\n    0\n]);\nVector.k = Vector.create([\n    0,\n    0,\n    1\n]);\n// Random vector of size n\nVector.Random = function(n) {\n    var elements = [];\n    while(n--){\n        elements.push(Math.random());\n    }\n    return Vector.create(elements);\n};\nVector.Fill = function(n, v) {\n    var elements = [];\n    while(n--){\n        elements.push(v);\n    }\n    return Vector.create(elements);\n};\n// Vector filled with zeros\nVector.Zero = function(n) {\n    return Vector.Fill(n, 0);\n};\nVector.One = function(n) {\n    return Vector.Fill(n, 1);\n};\nVector.log = function(v) {\n    return v.map(function(x) {\n        return Math.log(x);\n    });\n};\nmodule.exports = Vector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3lsdmVzdGVyL2xpYi9ub2RlLXN5bHZlc3Rlci92ZWN0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0RBQWdEO0FBQ2hELGtHQUFrRztBQUNsRyxtR0FBbUc7QUFDbkcsb0VBQW9FOztBQUVwRSxJQUFJQSxZQUFZQyxtQkFBT0EsQ0FBQyxzRkFDeEJDLFNBQVNELG1CQUFPQSxDQUFDO0FBRWpCLFNBQVNFLFVBQVU7QUFDbkJBLE9BQU9DLFNBQVMsR0FBRztJQUVmQyxNQUFNO1FBQ1QsSUFBSUMsSUFBSSxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsTUFBTTtRQUM1QixJQUFJQyxNQUFNO1FBRVYsTUFBT0gsSUFBSztZQUNSRyxPQUFPQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDSixRQUFRLENBQUNELEVBQUUsRUFBRTtRQUN0QztRQUVBLE9BQU9JLEtBQUtFLElBQUksQ0FBQ0g7SUFDZDtJQUVBLGtDQUFrQztJQUNsQ0ksR0FBRyxTQUFTQyxDQUFDO1FBQ1gsT0FBTyxJQUFLLEtBQUtBLElBQUksSUFBSSxDQUFDUCxRQUFRLENBQUNDLE1BQU0sR0FBSSxPQUFPLElBQUksQ0FBQ0QsUUFBUSxDQUFDTyxJQUFJLEVBQUU7SUFDMUU7SUFFQSxvREFBb0Q7SUFDcERDLFlBQVk7UUFDVixPQUFPO1lBQUNDLE1BQU07WUFBR0MsTUFBTSxJQUFJLENBQUNWLFFBQVEsQ0FBQ0MsTUFBTTtRQUFBO0lBQzdDO0lBRUEsMkNBQTJDO0lBQzNDUSxNQUFNO1FBQ0osT0FBTztJQUNUO0lBRUEsOENBQThDO0lBQzlDQyxNQUFNO1FBQ0osT0FBTyxJQUFJLENBQUNWLFFBQVEsQ0FBQ0MsTUFBTTtJQUM3QjtJQUVBLCtDQUErQztJQUMvQ1UsU0FBUztRQUNQLE9BQU9SLEtBQUtFLElBQUksQ0FBQyxJQUFJLENBQUNPLEdBQUcsQ0FBQyxJQUFJO0lBQ2hDO0lBRUEsdURBQXVEO0lBQ3ZEQyxLQUFLLFNBQVNDLE1BQU07UUFDbkIsSUFBSWYsSUFBSSxJ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OEYsTUFBTTtJQUFLO0lBQzVDLE9BQU9yRyxPQUFPdUIsTUFBTSxDQUFDbkI7QUFDekI7QUFFQUosT0FBT3NHLElBQUksR0FBRyxTQUFTbkcsQ0FBQyxFQUFFeUMsQ0FBQztJQUN2QixJQUFJeEMsV0FBVyxFQUFFO0lBQ2pCLE1BQU9ELElBQUs7UUFBRUMsU0FBU3dCLElBQUksQ0FBQ2dCO0lBQUk7SUFDaEMsT0FBTzVDLE9BQU91QixNQUFNLENBQUNuQjtBQUN6QjtBQUVBLDJCQUEyQjtBQUMzQkosT0FBT3VHLElBQUksR0FBRyxTQUFTcEcsQ0FBQztJQUNwQixPQUFPSCxPQUFPc0csSUFBSSxDQUFDbkcsR0FBRztBQUMxQjtBQUVBSCxPQUFPd0csR0FBRyxHQUFHLFNBQVNyRyxDQUFDO0lBQ25CLE9BQU9ILE9BQU9zRyxJQUFJLENBQUNuRyxHQUFHO0FBQzFCO0FBRUFILE9BQU9vRCxHQUFHLEdBQUcsU0FBU1IsQ0FBQztJQUNuQixPQUFPQSxFQUFFcEIsR0FBRyxDQUFDLFNBQVNHLENBQUM7UUFDMUIsT0FBT3BCLEtBQUs2QyxHQUFHLENBQUN6QjtJQUNiO0FBQ0o7QUFFQThFLE9BQU9DLE9BQU8sR0FBRzFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGlvbmV6LW5leHRqcy8uL25vZGVfbW9kdWxlcy9zeWx2ZXN0ZXIvbGliL25vZGUtc3lsdmVzdGVyL3ZlY3Rvci5qcz83YjYwIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxMSwgQ2hyaXMgVW1iZWwsIEphbWVzIENvZ2xhblxuLy8gVGhpcyBmaWxlIGlzIHJlcXVpcmVkIGluIG9yZGVyIGZvciBhbnkgb3RoZXIgY2xhc3NlcyB0byB3b3JrLiBTb21lIFZlY3RvciBtZXRob2RzIHdvcmsgd2l0aCB0aGVcbi8vIG90aGVyIFN5bHZlc3RlciBjbGFzc2VzIGFuZCBhcmUgdXNlbGVzcyB1bmxlc3MgdGhleSBhcmUgaW5jbHVkZWQuIE90aGVyIGNsYXNzZXMgc3VjaCBhcyBMaW5lIGFuZFxuLy8gUGxhbmUgd2lsbCBub3QgZnVuY3Rpb24gYXQgYWxsIHdpdGhvdXQgVmVjdG9yIGJlaW5nIGxvYWRlZCBmaXJzdC5cblxudmFyIFN5bHZlc3RlciA9IHJlcXVpcmUoJy4vc3lsdmVzdGVyJyksXG5NYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xuXG5mdW5jdGlvbiBWZWN0b3IoKSB7fVxuVmVjdG9yLnByb3RvdHlwZSA9IHtcblxuICAgIG5vcm06IGZ1bmN0aW9uKCkge1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR2YXIgc3VtID0gMDtcblxuXHR3aGlsZSAobi0tKSB7XG5cdCAgICBzdW0gKz0gTWF0aC5wb3codGhpcy5lbGVtZW50c1tuXSwgMik7XG5cdH1cblxuXHRyZXR1cm4gTWF0aC5zcXJ0KHN1bSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgZWxlbWVudCBpIG9mIHRoZSB2ZWN0b3JcbiAgICBlOiBmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gKGkgPCAxIHx8IGkgPiB0aGlzLmVsZW1lbnRzLmxlbmd0aCkgPyBudWxsIDogdGhpcy5lbGVtZW50c1tpIC0gMV07XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzL2NvbHVtbnMgdGhlIHZlY3RvciBoYXNcbiAgICBkaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7cm93czogMSwgY29sczogdGhpcy5lbGVtZW50cy5sZW5ndGh9O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgdmVjdG9yXG4gICAgcm93czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHZlY3RvclxuICAgIGNvbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBtb2R1bHVzICgnbGVuZ3RoJykgb2YgdGhlIHZlY3RvclxuICAgIG1vZHVsdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRvdCh0aGlzKSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBlcXVhbCB0byB0aGUgYXJndW1lbnRcbiAgICBlcWw6IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgIFx0dmFyIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICBcdHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3RvcjtcbiAgICBcdGlmIChuICE9IFYubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIFx0d2hpbGUgKG4tLSkge1xuICAgIFx0ICAgIGlmIChNYXRoLmFicyh0aGlzLmVsZW1lbnRzW25dIC0gVltuXSkgPiBTeWx2ZXN0ZXIucHJlY2lzaW9uKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIFx0fVxuICAgIFx0cmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBjb3B5IG9mIHRoZSB2ZWN0b3JcbiAgICBkdXA6IGZ1bmN0aW9uKCkge1xuXHQgICAgcmV0dXJuIFZlY3Rvci5jcmVhdGUodGhpcy5lbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIE1hcHMgdGhlIHZlY3RvciB0byBhbm90aGVyIHZlY3RvciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGZ1bmN0aW9uXG4gICAgbWFwOiBmdW5jdGlvbihmbikge1xuXHR2YXIgZWxlbWVudHMgPSBbXTtcblx0dGhpcy5lYWNoKGZ1bmN0aW9uKHgsIGkpIHtcblx0ICAgIGVsZW1lbnRzLnB1c2goZm4oeCwgaSkpO1xuXHR9KTtcblx0cmV0dXJuIFZlY3Rvci5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBDYWxscyB0aGUgaXRlcmF0b3IgZm9yIGVhY2ggZWxlbWVudCBvZiB0aGUgdmVjdG9yIGluIHR1cm5cbiAgICBlYWNoOiBmdW5jdGlvbihmbikge1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHQgICAgZm4odGhpcy5lbGVtZW50c1tpXSwgaSArIDEpO1xuXHR9XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSBuZXcgdmVjdG9yIGNyZWF0ZWQgYnkgbm9ybWFsaXppbmcgdGhlIHJlY2VpdmVyXG4gICAgdG9Vbml0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0dmFyIHIgPSB0aGlzLm1vZHVsdXMoKTtcblx0aWYgKHIgPT09IDApIHsgcmV0dXJuIHRoaXMuZHVwKCk7IH1cblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgpIHsgcmV0dXJuIHggLyByOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgYW5nbGUgYmV0d2VlbiB0aGUgdmVjdG9yIGFuZCB0aGUgYXJndW1lbnQgKGFsc28gYSB2ZWN0b3IpXG4gICAgYW5nbGVGcm9tOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIFYgPSB2ZWN0b3IuZWxlbWVudHMgfHwgdmVjdG9yO1xuXHR2YXIgbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoLCBrID0gbiwgaTtcblx0aWYgKG4gIT0gVi5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIGRvdCA9IDAsIG1vZDEgPSAwLCBtb2QyID0gMDtcblx0Ly8gV29yayB0aGluZ3Mgb3V0IGluIHBhcmFsbGVsIHRvIHNhdmUgdGltZVxuXHR0aGlzLmVhY2goZnVuY3Rpb24oeCwgaSkge1xuXHQgICAgZG90ICs9IHggKiBWW2kgLSAxXTtcblx0ICAgIG1vZDEgKz0geCAqIHg7XG5cdCAgICBtb2QyICs9IFZbaSAtIDFdICogVltpIC0gMV07XG5cdH0pO1xuXHRtb2QxID0gTWF0aC5zcXJ0KG1vZDEpOyBtb2QyID0gTWF0aC5zcXJ0KG1vZDIpO1xuXHRpZiAobW9kMSAqIG1vZDIgPT09IDApIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIHRoZXRhID0gZG90IC8gKG1vZDEgKiBtb2QyKTtcblx0aWYgKHRoZXRhIDwgLTEpIHsgdGhldGEgPSAtMTsgfVxuXHRpZiAodGhldGEgPiAxKSB7IHRoZXRhID0gMTsgfVxuXHRyZXR1cm4gTWF0aC5hY29zKHRoZXRhKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIHBhcmFsbGVsIHRvIHRoZSBhcmd1bWVudFxuICAgIGlzUGFyYWxsZWxUbzogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHZhciBhbmdsZSA9IHRoaXMuYW5nbGVGcm9tKHZlY3Rvcik7XG5cdHJldHVybiAoYW5nbGUgPT09IG51bGwpID8gbnVsbCA6IChhbmdsZSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGFudGlwYXJhbGxlbCB0byB0aGUgYXJndW1lbnRcbiAgICBpc0FudGlwYXJhbGxlbFRvOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIGFuZ2xlID0gdGhpcy5hbmdsZUZyb20odmVjdG9yKTtcblx0cmV0dXJuIChhbmdsZSA9PT0gbnVsbCkgPyBudWxsIDogKE1hdGguYWJzKGFuZ2xlIC0gTWF0aC5QSSkgPD0gU3lsdmVzdGVyLnByZWNpc2lvbik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZmYgdGhlIHZlY3RvciBpcyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBhcmd1bWVudFxuICAgIGlzUGVycGVuZGljdWxhclRvOiBmdW5jdGlvbih2ZWN0b3IpIHtcblx0dmFyIGRvdCA9IHRoaXMuZG90KHZlY3Rvcik7XG5cdHJldHVybiAoZG90ID09PSBudWxsKSA/IG51bGwgOiAoTWF0aC5hYnMoZG90KSA8PSBTeWx2ZXN0ZXIucHJlY2lzaW9uKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGFkZGluZyB0aGUgYXJndW1lbnQgdG8gdGhlIHZlY3RvclxuICAgIGFkZDogZnVuY3Rpb24odmFsdWUpIHtcblx0dmFyIFYgPSB2YWx1ZS5lbGVtZW50cyB8fCB2YWx1ZTtcblxuXHRpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gVi5sZW5ndGgpIFxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHYpIHsgcmV0dXJuIHYgKyB2YWx1ZSB9KTtcblx0ZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHgsIGkpIHsgcmV0dXJuIHggKyBWW2kgLSAxXTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzdWJ0cmFjdGluZyB0aGUgYXJndW1lbnQgZnJvbSB0aGUgdmVjdG9yXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKHYpIHtcblx0aWYgKHR5cGVvZih2KSA9PSAnbnVtYmVyJylcblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiBrIC0gdjsgfSk7XG5cblx0dmFyIFYgPSB2LmVsZW1lbnRzIHx8IHY7XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSBWLmxlbmd0aCkgeyByZXR1cm4gbnVsbDsgfVxuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCwgaSkgeyByZXR1cm4geCAtIFZbaSAtIDFdOyB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIG11bHRpcGx5aW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yIGJ5IHRoZSBhcmd1bWVudFxuICAgIG11bHRpcGx5OiBmdW5jdGlvbihrKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4ICogazsgfSk7XG4gICAgfSxcblxuICAgIGVsZW1lbnRNdWx0aXBseTogZnVuY3Rpb24odikge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaywgaSkge1xuXHQgICAgcmV0dXJuIHYuZShpKSAqIGs7XG5cdH0pO1xuICAgIH0sXG5cbiAgICBzdW06IGZ1bmN0aW9uKCkge1xuXHR2YXIgc3VtID0gMDtcblx0dGhpcy5tYXAoZnVuY3Rpb24oeCkgeyBzdW0gKz0geDt9KTtcblx0cmV0dXJuIHN1bTtcbiAgICB9LFxuXG4gICAgY2hvbXA6IGZ1bmN0aW9uKG4pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IG47IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBlbGVtZW50cy5wdXNoKHRoaXMuZWxlbWVudHNbaV0pO1xuXHR9XG5cblx0cmV0dXJuIFZlY3Rvci5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICB0b3A6IGZ1bmN0aW9uKG4pIHtcblx0dmFyIGVsZW1lbnRzID0gW107XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGVsZW1lbnRzLnB1c2godGhpcy5lbGVtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIGF1Z21lbnQ6IGZ1bmN0aW9uKGVsZW1lbnRzKSB7XG5cdHZhciBuZXdFbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuXHQgICAgbmV3RWxlbWVudHMucHVzaChlbGVtZW50c1tpXSk7XG5cdH1cblxuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShuZXdFbGVtZW50cyk7XG4gICAgfSxcblxuICAgIHg6IGZ1bmN0aW9uKGspIHsgcmV0dXJuIHRoaXMubXVsdGlwbHkoayk7IH0sXG5cbiAgICBsb2c6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gVmVjdG9yLmxvZyh0aGlzKTtcbiAgICB9LFxuXG4gICAgZWxlbWVudERpdmlkZTogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih2LCBpKSB7XG5cdCAgICByZXR1cm4gdiAvIHZlY3Rvci5lKGkpO1xuXHR9KTtcbiAgICB9LFxuXG4gICAgcHJvZHVjdDogZnVuY3Rpb24oKSB7XG5cdHZhciBwID0gMTtcblxuXHR0aGlzLm1hcChmdW5jdGlvbih2KSB7XG5cdCAgICBwICo9IHY7XG5cdH0pO1xuXG5cdHJldHVybiBwO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBzY2FsYXIgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XG4gICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBlcXVhbCBkaW1lbnNpb25hbGl0eVxuICAgIGRvdDogZnVuY3Rpb24odmVjdG9yKSB7XG5cdHZhciBWID0gdmVjdG9yLmVsZW1lbnRzIHx8IHZlY3Rvcjtcblx0dmFyIGksIHByb2R1Y3QgPSAwLCBuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XHRcblx0aWYgKG4gIT0gVi5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0d2hpbGUgKG4tLSkgeyBwcm9kdWN0ICs9IHRoaXMuZWxlbWVudHNbbl0gKiBWW25dOyB9XG5cdHJldHVybiBwcm9kdWN0O1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IgcHJvZHVjdCBvZiB0aGUgdmVjdG9yIHdpdGggdGhlIGFyZ3VtZW50XG4gICAgLy8gQm90aCB2ZWN0b3JzIG11c3QgaGF2ZSBkaW1lbnNpb25hbGl0eSAzXG4gICAgY3Jvc3M6IGZ1bmN0aW9uKHZlY3Rvcikge1xuXHR2YXIgQiA9IHZlY3Rvci5lbGVtZW50cyB8fCB2ZWN0b3I7XG5cdGlmICh0aGlzLmVsZW1lbnRzLmxlbmd0aCAhPSAzIHx8IEIubGVuZ3RoICE9IDMpIHsgcmV0dXJuIG51bGw7IH1cblx0dmFyIEEgPSB0aGlzLmVsZW1lbnRzO1xuXHRyZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG5cdCAgICAoQVsxXSAqIEJbMl0pIC0gKEFbMl0gKiBCWzFdKSxcblx0ICAgIChBWzJdICogQlswXSkgLSAoQVswXSAqIEJbMl0pLFxuXHQgICAgKEFbMF0gKiBCWzFdKSAtIChBWzFdICogQlswXSlcblx0XSk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIChhYnNvbHV0ZSkgbGFyZ2VzdCBlbGVtZW50IG9mIHRoZSB2ZWN0b3JcbiAgICBtYXg6IGZ1bmN0aW9uKCkge1xuXHR2YXIgbSA9IDAsIGkgPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0d2hpbGUgKGktLSkge1xuXHQgICAgaWYgKE1hdGguYWJzKHRoaXMuZWxlbWVudHNbaV0pID4gTWF0aC5hYnMobSkpIHsgbSA9IHRoaXMuZWxlbWVudHNbaV07IH1cblx0fVxuXHRyZXR1cm4gbTtcbiAgICB9LFxuXG5cbiAgICBtYXhJbmRleDogZnVuY3Rpb24oKSB7XG5cdHZhciBtID0gMCwgaSA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuXHR2YXIgbWF4SW5kZXggPSAtMTtcblxuXHR3aGlsZSAoaS0tKSB7XG5cdCAgICBpZiAoTWF0aC5hYnModGhpcy5lbGVtZW50c1tpXSkgPiBNYXRoLmFicyhtKSkgeyBcblx0XHRtID0gdGhpcy5lbGVtZW50c1tpXTsgXG5cdFx0bWF4SW5kZXggPSBpICsgMTtcblx0ICAgIH1cblx0fVxuXG5cdHJldHVybiBtYXhJbmRleDtcbiAgICB9LFxuXG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgbWF0Y2ggZm91bmRcbiAgICBpbmRleE9mOiBmdW5jdGlvbih4KSB7XG5cdHZhciBpbmRleCA9IG51bGwsIG4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcblx0ICAgIGlmIChpbmRleCA9PT0gbnVsbCAmJiB0aGlzLmVsZW1lbnRzW2ldID09IHgpIHtcblx0XHRpbmRleCA9IGkgKyAxO1xuXHQgICAgfVxuXHR9XG5cdHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIGRpYWdvbmFsIG1hdHJpeCB3aXRoIHRoZSB2ZWN0b3IncyBlbGVtZW50cyBhcyBpdHMgZGlhZ29uYWwgZWxlbWVudHNcbiAgICB0b0RpYWdvbmFsTWF0cml4OiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdHJpeC5EaWFnb25hbCh0aGlzLmVsZW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJvdW5kaW5nIHRoZSBlbGVtZW50cyBvZiB0aGUgdmVjdG9yXG4gICAgcm91bmQ6IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oeCkgeyByZXR1cm4gTWF0aC5yb3VuZCh4KTsgfSk7XG4gICAgfSxcblxuICAgIC8vIFRyYW5zcG9zZSBhIFZlY3RvciwgcmV0dXJuIGEgMXhuIE1hdHJpeFxuICAgIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG5cdHZhciByb3dzID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG5cdHZhciBlbGVtZW50cyA9IFtdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG5cdCAgICBlbGVtZW50cy5wdXNoKFt0aGlzLmVsZW1lbnRzW2ldXSk7XG5cdH1cblx0cmV0dXJuIE1hdHJpeC5jcmVhdGUoZWxlbWVudHMpO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgdmVjdG9yIHdpdGggZWxlbWVudHMgc2V0IHRvIHRoZSBnaXZlbiB2YWx1ZSBpZiB0aGV5XG4gICAgLy8gZGlmZmVyIGZyb20gaXQgYnkgbGVzcyB0aGFuIFN5bHZlc3Rlci5wcmVjaXNpb25cbiAgICBzbmFwVG86IGZ1bmN0aW9uKHgpIHtcblx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHkpIHtcblx0ICAgIHJldHVybiAoTWF0aC5hYnMoeSAtIHgpIDw9IFN5bHZlc3Rlci5wcmVjaXNpb24pID8geCA6IHk7XG5cdH0pO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2ZWN0b3IncyBkaXN0YW5jZSBmcm9tIHRoZSBhcmd1bWVudCwgd2hlbiBjb25zaWRlcmVkIGFzIGEgcG9pbnQgaW4gc3BhY2VcbiAgICBkaXN0YW5jZUZyb206IGZ1bmN0aW9uKG9iaikge1xuXHRpZiAob2JqLmFuY2hvciB8fCAob2JqLnN0YXJ0ICYmIG9iai5lbmQpKSB7IHJldHVybiBvYmouZGlzdGFuY2VGcm9tKHRoaXMpOyB9XG5cdHZhciBWID0gb2JqLmVsZW1lbnRzIHx8IG9iajtcblx0aWYgKFYubGVuZ3RoICE9IHRoaXMuZWxlbWVudHMubGVuZ3RoKSB7IHJldHVybiBudWxsOyB9XG5cdHZhciBzdW0gPSAwLCBwYXJ0O1xuXHR0aGlzLmVhY2goZnVuY3Rpb24oeCwgaSkge1xuXHQgICAgcGFydCA9IHggLSBWW2kgLSAxXTtcblx0ICAgIHN1bSArPSBwYXJ0ICogcGFydDtcblx0fSk7XG5cdHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoZSB2ZWN0b3IgaXMgcG9pbnQgb24gdGhlIGdpdmVuIGxpbmVcbiAgICBsaWVzT246IGZ1bmN0aW9uKGxpbmUpIHtcblx0cmV0dXJuIGxpbmUuY29udGFpbnModGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybiB0cnVlIGlmZiB0aGUgdmVjdG9yIGlzIGEgcG9pbnQgaW4gdGhlIGdpdmVuIHBsYW5lXG4gICAgbGllc0luOiBmdW5jdGlvbihwbGFuZSkge1xuXHRyZXR1cm4gcGxhbmUuY29udGFpbnModGhpcyk7XG4gICAgfSxcblxuICAgIC8vIFJvdGF0ZXMgdGhlIHZlY3RvciBhYm91dCB0aGUgZ2l2ZW4gb2JqZWN0LiBUaGUgb2JqZWN0IHNob3VsZCBiZSBhXG4gICAgLy8gcG9pbnQgaWYgdGhlIHZlY3RvciBpcyAyRCwgYW5kIGEgbGluZSBpZiBpdCBpcyAzRC4gQmUgY2FyZWZ1bCB3aXRoIGxpbmUgZGlyZWN0aW9ucyFcbiAgICByb3RhdGU6IGZ1bmN0aW9uKHQsIG9iaikge1xuXHR2YXIgViwgUiA9IG51bGwsIHgsIHksIHo7XG5cdGlmICh0LmRldGVybWluYW50KSB7IFIgPSB0LmVsZW1lbnRzOyB9XG5cdHN3aXRjaCAodGhpcy5lbGVtZW50cy5sZW5ndGgpIHtcblx0Y2FzZSAyOlxuICAgICAgICAgICAgViA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG4gICAgICAgICAgICBpZiAoVi5sZW5ndGggIT0gMikgeyByZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgaWYgKCFSKSB7IFIgPSBNYXRyaXguUm90YXRpb24odCkuZWxlbWVudHM7IH1cbiAgICAgICAgICAgIHggPSB0aGlzLmVsZW1lbnRzWzBdIC0gVlswXTtcbiAgICAgICAgICAgIHkgPSB0aGlzLmVsZW1lbnRzWzFdIC0gVlsxXTtcbiAgICAgICAgICAgIHJldHVybiBWZWN0b3IuY3JlYXRlKFtcblx0XHRWWzBdICsgUlswXVswXSAqIHggKyBSWzBdWzFdICogeSxcblx0XHRWWzFdICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeVxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBicmVhaztcblx0Y2FzZSAzOlxuICAgICAgICAgICAgaWYgKCFvYmouZGlyZWN0aW9uKSB7IHJldHVybiBudWxsOyB9XG4gICAgICAgICAgICB2YXIgQyA9IG9iai5wb2ludENsb3Nlc3RUbyh0aGlzKS5lbGVtZW50cztcbiAgICAgICAgICAgIGlmICghUikgeyBSID0gTWF0cml4LlJvdGF0aW9uKHQsIG9iai5kaXJlY3Rpb24pLmVsZW1lbnRzOyB9XG4gICAgICAgICAgICB4ID0gdGhpcy5lbGVtZW50c1swXSAtIENbMF07XG4gICAgICAgICAgICB5ID0gdGhpcy5lbGVtZW50c1sxXSAtIENbMV07XG4gICAgICAgICAgICB6ID0gdGhpcy5lbGVtZW50c1syXSAtIENbMl07XG4gICAgICAgICAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbXG5cdFx0Q1swXSArIFJbMF1bMF0gKiB4ICsgUlswXVsxXSAqIHkgKyBSWzBdWzJdICogeixcblx0XHRDWzFdICsgUlsxXVswXSAqIHggKyBSWzFdWzFdICogeSArIFJbMV1bMl0gKiB6LFxuXHRcdENbMl0gKyBSWzJdWzBdICogeCArIFJbMl1bMV0gKiB5ICsgUlsyXVsyXSAqIHpcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cdGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSByZXN1bHQgb2YgcmVmbGVjdGluZyB0aGUgcG9pbnQgaW4gdGhlIGdpdmVuIHBvaW50LCBsaW5lIG9yIHBsYW5lXG4gICAgcmVmbGVjdGlvbkluOiBmdW5jdGlvbihvYmopIHtcblx0aWYgKG9iai5hbmNob3IpIHtcblx0ICAgIC8vIG9iaiBpcyBhIHBsYW5lIG9yIGxpbmVcblx0ICAgIHZhciBQID0gdGhpcy5lbGVtZW50cy5zbGljZSgpO1xuXHQgICAgdmFyIEMgPSBvYmoucG9pbnRDbG9zZXN0VG8oUCkuZWxlbWVudHM7XG5cdCAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShbQ1swXSArIChDWzBdIC0gUFswXSksIENbMV0gKyAoQ1sxXSAtIFBbMV0pLCBDWzJdICsgKENbMl0gLSAoUFsyXSB8fCAwKSldKTtcblx0fSBlbHNlIHtcblx0ICAgIC8vIG9iaiBpcyBhIHBvaW50XG5cdCAgICB2YXIgUSA9IG9iai5lbGVtZW50cyB8fCBvYmo7XG5cdCAgICBpZiAodGhpcy5lbGVtZW50cy5sZW5ndGggIT0gUS5sZW5ndGgpIHsgcmV0dXJuIG51bGw7IH1cblx0ICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbih4LCBpKSB7IHJldHVybiBRW2kgLSAxXSArIChRW2kgLSAxXSAtIHgpOyB9KTtcblx0fVxuICAgIH0sXG5cbiAgICAvLyBVdGlsaXR5IHRvIG1ha2Ugc3VyZSB2ZWN0b3JzIGFyZSAzRC4gSWYgdGhleSBhcmUgMkQsIGEgemVybyB6LWNvbXBvbmVudCBpcyBhZGRlZFxuICAgIHRvM0Q6IGZ1bmN0aW9uKCkge1xuXHR2YXIgViA9IHRoaXMuZHVwKCk7XG5cdHN3aXRjaCAoVi5lbGVtZW50cy5sZW5ndGgpIHtcblx0Y2FzZSAzOiBicmVhaztcblx0Y2FzZSAyOiBWLmVsZW1lbnRzLnB1c2goMCk7IGJyZWFrO1xuXHRkZWZhdWx0OiByZXR1cm4gbnVsbDtcblx0fVxuXHRyZXR1cm4gVjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gICAgaW5zcGVjdDogZnVuY3Rpb24oKSB7XG5cdHJldHVybiAnWycgKyB0aGlzLmVsZW1lbnRzLmpvaW4oJywgJykgKyAnXSc7XG4gICAgfSxcblxuICAgIC8vIFNldCB2ZWN0b3IncyBlbGVtZW50cyBmcm9tIGFuIGFycmF5XG4gICAgc2V0RWxlbWVudHM6IGZ1bmN0aW9uKGVscykge1xuXHR0aGlzLmVsZW1lbnRzID0gKGVscy5lbGVtZW50cyB8fCBlbHMpLnNsaWNlKCk7XG5cdHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbi8vIENvbnN0cnVjdG9yIGZ1bmN0aW9uXG5WZWN0b3IuY3JlYXRlID0gZnVuY3Rpb24oZWxlbWVudHMpIHtcbiAgICB2YXIgViA9IG5ldyBWZWN0b3IoKTtcbiAgICByZXR1cm4gVi5zZXRFbGVtZW50cyhlbGVtZW50cyk7XG59O1xuXG4vLyBpLCBqLCBrIHVuaXQgdmVjdG9yc1xuVmVjdG9yLmkgPSBWZWN0b3IuY3JlYXRlKFsxLCAwLCAwXSk7XG5WZWN0b3IuaiA9IFZlY3Rvci5jcmVhdGUoWzAsIDEsIDBdKTtcblZlY3Rvci5rID0gVmVjdG9yLmNyZWF0ZShbMCwgMCwgMV0pO1xuXG4vLyBSYW5kb20gdmVjdG9yIG9mIHNpemUgblxuVmVjdG9yLlJhbmRvbSA9IGZ1bmN0aW9uKG4pIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAobi0tKSB7IGVsZW1lbnRzLnB1c2goTWF0aC5yYW5kb20oKSk7IH1cbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG59O1xuXG5WZWN0b3IuRmlsbCA9IGZ1bmN0aW9uKG4sIHYpIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB3aGlsZSAobi0tKSB7IGVsZW1lbnRzLnB1c2godik7IH1cbiAgICByZXR1cm4gVmVjdG9yLmNyZWF0ZShlbGVtZW50cyk7XG59O1xuXG4vLyBWZWN0b3IgZmlsbGVkIHdpdGggemVyb3NcblZlY3Rvci5aZXJvID0gZnVuY3Rpb24obikge1xuICAgIHJldHVybiBWZWN0b3IuRmlsbChuLCAwKTtcbn07XG5cblZlY3Rvci5PbmUgPSBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIFZlY3Rvci5GaWxsKG4sIDEpO1xufTtcblxuVmVjdG9yLmxvZyA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gdi5tYXAoZnVuY3Rpb24oeCkge1xuXHRyZXR1cm4gTWF0aC5sb2coeCk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlY3RvcjtcbiJdLCJuYW1lcyI6WyJTeWx2ZXN0ZXIiLCJyZXF1aXJlIiwiTWF0cml4IiwiVmVjdG9yIiwicHJvdG90eXBlIiwibm9ybSIsIm4iLCJlbGVtZW50cyIsImxlbmd0aCIsInN1bSIsIk1hdGgiLCJwb3ciLCJzcXJ0IiwiZSIsImkiLCJkaW1lbnNpb25zIiwicm93cyIsImNvbHMiLCJtb2R1bHVzIiwiZG90IiwiZXFsIiwidmVjdG9yIiwiViIsImFicyIsInByZWNpc2lvbiIsImR1cCIsImNyZWF0ZSIsIm1hcCIsImZuIiwiZWFjaCIsIngiLCJwdXNoIiwidG9Vbml0VmVjdG9yIiwiciIsImFuZ2xlRnJvbSIsImsiLCJtb2QxIiwibW9kMiIsInRoZXRhIiwiYWNvcyIsImlzUGFyYWxsZWxUbyIsImFuZ2xlIiwiaXNBbnRpcGFyYWxsZWxUbyIsIlBJIiwiaXNQZXJwZW5kaWN1bGFyVG8iLCJhZGQiLCJ2YWx1ZSIsInYiLCJzdWJ0cmFjdCIsIm11bHRpcGx5IiwiZWxlbWVudE11bHRpcGx5IiwiY2hvbXAiLCJ0b3AiLCJhdWdtZW50IiwibmV3RWxlbWVudHMiLCJsb2ciLCJlbGVtZW50RGl2aWRlIiwicHJvZHVjdCIsInAiLCJjcm9zcyIsIkIiLCJBIiwibWF4IiwibSIsIm1heEluZGV4IiwiaW5kZXhPZiIsImluZGV4IiwidG9EaWFnb25hbE1hdHJpeCIsIkRpYWdvbmFsIiwicm91bmQiLCJ0cmFuc3Bvc2UiLCJzbmFwVG8iLCJ5IiwiZGlzdGFuY2VGcm9tIiwib2JqIiwiYW5jaG9yIiwic3RhcnQiLCJlbmQiLCJwYXJ0IiwibGllc09uIiwibGluZSIsImNvbnRhaW5zIiwibGllc0luIiwicGxhbmUiLCJyb3RhdGUiLCJ0IiwiUiIsInoiLCJkZXRlcm1pbmFudCIsIlJvdGF0aW9uIiwiZGlyZWN0aW9uIiwiQyIsInBvaW50Q2xvc2VzdFRvIiwicmVmbGVjdGlvbkluIiwiUCIsInNsaWNlIiwiUSIsInRvM0QiLCJpbnNwZWN0Iiwiam9pbiIsInNldEVsZW1lbnRzIiwiZWxzIiwiaiIsIlJhbmRvbSIsInJhbmRvbSIsIkZpbGwiLCJaZXJvIiwiT25lIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sylvester/lib/node-sylvester/vector.js\n");

/***/ })

};
;