"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bson";
exports.ids = ["vendor-chunks/bson"];
exports.modules = {

/***/ "(ssr)/./node_modules/bson/lib/bson.cjs":
/*!****************************************!*\
  !*** ./node_modules/bson/lib/bson.cjs ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction isAnyArrayBuffer(value) {\n    return [\n        \"[object ArrayBuffer]\",\n        \"[object SharedArrayBuffer]\"\n    ].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n    return Object.prototype.toString.call(value) === \"[object Uint8Array]\";\n}\nfunction isRegExp(d) {\n    return Object.prototype.toString.call(d) === \"[object RegExp]\";\n}\nfunction isMap(d) {\n    return Object.prototype.toString.call(d) === \"[object Map]\";\n}\nfunction isDate(d) {\n    return Object.prototype.toString.call(d) === \"[object Date]\";\n}\nfunction defaultInspect(x, _options) {\n    return JSON.stringify(x, (k, v)=>{\n        if (typeof v === \"bigint\") {\n            return {\n                $numberLong: `${v}`\n            };\n        } else if (isMap(v)) {\n            return Object.fromEntries(v);\n        }\n        return v;\n    });\n}\nfunction getStylizeFunction(options) {\n    const stylizeExists = options != null && typeof options === \"object\" && \"stylize\" in options && typeof options.stylize === \"function\";\n    if (stylizeExists) {\n        return options.stylize;\n    }\n}\nconst BSON_MAJOR_VERSION = 6;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return \"BSONError\";\n    }\n    constructor(message, options){\n        super(message, options);\n    }\n    static isBSONError(value) {\n        return value != null && typeof value === \"object\" && \"bsonError\" in value && value.bsonError === true && \"name\" in value && \"message\" in value && \"stack\" in value;\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return \"BSONVersionError\";\n    }\n    constructor(){\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return \"BSONRuntimeError\";\n    }\n    constructor(message){\n        super(message);\n    }\n}\nclass BSONOffsetError extends BSONError {\n    get name() {\n        return \"BSONOffsetError\";\n    }\n    constructor(message, offset, options){\n        super(`${message}. offset: ${offset}`, options);\n        this.offset = offset;\n    }\n}\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n    let continuation = 0;\n    for(let i = start; i < end; i += 1){\n        const byte = bytes[i];\n        if (continuation) {\n            if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n                return false;\n            }\n            continuation -= 1;\n        } else if (byte & FIRST_BIT) {\n            if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n                continuation = 1;\n            } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n                continuation = 2;\n            } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n                continuation = 3;\n            } else {\n                return false;\n            }\n        }\n    }\n    return !continuation;\n}\nfunction tryReadBasicLatin(uint8array, start, end) {\n    if (uint8array.length === 0) {\n        return \"\";\n    }\n    const stringByteLength = end - start;\n    if (stringByteLength === 0) {\n        return \"\";\n    }\n    if (stringByteLength > 20) {\n        return null;\n    }\n    if (stringByteLength === 1 && uint8array[start] < 128) {\n        return String.fromCharCode(uint8array[start]);\n    }\n    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {\n        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);\n    }\n    if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {\n        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);\n    }\n    const latinBytes = [];\n    for(let i = start; i < end; i++){\n        const byte = uint8array[i];\n        if (byte > 127) {\n            return null;\n        }\n        latinBytes.push(byte);\n    }\n    return String.fromCharCode(...latinBytes);\n}\nfunction tryWriteBasicLatin(destination, source, offset) {\n    if (source.length === 0) return 0;\n    if (source.length > 25) return null;\n    if (destination.length - offset < source.length) return null;\n    for(let charOffset = 0, destinationOffset = offset; charOffset < source.length; charOffset++, destinationOffset++){\n        const char = source.charCodeAt(charOffset);\n        if (char > 127) return null;\n        destination[destinationOffset] = char;\n    }\n    return source.length;\n}\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = (()=>{\n    try {\n        return (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\n    } catch  {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType (potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n    },\n    allocate (size) {\n        return Buffer.alloc(size);\n    },\n    allocateUnsafe (size) {\n        return Buffer.allocUnsafe(size);\n    },\n    equals (a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray (array) {\n        return Buffer.from(array);\n    },\n    fromBase64 (base64) {\n        return Buffer.from(base64, \"base64\");\n    },\n    toBase64 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"base64\");\n    },\n    fromISO88591 (codePoints) {\n        return Buffer.from(codePoints, \"binary\");\n    },\n    toISO88591 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"binary\");\n    },\n    fromHex (hex) {\n        return Buffer.from(hex, \"hex\");\n    },\n    toHex (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"hex\");\n    },\n    toUTF8 (buffer, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryReadBasicLatin(buffer, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        const string = nodeJsByteUtils.toLocalBufferType(buffer).toString(\"utf8\", start, end);\n        if (fatal) {\n            for(let i = 0; i < string.length; i++){\n                if (string.charCodeAt(i) === 0xfffd) {\n                    if (!validateUtf8(buffer, start, end)) {\n                        throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                    }\n                    break;\n                }\n            }\n        }\n        return string;\n    },\n    utf8ByteLength (input) {\n        return Buffer.byteLength(input, \"utf8\");\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        const latinBytesWritten = tryWriteBasicLatin(buffer, source, byteOffset);\n        if (latinBytesWritten != null) {\n            return latinBytesWritten;\n        }\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, \"utf8\");\n    },\n    randomBytes: nodejsRandomBytes\n};\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === \"object\" && navigator.product === \"ReactNative\";\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (()=>{\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === \"function\") {\n        return (byteLength)=>{\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    } else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.(\"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.\");\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType (potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === \"Uint8Array\") {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n    },\n    allocate (size) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    allocateUnsafe (size) {\n        return webByteUtils.allocate(size);\n    },\n    equals (a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < a.byteLength; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray (array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64 (base64) {\n        return Uint8Array.from(atob(base64), (c)=>c.charCodeAt(0));\n    },\n    toBase64 (uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591 (codePoints) {\n        return Uint8Array.from(codePoints, (c)=>c.charCodeAt(0) & 0xff);\n    },\n    toISO88591 (uint8array) {\n        return Array.from(Uint16Array.from(uint8array), (b)=>String.fromCharCode(b)).join(\"\");\n    },\n    fromHex (hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for(let i = 0; i < evenLengthHex.length; i += 2){\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex (uint8array) {\n        return Array.from(uint8array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    },\n    toUTF8 (uint8array, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryReadBasicLatin(uint8array, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        if (fatal) {\n            try {\n                return new TextDecoder(\"utf8\", {\n                    fatal\n                }).decode(uint8array.slice(start, end));\n            } catch (cause) {\n                throw new BSONError(\"Invalid UTF-8 string in BSON document\", {\n                    cause\n                });\n            }\n        }\n        return new TextDecoder(\"utf8\", {\n            fatal\n        }).decode(uint8array.slice(start, end));\n    },\n    utf8ByteLength (input) {\n        return new TextEncoder().encode(input).byteLength;\n    },\n    encodeUTF8Into (uint8array, source, byteOffset) {\n        const bytes = new TextEncoder().encode(source);\n        uint8array.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes\n};\nconst hasGlobalBuffer = typeof Buffer === \"function\" && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONValue {\n    get [Symbol.for(\"@@mdb.bson.version\")]() {\n        return BSON_MAJOR_VERSION;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth, options, inspect) {\n        return this.inspect(depth, options, inspect);\n    }\n}\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return \"Binary\";\n    }\n    constructor(buffer, subType){\n        super();\n        if (!(buffer == null) && typeof buffer === \"string\" && !ArrayBuffer.isView(buffer) && !isAnyArrayBuffer(buffer) && !Array.isArray(buffer)) {\n            throw new BSONError(\"Binary can only be constructed from Uint8Array or number[]\");\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        } else {\n            this.buffer = Array.isArray(buffer) ? ByteUtils.fromNumberArray(buffer) : ByteUtils.toLocalBufferType(buffer);\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === \"string\" && byteValue.length !== 1) {\n            throw new BSONError(\"only accepts single character String\");\n        } else if (typeof byteValue !== \"number\" && byteValue.length !== 1) throw new BSONError(\"only accepts single character Uint8Array or Array\");\n        let decodedByte;\n        if (typeof byteValue === \"string\") {\n            decodedByte = byteValue.charCodeAt(0);\n        } else if (typeof byteValue === \"number\") {\n            decodedByte = byteValue;\n        } else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError(\"only accepts number in a valid unsigned byte range 0-255\");\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        } else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === \"number\" ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        } else if (typeof sequence === \"string\") {\n            throw new BSONError(\"input cannot be string\");\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        return this.buffer.slice(position, position + length);\n    }\n    value() {\n        return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.buffer.subarray(0, this.position));\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        if (encoding === \"utf8\" || encoding === \"utf-8\") return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n        return ByteUtils.toUTF8(this.buffer, 0, this.position, false);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? \"0\" + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? \"0\" + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.slice(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if (\"$binary\" in doc) {\n            if (options.legacy && typeof doc.$binary === \"string\" && \"$type\" in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            } else {\n                if (typeof doc.$binary !== \"string\") {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        } else if (\"$uuid\" in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        const base64Arg = inspect(base64, options);\n        const subTypeArg = inspect(this.sub_type, options);\n        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_SENSITIVE = 8;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input){\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        } else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        } else if (typeof input === \"string\") {\n            bytes = UUID.bytesFromString(input);\n        } else {\n            throw new BSONError(\"Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\");\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join(\"-\");\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.id);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        } catch  {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = bytes[6] & 0x0f | 0x40;\n        bytes[8] = bytes[8] & 0x3f | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === \"string\") {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return input._bsontype === \"Binary\" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError(\"UUID string representation must be 32 hex digits or canonical hyphenated representation\");\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, \"\"));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new UUID(${inspect(this.toHexString(), options)})`;\n    }\n}\nclass Code extends BSONValue {\n    get _bsontype() {\n        return \"Code\";\n    }\n    constructor(code, scope){\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return {\n                code: this.code,\n                scope: this.scope\n            };\n        }\n        return {\n            code: this.code\n        };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return {\n                $code: this.code,\n                $scope: this.scope\n            };\n        }\n        return {\n            $code: this.code\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        let parametersString = inspect(this.code, options);\n        const multiLineFn = parametersString.includes(\"\\n\");\n        if (this.scope != null) {\n            parametersString += `,${multiLineFn ? \"\\n\" : \" \"}${inspect(this.scope, options)}`;\n        }\n        const endingNewline = multiLineFn && this.scope === null;\n        return `new Code(${multiLineFn ? \"\\n\" : \"\"}${parametersString}${endingNewline ? \"\\n\" : \"\"})`;\n    }\n}\nfunction isDBRefLike(value) {\n    return value != null && typeof value === \"object\" && \"$id\" in value && value.$id != null && \"$ref\" in value && typeof value.$ref === \"string\" && (!(\"$db\" in value) || \"$db\" in value && typeof value.$db === \"string\");\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return \"DBRef\";\n    }\n    constructor(collection, oid, db, fields){\n        super();\n        const parts = collection.split(\".\");\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null) o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db) o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const args = [\n            inspect(this.namespace, options),\n            inspect(this.oid, options),\n            ...this.db ? [\n                inspect(this.db, options)\n            ] : [],\n            ...Object.keys(this.fields).length > 0 ? [\n                inspect(this.fields, options)\n            ] : []\n        ];\n        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];\n        return `new DBRef(${args.join(\", \")})`;\n    }\n}\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n    ])), {}).exports;\n} catch  {}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return \"Long\";\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(low = 0, high, unsigned){\n        super();\n        if (typeof low === \"bigint\") {\n            Object.assign(this, Long.fromBigInt(low, !!high));\n        } else if (typeof low === \"string\") {\n            Object.assign(this, Long.fromString(low, !!high));\n        } else {\n            this.low = low | 0;\n            this.high = high | 0;\n            this.unsigned = !!unsigned;\n        }\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0) return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;\n        }\n        if (value < 0) return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        return Long.fromString(value.toString(), unsigned);\n    }\n    static fromString(str, unsigned, radix) {\n        if (str.length === 0) throw new BSONError(\"empty string\");\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return Long.ZERO;\n        if (typeof unsigned === \"number\") {\n            radix = unsigned, unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        let p;\n        if ((p = str.indexOf(\"-\")) > 0) throw new BSONError(\"interior hyphen\");\n        else if (p === 0) {\n            return Long.fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for(let i = 0; i < str.length; i += 8){\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return value != null && typeof value === \"object\" && \"__isLong__\" in value && value.__isLong__ === true;\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === \"number\") return Long.fromNumber(val, unsigned);\n        if (typeof val === \"string\") return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend)) addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.eq(other)) return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1;\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (divisor.isZero()) throw new BSONError(\"division by zero\");\n        if (wasm) {\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        } else {\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return Long.UZERO;\n            if (divisor.gt(this.shru(1))) return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while(rem.gte(divisor)){\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero()) approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for(bit = 31; bit > 0; bit--)if ((val & 1 << bit) !== 0) break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero()) return Long.ZERO;\n        if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero()) return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0) return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n            } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);\n            else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = \"\";\n        while(true){\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            } else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed) return this.toNumber();\n        return {\n            $numberLong: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = {\n            ...options\n        };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError(\"$numberLong string is too long\");\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const longVal = inspect(this.toString(), options);\n        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : \"\";\n        return `new Long(${longVal}${unsignedVal})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return {\n            quotient: value,\n            rem: _rem\n        };\n    }\n    for(let i = 0; i <= 3; i++){\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return {\n        quotient: value,\n        rem: _rem\n    };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return {\n            high: Long.fromNumber(0),\n            low: Long.fromNumber(0)\n        };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return {\n        high: productHigh,\n        low: productLow\n    };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    } else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright) return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return \"Decimal128\";\n    }\n    constructor(bytes){\n        super();\n        if (typeof bytes === \"string\") {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        } else if (isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError(\"Decimal128 must take a Buffer of 16 bytes\");\n            }\n            this.bytes = bytes;\n        } else {\n            throw new BSONError(\"Decimal128 must take a Buffer or string\");\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: false\n        });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: true\n        });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [\n            0\n        ];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined) invalidErr(representation, \"missing exponent power\");\n            if (e && unsignedNumber === undefined) invalidErr(representation, \"missing exponent base\");\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, \"missing e before exponent\");\n            }\n        }\n        if (representation[index] === \"+\" || representation[index] === \"-\") {\n            sawSign = true;\n            isNegative = representation[index++] === \"-\";\n        }\n        if (!isDigit(representation[index]) && representation[index] !== \".\") {\n            if (representation[index] === \"i\" || representation[index] === \"I\") {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            } else if (representation[index] === \"N\") {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while(isDigit(representation[index]) || representation[index] === \".\"){\n            if (representation[index] === \".\") {\n                if (sawRadix) invalidErr(representation, \"contains multiple periods\");\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== \"0\" || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero) nDigits = nDigits + 1;\n            if (sawRadix) radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead) throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        if (representation[index] === \"e\" || representation[index] === \"E\") {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2]) return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index]) return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        } else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while(representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === \"0\"){\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        } else {\n            exponent = exponent - radixPosition;\n        }\n        while(exponent > EXPONENT_MAX){\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, \"overflow\");\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                } else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    const digitsString = digits.join(\"\");\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for(let i = firstNonZero + lastDigit + 2; i < endOfString; i++){\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for(; dIdx >= 0; dIdx--){\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                } else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, \"exponent underflow\");\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== \"0\" && significantDigits !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    nDigits = nDigits - 1;\n                } else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, \"inexact rounding\");\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        } else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        } else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit - 17; dIdx++){\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString(\"100000000000000000\"));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = {\n            low: Long.fromNumber(0),\n            high: Long.fromNumber(0)\n        };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        } else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString(\"9223372036854775808\"));\n        }\n        const buffer = ByteUtils.allocateUnsafe(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = dec.low.low >> 8 & 0xff;\n        buffer[index++] = dec.low.low >> 16 & 0xff;\n        buffer[index++] = dec.low.low >> 24 & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = dec.low.high >> 8 & 0xff;\n        buffer[index++] = dec.low.high >> 16 & 0xff;\n        buffer[index++] = dec.low.high >> 24 & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = dec.high.low >> 8 & 0xff;\n        buffer[index++] = dec.high.low >> 16 & 0xff;\n        buffer[index++] = dec.high.low >> 24 & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = dec.high.high >> 8 & 0xff;\n        buffer[index++] = dec.high.high >> 16 & 0xff;\n        buffer[index++] = dec.high.high >> 24 & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for(let i = 0; i < significand.length; i++)significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = {\n            parts: [\n                0,\n                0,\n                0,\n                0\n            ]\n        };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push(\"-\");\n        }\n        const combination = high >> 26 & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join(\"\") + \"Infinity\";\n            } else if (combination === COMBINATION_NAN) {\n                return \"NaN\";\n            } else {\n                biased_exponent = high >> 15 & EXPONENT_MASK;\n                significand_msb = 0x08 + (high >> 14 & 0x01);\n            }\n        } else {\n            significand_msb = high >> 14 & 0x07;\n            biased_exponent = high >> 17 & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n            is_zero = true;\n        } else {\n            for(k = 3; k >= 0; k--){\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits) continue;\n                for(j = 8; j >= 0; j--){\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        } else {\n            significand_digits = 36;\n            while(!significand[index]){\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0) string.push(`E+${exponent}`);\n                else if (exponent < 0) string.push(`E${exponent}`);\n                return string.join(\"\");\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push(\".\");\n            }\n            for(let i = 0; i < significand_digits; i++){\n                string.push(`${significand[index++]}`);\n            }\n            string.push(\"E\");\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            } else {\n                string.push(`${scientific_exponent}`);\n            }\n        } else {\n            if (exponent >= 0) {\n                for(let i = 0; i < significand_digits; i++){\n                    string.push(`${significand[index++]}`);\n                }\n            } else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for(let i = 0; i < radix_position; i++){\n                        string.push(`${significand[index++]}`);\n                    }\n                } else {\n                    string.push(\"0\");\n                }\n                string.push(\".\");\n                while(radix_position++ < 0){\n                    string.push(\"0\");\n                }\n                for(let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++){\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join(\"\");\n    }\n    toJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    toExtendedJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const d128string = inspect(this.toString(), options);\n        return `new Decimal128(${d128string})`;\n    }\n}\nclass Double extends BSONValue {\n    get _bsontype() {\n        return \"Double\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return {\n                $numberDouble: \"-0.0\"\n            };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Double(${inspect(this.value, options)})`;\n    }\n}\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return \"Int32\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy)) return this.value;\n        return {\n            $numberInt: this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Int32(${inspect(this.value, options)})`;\n    }\n}\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return \"MaxKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $maxKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    inspect() {\n        return \"new MaxKey()\";\n    }\n}\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return \"MinKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $minKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    inspect() {\n        return \"new MinKey()\";\n    }\n}\nconst FLOAT = new Float64Array(1);\nconst FLOAT_BYTES = new Uint8Array(FLOAT.buffer, 0, 8);\nFLOAT[0] = -1;\nconst isBigEndian = FLOAT_BYTES[7] === 0;\nconst NumberUtils = {\n    getNonnegativeInt32LE (source, offset) {\n        if (source[offset + 3] > 127) {\n            throw new RangeError(`Size cannot be negative at offset: ${offset}`);\n        }\n        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;\n    },\n    getInt32LE (source, offset) {\n        return source[offset] | source[offset + 1] << 8 | source[offset + 2] << 16 | source[offset + 3] << 24;\n    },\n    getUint32LE (source, offset) {\n        return source[offset] + source[offset + 1] * 256 + source[offset + 2] * 65536 + source[offset + 3] * 16777216;\n    },\n    getUint32BE (source, offset) {\n        return source[offset + 3] + source[offset + 2] * 256 + source[offset + 1] * 65536 + source[offset] * 16777216;\n    },\n    getBigInt64LE (source, offset) {\n        const lo = NumberUtils.getUint32LE(source, offset);\n        const hi = NumberUtils.getUint32LE(source, offset + 4);\n        return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    },\n    getFloat64LE: isBigEndian ? (source, offset)=>{\n        FLOAT_BYTES[7] = source[offset];\n        FLOAT_BYTES[6] = source[offset + 1];\n        FLOAT_BYTES[5] = source[offset + 2];\n        FLOAT_BYTES[4] = source[offset + 3];\n        FLOAT_BYTES[3] = source[offset + 4];\n        FLOAT_BYTES[2] = source[offset + 5];\n        FLOAT_BYTES[1] = source[offset + 6];\n        FLOAT_BYTES[0] = source[offset + 7];\n        return FLOAT[0];\n    } : (source, offset)=>{\n        FLOAT_BYTES[0] = source[offset];\n        FLOAT_BYTES[1] = source[offset + 1];\n        FLOAT_BYTES[2] = source[offset + 2];\n        FLOAT_BYTES[3] = source[offset + 3];\n        FLOAT_BYTES[4] = source[offset + 4];\n        FLOAT_BYTES[5] = source[offset + 5];\n        FLOAT_BYTES[6] = source[offset + 6];\n        FLOAT_BYTES[7] = source[offset + 7];\n        return FLOAT[0];\n    },\n    setInt32BE (destination, offset, value) {\n        destination[offset + 3] = value;\n        value >>>= 8;\n        destination[offset + 2] = value;\n        value >>>= 8;\n        destination[offset + 1] = value;\n        value >>>= 8;\n        destination[offset] = value;\n        return 4;\n    },\n    setInt32LE (destination, offset, value) {\n        destination[offset] = value;\n        value >>>= 8;\n        destination[offset + 1] = value;\n        value >>>= 8;\n        destination[offset + 2] = value;\n        value >>>= 8;\n        destination[offset + 3] = value;\n        return 4;\n    },\n    setBigInt64LE (destination, offset, value) {\n        const mask32bits = BigInt(4294967295);\n        let lo = Number(value & mask32bits);\n        destination[offset] = lo;\n        lo >>= 8;\n        destination[offset + 1] = lo;\n        lo >>= 8;\n        destination[offset + 2] = lo;\n        lo >>= 8;\n        destination[offset + 3] = lo;\n        let hi = Number(value >> BigInt(32) & mask32bits);\n        destination[offset + 4] = hi;\n        hi >>= 8;\n        destination[offset + 5] = hi;\n        hi >>= 8;\n        destination[offset + 6] = hi;\n        hi >>= 8;\n        destination[offset + 7] = hi;\n        return 8;\n    },\n    setFloat64LE: isBigEndian ? (destination, offset, value)=>{\n        FLOAT[0] = value;\n        destination[offset] = FLOAT_BYTES[7];\n        destination[offset + 1] = FLOAT_BYTES[6];\n        destination[offset + 2] = FLOAT_BYTES[5];\n        destination[offset + 3] = FLOAT_BYTES[4];\n        destination[offset + 4] = FLOAT_BYTES[3];\n        destination[offset + 5] = FLOAT_BYTES[2];\n        destination[offset + 6] = FLOAT_BYTES[1];\n        destination[offset + 7] = FLOAT_BYTES[0];\n        return 8;\n    } : (destination, offset, value)=>{\n        FLOAT[0] = value;\n        destination[offset] = FLOAT_BYTES[0];\n        destination[offset + 1] = FLOAT_BYTES[1];\n        destination[offset + 2] = FLOAT_BYTES[2];\n        destination[offset + 3] = FLOAT_BYTES[3];\n        destination[offset + 4] = FLOAT_BYTES[4];\n        destination[offset + 5] = FLOAT_BYTES[5];\n        destination[offset + 6] = FLOAT_BYTES[6];\n        destination[offset + 7] = FLOAT_BYTES[7];\n        return 8;\n    }\n};\nconst checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\nlet PROCESS_UNIQUE = null;\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return \"ObjectId\";\n    }\n    constructor(inputId){\n        super();\n        let workingId;\n        if (typeof inputId === \"object\" && inputId && \"id\" in inputId) {\n            if (typeof inputId.id !== \"string\" && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError(\"Argument passed in must have an id that is of type string or Buffer\");\n            }\n            if (\"toHexString\" in inputId && typeof inputId.toHexString === \"function\") {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            } else {\n                workingId = inputId.id;\n            }\n        } else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === \"number\") {\n            this.buffer = ObjectId.generate(typeof workingId === \"number\" ? workingId : undefined);\n        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this.buffer = ByteUtils.toLocalBufferType(workingId);\n        } else if (typeof workingId === \"string\") {\n            if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n                this.buffer = ByteUtils.fromHex(workingId);\n            } else {\n                throw new BSONError(\"input must be a 24 character hex string, 12 byte Uint8Array, or an integer\");\n            }\n        } else {\n            throw new BSONError(\"Argument passed in does not match the accepted types\");\n        }\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(this.id);\n        }\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(value);\n        }\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString && this.__id) {\n            return this.__id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString && !this.__id) {\n            this.__id = hexString;\n        }\n        return hexString;\n    }\n    static getInc() {\n        return ObjectId.index = (ObjectId.index + 1) % 0xffffff;\n    }\n    static generate(time) {\n        if (\"number\" !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocateUnsafe(12);\n        NumberUtils.setInt32BE(buffer, 0, time);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = inc >> 8 & 0xff;\n        buffer[9] = inc >> 16 & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        if (encoding === \"hex\") return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    static is(variable) {\n        return variable != null && typeof variable === \"object\" && \"_bsontype\" in variable && variable._bsontype === \"ObjectId\";\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (ObjectId.is(otherId)) {\n            return this.buffer[11] === otherId.buffer[11] && ByteUtils.equals(this.buffer, otherId.buffer);\n        }\n        if (typeof otherId === \"string\") {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === \"object\" && typeof otherId.toHexString === \"function\") {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString();\n            return typeof otherIdString === \"string\" && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = NumberUtils.getUint32BE(this.buffer, 0);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    serializeInto(uint8array, index) {\n        uint8array[index] = this.buffer[0];\n        uint8array[index + 1] = this.buffer[1];\n        uint8array[index + 2] = this.buffer[2];\n        uint8array[index + 3] = this.buffer[3];\n        uint8array[index + 4] = this.buffer[4];\n        uint8array[index + 5] = this.buffer[5];\n        uint8array[index + 6] = this.buffer[6];\n        uint8array[index + 7] = this.buffer[7];\n        uint8array[index + 8] = this.buffer[8];\n        uint8array[index + 9] = this.buffer[9];\n        uint8array[index + 10] = this.buffer[10];\n        uint8array[index + 11] = this.buffer[11];\n        return 12;\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.allocate(12);\n        for(let i = 11; i >= 4; i--)buffer[i] = 0;\n        NumberUtils.setInt32BE(buffer, 0, time);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError(\"hex string must be 24 characters\");\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError(\"base64 string must be 16 characters\");\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null) return false;\n        try {\n            new ObjectId(id);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString) return {\n            $oid: this.toHexString()\n        };\n        return {\n            $oid: this.toString(\"hex\")\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new ObjectId(${inspect(this.toHexString(), options)})`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)){\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === \"function\") {\n        value = value.toBSON();\n    }\n    switch(typeof value){\n        case \"string\":\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case \"number\":\n            if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case \"undefined\":\n            if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case \"boolean\":\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case \"object\":\n            if (value != null && typeof value._bsontype === \"string\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value == null || value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            } else if (value._bsontype === \"ObjectId\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            } else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Double\" || value._bsontype === \"Timestamp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (value._bsontype === \"Decimal128\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            } else if (value._bsontype === \"Code\") {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;\n                }\n            } else if (value._bsontype === \"Binary\") {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);\n                }\n            } else if (value._bsontype === \"Symbol\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;\n            } else if (value._bsontype === \"DBRef\") {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values[\"$db\"] = value.db;\n                }\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n            } else if (value._bsontype === \"BSONRegExp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;\n            }\n        case \"function\":\n            if (serializeFunctions) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;\n            }\n    }\n    return 0;\n}\nfunction alphabetize(str) {\n    return str.split(\"\").sort().join(\"\");\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return \"BSONRegExp\";\n    }\n    constructor(pattern, options){\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? \"\");\n        if (this.pattern.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for(let i = 0; i < this.options.length; i++){\n            if (!(this.options[i] === \"i\" || this.options[i] === \"m\" || this.options[i] === \"x\" || this.options[i] === \"l\" || this.options[i] === \"s\" || this.options[i] === \"u\")) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split(\"\").sort().join(\"\") : \"\";\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return {\n                $regex: this.pattern,\n                $options: this.options\n            };\n        }\n        return {\n            $regularExpression: {\n                pattern: this.pattern,\n                options: this.options\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        if (\"$regex\" in doc) {\n            if (typeof doc.$regex !== \"string\") {\n                if (doc.$regex._bsontype === \"BSONRegExp\") {\n                    return doc;\n                }\n            } else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if (\"$regularExpression\" in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    inspect(depth, options, inspect) {\n        const stylize = getStylizeFunction(options) ?? ((v)=>v);\n        inspect ??= defaultInspect;\n        const pattern = stylize(inspect(this.pattern), \"regexp\");\n        const flags = stylize(inspect(this.options), \"regexp\");\n        return `new BSONRegExp(${pattern}, ${flags})`;\n    }\n}\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return \"BSONSymbol\";\n    }\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return {\n            $symbol: this.value\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new BSONSymbol(${inspect(this.value, options)})`;\n    }\n}\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return \"Timestamp\";\n    }\n    constructor(low){\n        if (low == null) {\n            super(0, 0, true);\n        } else if (typeof low === \"bigint\") {\n            super(low, true);\n        } else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        } else if (typeof low === \"object\" && \"t\" in low && \"i\" in low) {\n            if (typeof low.t !== \"number\" && (typeof low.t !== \"object\" || low.t._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t as a number\");\n            }\n            if (typeof low.i !== \"number\" && (typeof low.i !== \"object\" || low.i._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i as a number\");\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive t\");\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive i\");\n            }\n            if (t > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t equal or less than uint32 max\");\n            }\n            if (i > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i equal or less than uint32 max\");\n            }\n            super(i, t, true);\n        } else {\n            throw new BSONError(\"A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }\");\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({\n            i: lowBits,\n            t: highBits\n        });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return {\n            $timestamp: {\n                t: this.high >>> 0,\n                i: this.low >>> 0\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;\n        return new Timestamp({\n            t,\n            i\n        });\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const t = inspect(this.high >>> 0, options);\n        const i = inspect(this.low >>> 0, options);\n        return `new Timestamp({ t: ${t}, i: ${i} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = NumberUtils.getInt32LE(buffer, index);\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options[\"fieldsAsRaw\"] == null ? null : options[\"fieldsAsRaw\"];\n    const raw = options[\"raw\"] == null ? false : options[\"raw\"];\n    const bsonRegExp = typeof options[\"bsonRegExp\"] === \"boolean\" ? options[\"bsonRegExp\"] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    const validation = options.validation == null ? {\n        utf8: true\n    } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    let utf8KeysSet;\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === \"boolean\") {\n        validationSetting = utf8ValidatedKeys;\n    } else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError(\"UTF-8 validation setting cannot be empty\");\n        }\n        if (typeof utf8ValidationValues[0] !== \"boolean\") {\n            throw new BSONError(\"Invalid UTF-8 validation option, must specify boolean values\");\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every((item)=>item === validationSetting)) {\n            throw new BSONError(\"Invalid UTF-8 validation option - keys must be all true or all false\");\n        }\n    }\n    if (!globalUTFValidation) {\n        utf8KeysSet = new Set();\n        for (const key of Object.keys(utf8ValidatedKeys)){\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5) throw new BSONError(\"corrupt bson message < 5 bytes long\");\n    const size = NumberUtils.getInt32LE(buffer, index);\n    index += 4;\n    if (size < 5 || size > buffer.length) throw new BSONError(\"corrupt bson message\");\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    while(!done){\n        const elementType = buffer[index++];\n        if (elementType === 0) break;\n        let i = index;\n        while(buffer[i] !== 0x00 && i < buffer.length){\n            i++;\n        }\n        if (i >= buffer.byteLength) throw new BSONError(\"Bad BSON Document: illegal CString\");\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet?.has(name)) {\n            shouldValidateKey = validationSetting;\n        } else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === \"$\") {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocateUnsafe(12);\n            for(let i = 0; i < 12; i++)oid[i] = buffer[index + i];\n            value = new ObjectId(oid);\n            index = index + 12;\n        } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(NumberUtils.getInt32LE(buffer, index));\n            index += 4;\n        } else if (elementType === BSON_DATA_INT) {\n            value = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n        } else if (elementType === BSON_DATA_NUMBER) {\n            value = NumberUtils.getFloat64LE(buffer, index);\n            index += 8;\n            if (promoteValues === false) value = new Double(value);\n        } else if (elementType === BSON_DATA_DATE) {\n            const lowBits = NumberUtils.getInt32LE(buffer, index);\n            const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n            index += 8;\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        } else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError(\"illegal boolean type value\");\n            value = buffer[index++] === 1;\n        } else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError(\"bad embedded document length in bson\");\n            if (raw) {\n                value = buffer.slice(index, index + objectSize);\n            } else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = {\n                        ...options,\n                        validation: {\n                            utf8: shouldValidateKey\n                        }\n                    };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        } else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = {\n                    ...options,\n                    raw: true\n                };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = {\n                    ...arrayOptions,\n                    validation: {\n                        utf8: shouldValidateKey\n                    }\n                };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0) throw new BSONError(\"invalid array terminator byte\");\n            if (index !== stopIndex) throw new BSONError(\"corrupted array bson\");\n        } else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        } else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        } else if (elementType === BSON_DATA_LONG) {\n            if (useBigInt64) {\n                value = NumberUtils.getBigInt64LE(buffer, index);\n                index += 8;\n            } else {\n                const lowBits = NumberUtils.getInt32LE(buffer, index);\n                const highBits = NumberUtils.getInt32LE(buffer, index + 4);\n                index += 8;\n                const long = new Long(lowBits, highBits);\n                if (promoteLongs && promoteValues === true) {\n                    value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n                } else {\n                    value = long;\n                }\n            }\n        } else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocateUnsafe(16);\n            for(let i = 0; i < 16; i++)bytes[i] = buffer[index + i];\n            index = index + 16;\n            value = new Decimal128(bytes);\n        } else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0) throw new BSONError(\"Negative binary type element size found\");\n            if (binarySize > buffer.byteLength) throw new BSONError(\"Binary type size larger than document size\");\n            if (buffer[\"slice\"] != null) {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = NumberUtils.getInt32LE(buffer, index);\n                    index += 4;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            } else {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = NumberUtils.getInt32LE(buffer, index);\n                    index += 4;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.allocateUnsafe(binarySize);\n                    for(i = 0; i < binarySize; i++){\n                        value[i] = buffer[index + i];\n                    }\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            index = index + binarySize;\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for(i = 0; i < regExpOptions.length; i++){\n                switch(regExpOptions[i]){\n                    case \"m\":\n                        optionsArray[i] = \"m\";\n                        break;\n                    case \"s\":\n                        optionsArray[i] = \"g\";\n                        break;\n                    case \"i\":\n                        optionsArray[i] = \"i\";\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(\"\"));\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        } else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_TIMESTAMP) {\n            value = new Timestamp({\n                i: NumberUtils.getUint32LE(buffer, index),\n                t: NumberUtils.getUint32LE(buffer, index + 4)\n            });\n            index += 8;\n        } else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        } else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        } else if (elementType === BSON_DATA_CODE) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError(\"code_w_scope total size shorter minimum expected length\");\n            }\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = NumberUtils.getInt32LE(buffer, index);\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too short, truncating scope\");\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too long, clips outer document\");\n            }\n            value = new Code(functionString, scopeObject);\n        } else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = NumberUtils.getInt32LE(buffer, index);\n            index += 4;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new BSONError(\"bad string length in bson\");\n            if (validation != null && validation.utf8) {\n                if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n                    throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                }\n            }\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, false);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocateUnsafe(12);\n            for(let i = 0; i < 12; i++)oidBuffer[i] = buffer[index + i];\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        } else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === \"__proto__\") {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        } else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray) throw new BSONError(\"corrupt array bson\");\n        throw new BSONError(\"corrupt object bson\");\n    }\n    if (!isPossibleDBRef) return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set([\n    \"$db\",\n    \"$ref\",\n    \"$id\",\n    \"$clusterTime\"\n]);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    NumberUtils.setInt32LE(buffer, index, size + 1);\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    if (type === BSON_DATA_INT) {\n        index += NumberUtils.setInt32LE(buffer, index, value);\n    } else {\n        index += NumberUtils.setFloat64LE(buffer, index, value);\n    }\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setBigInt64LE(buffer, index, value);\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    index += NumberUtils.setInt32LE(buffer, index, lowBits);\n    index += NumberUtils.setInt32LE(buffer, index, highBits);\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError(\"value \" + value.source + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase) buffer[index++] = 0x69;\n    if (value.global) buffer[index++] = 0x73;\n    if (value.multiline) buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError(\"pattern \" + value.pattern + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split(\"\").sort().join(\"\");\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    } else if (value._bsontype === \"MinKey\") {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    } else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += value.serializeInto(buffer, index);\n    return index;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    if (size <= 16) {\n        for(let i = 0; i < size; i++)buffer[index + i] = value[i];\n    } else {\n        buffer.set(value, index);\n    }\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError(\"Cannot convert circular structure to BSON\");\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    for(let i = 0; i < 16; i++)buffer[index + i] = value.bytes[i];\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] = value._bsontype === \"Long\" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    index += NumberUtils.setInt32LE(buffer, index, lowBits);\n    index += NumberUtils.setInt32LE(buffer, index, highBits);\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setInt32LE(buffer, index, value);\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    index += NumberUtils.setFloat64LE(buffer, index, value.value);\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    NumberUtils.setInt32LE(buffer, index, size);\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === \"object\") {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        NumberUtils.setInt32LE(buffer, index, codeSize);\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        startIndex += NumberUtils.setInt32LE(buffer, startIndex, totalSize);\n        buffer[index++] = 0;\n    } else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        NumberUtils.setInt32LE(buffer, index, size);\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n    index += NumberUtils.setInt32LE(buffer, index, size);\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        index += NumberUtils.setInt32LE(buffer, index, size);\n    }\n    if (size <= 16) {\n        for(let i = 0; i < size; i++)buffer[index + i] = data[i];\n    } else {\n        buffer.set(data, index);\n    }\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    NumberUtils.setInt32LE(buffer, index, size);\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    startIndex += NumberUtils.setInt32LE(buffer, index, size);\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError(\"serialize does not support an array as the root input\");\n        }\n        if (typeof object !== \"object\") {\n            throw new BSONError(\"serialize does not support non-object as the root input\");\n        } else if (\"_bsontype\" in object && typeof object._bsontype === \"string\") {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            if (typeof value === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (typeof value === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (typeof value === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (typeof value === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (typeof value === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while(!done){\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done) continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (key.includes(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === null || value === undefined && ignoreUndefined === false) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n            if (object != null && typeof object !== \"object\") {\n                throw new BSONError(\"toBSON function did not return an object\");\n            }\n        }\n        for (const key of Object.keys(object)){\n            let value = object[key];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (key.includes(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    startingIndex += NumberUtils.setInt32LE(buffer, startingIndex, size);\n    return index;\n}\nfunction isBSONType(value) {\n    return value != null && typeof value === \"object\" && \"_bsontype\" in value && typeof value._bsontype === \"string\";\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === \"number\") {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== \"object\") return value;\n    if (value.$undefined) return null;\n    const keys = Object.keys(value).filter((k)=>k.startsWith(\"$\") && value[k] != null);\n    for(let i = 0; i < keys.length; i++){\n        const c = keysToCodecs[keys[i]];\n        if (c) return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === \"number\") date.setTime(d);\n            else if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        } else {\n            if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (Long.isLong(d)) date.setTime(d.toNumber());\n            else if (typeof d === \"number\" && options.relaxed) date.setTime(d);\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef) return v;\n        const dollarKeys = Object.keys(v).filter((k)=>k.startsWith(\"$\"));\n        let valid = true;\n        dollarKeys.forEach((k)=>{\n            if ([\n                \"$ref\",\n                \"$id\",\n                \"$db\"\n            ].indexOf(k) === -1) valid = false;\n        });\n        if (valid) return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index)=>{\n        options.seenObjects.push({\n            propertyName: `index ${index}`,\n            obj: null\n        });\n        try {\n            return serializeValue(v, options);\n        } finally{\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + \"Z\";\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value){\n            if (typeof k !== \"string\") {\n                throw new BSONError(\"Can only serialize maps with string keys\");\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === \"object\" || typeof value === \"function\") && value !== null) {\n        const index = options.seenObjects.findIndex((entry)=>entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map((entry)=>entry.propertyName);\n            const leadingPart = props.slice(0, index).map((prop)=>`${prop} -> `).join(\"\");\n            const alreadySeen = props[index];\n            const circularPart = \" -> \" + props.slice(index + 1, props.length - 1).map((prop)=>`${prop} -> `).join(\"\");\n            const current = props[props.length - 1];\n            const leadingSpace = \" \".repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = \"-\".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError(\"Converting circular structure to EJSON:\\n\" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` + `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value)) return serializeArray(value, options);\n    if (value === undefined) return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange ? {\n                $date: value.getTime()\n            } : {\n                $date: getISOString(value)\n            };\n        }\n        return options.relaxed && inRange ? {\n            $date: getISOString(value)\n        } : {\n            $date: {\n                $numberLong: value.getTime().toString()\n            }\n        };\n    }\n    if (typeof value === \"number\" && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return {\n                    $numberInt: value.toString()\n                };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return {\n                    $numberLong: value.toString()\n                };\n            }\n        }\n        return {\n            $numberDouble: Object.is(value, -0) ? \"-0.0\" : value.toString()\n        };\n    }\n    if (typeof value === \"bigint\") {\n        if (!options.relaxed) {\n            return {\n                $numberLong: BigInt.asIntN(64, value).toString()\n            };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === \"object\") return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o)=>new Binary(o.value(), o.sub_type),\n    Code: (o)=>new Code(o.code, o.scope),\n    DBRef: (o)=>new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o)=>new Decimal128(o.bytes),\n    Double: (o)=>new Double(o.value),\n    Int32: (o)=>new Int32(o.value),\n    Long: (o)=>Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: ()=>new MaxKey(),\n    MinKey: ()=>new MinKey(),\n    ObjectId: (o)=>new ObjectId(o),\n    BSONRegExp: (o)=>new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o)=>new BSONSymbol(o.value),\n    Timestamp: (o)=>Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== \"object\") throw new BSONError(\"not an object instance\");\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === \"undefined\") {\n        const _doc = {};\n        for (const name of Object.keys(doc)){\n            options.seenObjects.push({\n                propertyName: name,\n                obj: null\n            });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === \"__proto__\") {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                } else {\n                    _doc[name] = value;\n                }\n            } finally{\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    } else if (doc != null && typeof doc === \"object\" && typeof doc._bsontype === \"string\" && doc[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    } else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== \"function\") {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError(\"Unrecognized or invalid _bsontype: \" + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === \"Code\" && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        } else if (bsontype === \"DBRef\" && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    } else {\n        throw new BSONError(\"_bsontype must be a string, but was: \" + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value)=>{\n        if (key.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === \"object\") {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({\n        relaxed: true,\n        legacy: false\n    }, options, {\n        seenObjects: [\n            {\n                propertyName: \"(root)\",\n                obj: null\n            }\n        ]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\nfunction getSize(source, offset) {\n    try {\n        return NumberUtils.getNonnegativeInt32LE(source, offset);\n    } catch (cause) {\n        throw new BSONOffsetError(\"BSON size cannot be negative\", offset, {\n            cause\n        });\n    }\n}\nfunction findNull(bytes, offset) {\n    let nullTerminatorOffset = offset;\n    for(; bytes[nullTerminatorOffset] !== 0x00; nullTerminatorOffset++);\n    if (nullTerminatorOffset === bytes.length - 1) {\n        throw new BSONOffsetError(\"Null terminator not found\", offset);\n    }\n    return nullTerminatorOffset;\n}\nfunction parseToElements(bytes, startOffset = 0) {\n    startOffset ??= 0;\n    if (bytes.length < 5) {\n        throw new BSONOffsetError(`Input must be at least 5 bytes, got ${bytes.length} bytes`, startOffset);\n    }\n    const documentSize = getSize(bytes, startOffset);\n    if (documentSize > bytes.length - startOffset) {\n        throw new BSONOffsetError(`Parsed documentSize (${documentSize} bytes) does not match input length (${bytes.length} bytes)`, startOffset);\n    }\n    if (bytes[startOffset + documentSize - 1] !== 0x00) {\n        throw new BSONOffsetError(\"BSON documents must end in 0x00\", startOffset + documentSize);\n    }\n    const elements = [];\n    let offset = startOffset + 4;\n    while(offset <= documentSize + startOffset){\n        const type = bytes[offset];\n        offset += 1;\n        if (type === 0) {\n            if (offset - startOffset !== documentSize) {\n                throw new BSONOffsetError(`Invalid 0x00 type byte`, offset);\n            }\n            break;\n        }\n        const nameOffset = offset;\n        const nameLength = findNull(bytes, offset) - nameOffset;\n        offset += nameLength + 1;\n        let length;\n        if (type === 1 || type === 18 || type === 9 || type === 17) {\n            length = 8;\n        } else if (type === 16) {\n            length = 4;\n        } else if (type === 7) {\n            length = 12;\n        } else if (type === 19) {\n            length = 16;\n        } else if (type === 8) {\n            length = 1;\n        } else if (type === 10 || type === 6 || type === 127 || type === 255) {\n            length = 0;\n        } else if (type === 11) {\n            length = findNull(bytes, findNull(bytes, offset) + 1) + 1 - offset;\n        } else if (type === 3 || type === 4 || type === 15) {\n            length = getSize(bytes, offset);\n        } else if (type === 2 || type === 5 || type === 12 || type === 13 || type === 14) {\n            length = getSize(bytes, offset) + 4;\n            if (type === 5) {\n                length += 1;\n            }\n            if (type === 12) {\n                length += 12;\n            }\n        } else {\n            throw new BSONOffsetError(`Invalid 0x${type.toString(16).padStart(2, \"0\")} type byte`, offset);\n        }\n        if (length > documentSize) {\n            throw new BSONOffsetError(\"value reports length larger than document\", offset);\n        }\n        elements.push([\n            type,\n            nameOffset,\n            nameLength,\n            offset,\n            length\n        ]);\n        offset += length;\n    }\n    return elements;\n}\nconst onDemand = Object.create(null);\nonDemand.parseToElements = parseToElements;\nonDemand.ByteUtils = ByteUtils;\nonDemand.NumberUtils = NumberUtils;\nObject.freeze(onDemand);\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === \"number\" ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocateUnsafe(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === \"number\" ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({\n        allowObjectSmallerThanBufferSize: true,\n        index: 0\n    }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for(let i = 0; i < numberOfDocuments; i++){\n        const size = NumberUtils.getInt32LE(bufferData, index);\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\nvar bson = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONOffsetError: BSONOffsetError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    onDemand: onDemand,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\nexports.BSON = bson;\nexports.BSONError = BSONError;\nexports.BSONOffsetError = BSONOffsetError;\nexports.BSONRegExp = BSONRegExp;\nexports.BSONRuntimeError = BSONRuntimeError;\nexports.BSONSymbol = BSONSymbol;\nexports.BSONType = BSONType;\nexports.BSONValue = BSONValue;\nexports.BSONVersionError = BSONVersionError;\nexports.Binary = Binary;\nexports.Code = Code;\nexports.DBRef = DBRef;\nexports.Decimal128 = Decimal128;\nexports.Double = Double;\nexports.EJSON = EJSON;\nexports.Int32 = Int32;\nexports.Long = Long;\nexports.MaxKey = MaxKey;\nexports.MinKey = MinKey;\nexports.ObjectId = ObjectId;\nexports.Timestamp = Timestamp;\nexports.UUID = UUID;\nexports.calculateObjectSize = calculateObjectSize;\nexports.deserialize = deserialize;\nexports.deserializeStream = deserializeStream;\nexports.onDemand = onDemand;\nexports.serialize = serialize;\nexports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;\nexports.setInternalBufferSize = setInternalBufferSize; //# sourceMappingURL=bson.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxTQUFTQSxpQkFBaUJDLEtBQUs7SUFDM0IsT0FBTztRQUFDO1FBQXdCO0tBQTZCLENBQUNDLFFBQVEsQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0w7QUFDMUc7QUFDQSxTQUFTTSxhQUFhTixLQUFLO0lBQ3ZCLE9BQU9FLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMLFdBQVc7QUFDckQ7QUFDQSxTQUFTTyxTQUFTQyxDQUFDO0lBQ2YsT0FBT04sT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0csT0FBTztBQUNqRDtBQUNBLFNBQVNDLE1BQU1ELENBQUM7SUFDWixPQUFPTixPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRyxPQUFPO0FBQ2pEO0FBQ0EsU0FBU0UsT0FBT0YsQ0FBQztJQUNiLE9BQU9OLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNHLE9BQU87QUFDakQ7QUFDQSxTQUFTRyxlQUFlQyxDQUFDLEVBQUVDLFFBQVE7SUFDL0IsT0FBT0MsS0FBS0MsU0FBUyxDQUFDSCxHQUFHLENBQUNJLEdBQUdDO1FBQ3pCLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3ZCLE9BQU87Z0JBQUVDLGFBQWEsQ0FBQyxFQUFFRCxFQUFFLENBQUM7WUFBQztRQUNqQyxPQUNLLElBQUlSLE1BQU1RLElBQUk7WUFDZixPQUFPZixPQUFPaUIsV0FBVyxDQUFDRjtRQUM5QjtRQUNBLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLFNBQVNHLG1CQUFtQkMsT0FBTztJQUMvQixNQUFNQyxnQkFBZ0JELFdBQVcsUUFDN0IsT0FBT0EsWUFBWSxZQUNuQixhQUFhQSxXQUNiLE9BQU9BLFFBQVFFLE9BQU8sS0FBSztJQUMvQixJQUFJRCxlQUFlO1FBQ2YsT0FBT0QsUUFB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UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUs7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R0FBRyxHQUFHO1FBQ2hDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUs1TSxHQUFHLENBQUNBLEdBQUcsSUFBSSxJQUFLO1FBQ3ZDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUs1TSxHQUFHLENBQUNBLEdBQUcsSUFBSSxLQUFNO1FBQ3hDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUs1TSxHQUFHLENBQUNBLEdBQUcsSUFBSSxLQUFNO1FBQ3hDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHZ0IsSUFBSTVOLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHO1FBQ2pDN0ssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUs1TSxHQUFHLENBQUNDLElBQUksSUFBSSxJQUFLO1FBQ3hDN0ssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUs1TSxHQUFHLENBQUNDLElBQUksSUFBSSxLQUFNO1FBQ3pDN0ssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUs1TSxHQUFHLENBQUNDLElBQUksSUFBSSxLQUFNO1FBQ3pDN0ssTUFBTSxDQUFDd1gsUUFBUSxHQUFHZ0IsSUFBSTNOLElBQUksQ0FBQ0QsR0FBRyxHQUFHO1FBQ2pDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUszTSxJQUFJLENBQUNELEdBQUcsSUFBSSxJQUFLO1FBQ3hDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUszTSxJQUFJLENBQUNELEdBQUcsSUFBSSxLQUFNO1FBQ3pDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUszTSxJQUFJLENBQUNELEdBQUcsSUFBSSxLQUFNO1FBQ3pDNUssTUFBTSxDQUFDd1gsUUFBUSxHQUFHZ0IsSUFBSTNOLElBQUksQ0FBQ0EsSUFBSSxHQUFHO1FBQ2xDN0ssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUszTSxJQUFJLENBQUNBLElBQUksSUFBSSxJQUFLO1FBQ3pDN0ssTUFBTSxDQUFDd1gsUUFBUSxHQUFHLElBQUszTSxJQUFJLENBQUNBLElBQUksSUFBSSxLQUFNO1FBQzFDN0ssTUFBTSxDQUFD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QUNqQnJRLGdCQUFnQixHQUFHMFI7QUFDbkIxUixpQkFBaUIsR0FBR3NVO0FBQ3BCdFUsWUFBWSxHQUFHaEU7QUFDZmdFLDJCQUEyQixHQUFHOGU7QUFDOUI5ZSxtQkFBbUIsR0FBRzRkO0FBQ3RCNWQseUJBQXlCLEdBQUcrZTtBQUM1Qi9lLGdCQUFnQixHQUFHc2U7QUFDbkJ0ZSxpQkFBaUIsR0FBRzJkO0FBQ3BCM2QsbUNBQW1DLEdBQUc0ZTtBQUN0QzVlLDZCQUE2QixHQUFHd2UsdUJBQ2hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2xpb25lei1uZXh0anMvLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janM/M2ZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gWydbb2JqZWN0IEFycmF5QnVmZmVyXScsICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSddLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmZ1bmN0aW9uIGlzTWFwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZnVuY3Rpb24gZGVmYXVsdEluc3BlY3QoeCwgX29wdGlvbnMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IGAke3Z9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWFwKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGl6ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsaXplRXhpc3RzID0gb3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnc3R5bGl6ZScgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zdHlsaXplID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChzdHlsaXplRXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemU7XG4gICAgfVxufVxuXG5jb25zdCBCU09OX01BSk9SX1ZFUlNJT04gPSA2O1xuY29uc3QgQlNPTl9JTlQzMl9NQVggPSAweDdmZmZmZmZmO1xuY29uc3QgQlNPTl9JTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbmNvbnN0IEJTT05fSU5UNjRfTUFYID0gTWF0aC5wb3coMiwgNjMpIC0gMTtcbmNvbnN0IEJTT05fSU5UNjRfTUlOID0gLU1hdGgucG93KDIsIDYzKTtcbmNvbnN0IEpTX0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5jb25zdCBKU19JTlRfTUlOID0gLU1hdGgucG93KDIsIDUzKTtcbmNvbnN0IEJTT05fREFUQV9OVU1CRVIgPSAxO1xuY29uc3QgQlNPTl9EQVRBX1NUUklORyA9IDI7XG5jb25zdCBCU09OX0RBVEFfT0JKRUNUID0gMztcbmNvbnN0IEJTT05fREFUQV9BUlJBWSA9IDQ7XG5jb25zdCBCU09OX0RBVEFfQklOQVJZID0gNTtcbmNvbnN0IEJTT05fREFUQV9VTkRFRklORUQgPSA2O1xuY29uc3QgQlNPTl9EQVRBX09JRCA9IDc7XG5jb25zdCBCU09OX0RBVEFfQk9PTEVBTiA9IDg7XG5jb25zdCBCU09OX0RBVEFfREFURSA9IDk7XG5jb25zdCBCU09OX0RBVEFfTlVMTCA9IDEwO1xuY29uc3QgQlNPTl9EQVRBX1JFR0VYUCA9IDExO1xuY29uc3QgQlNPTl9EQVRBX0RCUE9JTlRFUiA9IDEyO1xuY29uc3QgQlNPTl9EQVRBX0NPREUgPSAxMztcbmNvbnN0IEJTT05fREFUQV9TWU1CT0wgPSAxNDtcbmNvbnN0IEJTT05fREFUQV9DT0RFX1dfU0NPUEUgPSAxNTtcbmNvbnN0IEJTT05fREFUQV9JTlQgPSAxNjtcbmNvbnN0IEJTT05fREFUQV9USU1FU1RBTVAgPSAxNztcbmNvbnN0IEJTT05fREFUQV9MT05HID0gMTg7XG5jb25zdCBCU09OX0RBVEFfREVDSU1BTDEyOCA9IDE5O1xuY29uc3QgQlNPTl9EQVRBX01JTl9LRVkgPSAweGZmO1xuY29uc3QgQlNPTl9EQVRBX01BWF9LRVkgPSAweDdmO1xuY29uc3QgQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUID0gMDtcbmNvbnN0IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPSA0O1xuY29uc3QgQlNPTlR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBkb3VibGU6IDEsXG4gICAgc3RyaW5nOiAyLFxuICAgIG9iamVjdDogMyxcbiAgICBhcnJheTogNCxcbiAgICBiaW5EYXRhOiA1LFxuICAgIHVuZGVmaW5lZDogNixcbiAgICBvYmplY3RJZDogNyxcbiAgICBib29sOiA4LFxuICAgIGRhdGU6IDksXG4gICAgbnVsbDogMTAsXG4gICAgcmVnZXg6IDExLFxuICAgIGRiUG9pbnRlcjogMTIsXG4gICAgamF2YXNjcmlwdDogMTMsXG4gICAgc3ltYm9sOiAxNCxcbiAgICBqYXZhc2NyaXB0V2l0aFNjb3BlOiAxNSxcbiAgICBpbnQ6IDE2LFxuICAgIHRpbWVzdGFtcDogMTcsXG4gICAgbG9uZzogMTgsXG4gICAgZGVjaW1hbDogMTksXG4gICAgbWluS2V5OiAtMSxcbiAgICBtYXhLZXk6IDEyN1xufSk7XG5cbmNsYXNzIEJTT05FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgYnNvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTkVycm9yJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQlNPTkVycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2Jzb25FcnJvcicgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLmJzb25FcnJvciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgJ25hbWUnIGluIHZhbHVlICYmXG4gICAgICAgICAgICAnbWVzc2FnZScgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgICdzdGFjaycgaW4gdmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIEJTT05WZXJzaW9uRXJyb3IgZXh0ZW5kcyBCU09ORXJyb3Ige1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05WZXJzaW9uRXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIEJTT04gdmVyc2lvbiwgYnNvbiB0eXBlcyBtdXN0IGJlIGZyb20gYnNvbiAke0JTT05fTUFKT1JfVkVSU0lPTn0ueC54YCk7XG4gICAgfVxufVxuY2xhc3MgQlNPTlJ1bnRpbWVFcnJvciBleHRlbmRzIEJTT05FcnJvciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTlJ1bnRpbWVFcnJvcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuY2xhc3MgQlNPTk9mZnNldEVycm9yIGV4dGVuZHMgQlNPTkVycm9yIHtcbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OT2Zmc2V0RXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoYCR7bWVzc2FnZX0uIG9mZnNldDogJHtvZmZzZXR9YCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbn1cblxuY29uc3QgRklSU1RfQklUID0gMHg4MDtcbmNvbnN0IEZJUlNUX1RXT19CSVRTID0gMHhjMDtcbmNvbnN0IEZJUlNUX1RIUkVFX0JJVFMgPSAweGUwO1xuY29uc3QgRklSU1RfRk9VUl9CSVRTID0gMHhmMDtcbmNvbnN0IEZJUlNUX0ZJVkVfQklUUyA9IDB4Zjg7XG5jb25zdCBUV09fQklUX0NIQVIgPSAweGMwO1xuY29uc3QgVEhSRUVfQklUX0NIQVIgPSAweGUwO1xuY29uc3QgRk9VUl9CSVRfQ0hBUiA9IDB4ZjA7XG5jb25zdCBDT05USU5VSU5HX0NIQVIgPSAweDgwO1xuZnVuY3Rpb24gdmFsaWRhdGVVdGY4KGJ5dGVzLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IGNvbnRpbnVhdGlvbiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgYnl0ZSA9IGJ5dGVzW2ldO1xuICAgICAgICBpZiAoY29udGludWF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoKGJ5dGUgJiBGSVJTVF9UV09fQklUUykgIT09IENPTlRJTlVJTkdfQ0hBUikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVhdGlvbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGUgJiBGSVJTVF9CSVQpIHtcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIEZJUlNUX1RIUkVFX0JJVFMpID09PSBUV09fQklUX0NIQVIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb24gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKGJ5dGUgJiBGSVJTVF9GT1VSX0JJVFMpID09PSBUSFJFRV9CSVRfQ0hBUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbiA9IDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYnl0ZSAmIEZJUlNUX0ZJVkVfQklUUykgPT09IEZPVVJfQklUX0NIQVIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51YXRpb24gPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhY29udGludWF0aW9uO1xufVxuXG5mdW5jdGlvbiB0cnlSZWFkQmFzaWNMYXRpbih1aW50OGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHVpbnQ4YXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nQnl0ZUxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICAgIGlmIChzdHJpbmdCeXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHN0cmluZ0J5dGVMZW5ndGggPiAyMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0cmluZ0J5dGVMZW5ndGggPT09IDEgJiYgdWludDhhcnJheVtzdGFydF0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhhcnJheVtzdGFydF0pO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nQnl0ZUxlbmd0aCA9PT0gMiAmJiB1aW50OGFycmF5W3N0YXJ0XSA8IDEyOCAmJiB1aW50OGFycmF5W3N0YXJ0ICsgMV0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhhcnJheVtzdGFydF0pICsgU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0ICsgMV0pO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nQnl0ZUxlbmd0aCA9PT0gMyAmJlxuICAgICAgICB1aW50OGFycmF5W3N0YXJ0XSA8IDEyOCAmJlxuICAgICAgICB1aW50OGFycmF5W3N0YXJ0ICsgMV0gPCAxMjggJiZcbiAgICAgICAgdWludDhhcnJheVtzdGFydCArIDJdIDwgMTI4KSB7XG4gICAgICAgIHJldHVybiAoU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0XSkgK1xuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0ICsgMV0pICtcbiAgICAgICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUodWludDhhcnJheVtzdGFydCArIDJdKSk7XG4gICAgfVxuICAgIGNvbnN0IGxhdGluQnl0ZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICBjb25zdCBieXRlID0gdWludDhhcnJheVtpXTtcbiAgICAgICAgaWYgKGJ5dGUgPiAxMjcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxhdGluQnl0ZXMucHVzaChieXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubGF0aW5CeXRlcyk7XG59XG5mdW5jdGlvbiB0cnlXcml0ZUJhc2ljTGF0aW4oZGVzdGluYXRpb24sIHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmIChzb3VyY2UubGVuZ3RoID4gMjUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChkZXN0aW5hdGlvbi5sZW5ndGggLSBvZmZzZXQgPCBzb3VyY2UubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKGxldCBjaGFyT2Zmc2V0ID0gMCwgZGVzdGluYXRpb25PZmZzZXQgPSBvZmZzZXQ7IGNoYXJPZmZzZXQgPCBzb3VyY2UubGVuZ3RoOyBjaGFyT2Zmc2V0KyssIGRlc3RpbmF0aW9uT2Zmc2V0KyspIHtcbiAgICAgICAgY29uc3QgY2hhciA9IHNvdXJjZS5jaGFyQ29kZUF0KGNoYXJPZmZzZXQpO1xuICAgICAgICBpZiAoY2hhciA+IDEyNylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZXN0aW5hdGlvbltkZXN0aW5hdGlvbk9mZnNldF0gPSBjaGFyO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gbm9kZWpzTWF0aFJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShBcnJheS5mcm9tKHsgbGVuZ3RoOiBieXRlTGVuZ3RoIH0sICgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpKTtcbn1cbmNvbnN0IG5vZGVqc1JhbmRvbUJ5dGVzID0gKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc01hdGhSYW5kb21CeXRlcztcbiAgICB9XG59KSgpO1xuY29uc3Qgbm9kZUpzQnl0ZVV0aWxzID0ge1xuICAgIHRvTG9jYWxCdWZmZXJUeXBlKHBvdGVudGlhbEJ1ZmZlcikge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBvdGVudGlhbEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwb3RlbnRpYWxCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG90ZW50aWFsQnVmZmVyLmJ1ZmZlciwgcG90ZW50aWFsQnVmZmVyLmJ5dGVPZmZzZXQsIHBvdGVudGlhbEJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdUYWcgPSBwb3RlbnRpYWxCdWZmZXI/LltTeW1ib2wudG9TdHJpbmdUYWddID8/IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwb3RlbnRpYWxCdWZmZXIpO1xuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG90ZW50aWFsQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBDYW5ub3QgY3JlYXRlIEJ1ZmZlciBmcm9tICR7U3RyaW5nKHBvdGVudGlhbEJ1ZmZlcil9YCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZVVuc2FmZShzaXplKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGEpLmVxdWFscyhiKTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyYXkpO1xuICAgIH0sXG4gICAgZnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICAgIH0sXG4gICAgdG9CYXNlNjQoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSxcbiAgICBmcm9tSVNPODg1OTEoY29kZVBvaW50cykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oY29kZVBvaW50cywgJ2JpbmFyeScpO1xuICAgIH0sXG4gICAgdG9JU084ODU5MShidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9LFxuICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgICB9LFxuICAgIHRvSGV4KGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0sXG4gICAgdG9VVEY4KGJ1ZmZlciwgc3RhcnQsIGVuZCwgZmF0YWwpIHtcbiAgICAgICAgY29uc3QgYmFzaWNMYXRpbiA9IGVuZCAtIHN0YXJ0IDw9IDIwID8gdHJ5UmVhZEJhc2ljTGF0aW4oYnVmZmVyLCBzdGFydCwgZW5kKSA6IG51bGw7XG4gICAgICAgIGlmIChiYXNpY0xhdGluICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNpY0xhdGluO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCd1dGY4Jywgc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChmYXRhbCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoaSkgPT09IDB4ZmZmZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlVXRmOChidWZmZXIsIHN0YXJ0LCBlbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdJbnZhbGlkIFVURi04IHN0cmluZyBpbiBCU09OIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfSxcbiAgICB1dGY4Qnl0ZUxlbmd0aChpbnB1dCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoaW5wdXQsICd1dGY4Jyk7XG4gICAgfSxcbiAgICBlbmNvZGVVVEY4SW50byhidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBsYXRpbkJ5dGVzV3JpdHRlbiA9IHRyeVdyaXRlQmFzaWNMYXRpbihidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCk7XG4gICAgICAgIGlmIChsYXRpbkJ5dGVzV3JpdHRlbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF0aW5CeXRlc1dyaXR0ZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLndyaXRlKHNvdXJjZSwgYnl0ZU9mZnNldCwgdW5kZWZpbmVkLCAndXRmOCcpO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IG5vZGVqc1JhbmRvbUJ5dGVzXG59O1xuXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICAgIGNvbnN0IHsgbmF2aWdhdG9yIH0gPSBnbG9iYWxUaGlzO1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcbn1cbmZ1bmN0aW9uIHdlYk1hdGhSYW5kb21CeXRlcyhieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgYXJndW1lbnQgJ2J5dGVMZW5ndGgnIGlzIGludmFsaWQuIFJlY2VpdmVkICR7Ynl0ZUxlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlYkJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoQXJyYXkuZnJvbSh7IGxlbmd0aDogYnl0ZUxlbmd0aCB9LCAoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKSk7XG59XG5jb25zdCB3ZWJSYW5kb21CeXRlcyA9ICgoKSA9PiB7XG4gICAgY29uc3QgeyBjcnlwdG8gfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKGNyeXB0byAhPSBudWxsICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoYnl0ZUxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMod2ViQnl0ZVV0aWxzLmFsbG9jYXRlKGJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uc29sZSB9ID0gZ2xvYmFsVGhpcztcbiAgICAgICAgICAgIGNvbnNvbGU/Lndhcm4/LignQlNPTjogRm9yIFJlYWN0IE5hdGl2ZSBwbGVhc2UgcG9seWZpbGwgY3J5cHRvLmdldFJhbmRvbVZhbHVlcywgZS5nLiB1c2luZzogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtbmF0aXZlLWdldC1yYW5kb20tdmFsdWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWJNYXRoUmFuZG9tQnl0ZXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IEhFWF9ESUdJVCA9IC8oXFxkfFthLWZdKS9pO1xuY29uc3Qgd2ViQnl0ZVV0aWxzID0ge1xuICAgIHRvTG9jYWxCdWZmZXJUeXBlKHBvdGVudGlhbFVpbnQ4YXJyYXkpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nVGFnID0gcG90ZW50aWFsVWludDhhcnJheT8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPz9cbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwb3RlbnRpYWxVaW50OGFycmF5KTtcbiAgICAgICAgaWYgKHN0cmluZ1RhZyA9PT0gJ1VpbnQ4QXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsVWludDhhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBvdGVudGlhbFVpbnQ4YXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsVWludDhhcnJheS5idWZmZXIuc2xpY2UocG90ZW50aWFsVWludDhhcnJheS5ieXRlT2Zmc2V0LCBwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVPZmZzZXQgKyBwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsVWludDhhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQ2Fubm90IG1ha2UgYSBVaW50OEFycmF5IGZyb20gJHtTdHJpbmcocG90ZW50aWFsVWludDhhcnJheSl9YCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCAke1N0cmluZyhzaXplKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZVVuc2FmZShzaXplKSB7XG4gICAgICAgIHJldHVybiB3ZWJCeXRlVXRpbHMuYWxsb2NhdGUoc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFycmF5KTtcbiAgICB9LFxuICAgIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjQpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgfSxcbiAgICB0b0Jhc2U2NCh1aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBidG9hKHdlYkJ5dGVVdGlscy50b0lTTzg4NTkxKHVpbnQ4YXJyYXkpKTtcbiAgICB9LFxuICAgIGZyb21JU084ODU5MShjb2RlUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29kZVBvaW50cywgYyA9PiBjLmNoYXJDb2RlQXQoMCkgJiAweGZmKTtcbiAgICB9LFxuICAgIHRvSVNPODg1OTEodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShVaW50MTZBcnJheS5mcm9tKHVpbnQ4YXJyYXkpLCBiID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgZXZlbkxlbmd0aEhleCA9IGhleC5sZW5ndGggJSAyID09PSAwID8gaGV4IDogaGV4LnNsaWNlKDAsIGhleC5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbkxlbmd0aEhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IGV2ZW5MZW5ndGhIZXhbaV07XG4gICAgICAgICAgICBjb25zdCBzZWNvbmREaWdpdCA9IGV2ZW5MZW5ndGhIZXhbaSArIDFdO1xuICAgICAgICAgICAgaWYgKCFIRVhfRElHSVQudGVzdChmaXJzdERpZ2l0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFIRVhfRElHSVQudGVzdChzZWNvbmREaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleERpZ2l0ID0gTnVtYmVyLnBhcnNlSW50KGAke2ZpcnN0RGlnaXR9JHtzZWNvbmREaWdpdH1gLCAxNik7XG4gICAgICAgICAgICBidWZmZXIucHVzaChoZXhEaWdpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICAgIH0sXG4gICAgdG9IZXgodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh1aW50OGFycmF5LCBieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgdG9VVEY4KHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQsIGZhdGFsKSB7XG4gICAgICAgIGNvbnN0IGJhc2ljTGF0aW4gPSBlbmQgLSBzdGFydCA8PSAyMCA/IHRyeVJlYWRCYXNpY0xhdGluKHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQpIDogbnVsbDtcbiAgICAgICAgaWYgKGJhc2ljTGF0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2ljTGF0aW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsIH0pLmRlY29kZSh1aW50OGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggc3RyaW5nIGluIEJTT04gZG9jdW1lbnQnLCB7IGNhdXNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsIH0pLmRlY29kZSh1aW50OGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICB9LFxuICAgIHV0ZjhCeXRlTGVuZ3RoKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoaW5wdXQpLmJ5dGVMZW5ndGg7XG4gICAgfSxcbiAgICBlbmNvZGVVVEY4SW50byh1aW50OGFycmF5LCBzb3VyY2UsIGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc291cmNlKTtcbiAgICAgICAgdWludDhhcnJheS5zZXQoYnl0ZXMsIGJ5dGVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICB9LFxuICAgIHJhbmRvbUJ5dGVzOiB3ZWJSYW5kb21CeXRlc1xufTtcblxuY29uc3QgaGFzR2xvYmFsQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBCdWZmZXIucHJvdG90eXBlPy5faXNCdWZmZXIgIT09IHRydWU7XG5jb25zdCBCeXRlVXRpbHMgPSBoYXNHbG9iYWxCdWZmZXIgPyBub2RlSnNCeXRlVXRpbHMgOiB3ZWJCeXRlVXRpbHM7XG5cbmNsYXNzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IFtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0oKSB7XG4gICAgICAgIHJldHVybiBCU09OX01BSk9SX1ZFUlNJT047XG4gICAgfVxuICAgIFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXShkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KTtcbiAgICB9XG59XG5cbmNsYXNzIEJpbmFyeSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdCaW5hcnknO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIHN1YlR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKCEoYnVmZmVyID09IG51bGwpICYmXG4gICAgICAgICAgICB0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgIUFycmF5QnVmZmVyLmlzVmlldyhidWZmZXIpICYmXG4gICAgICAgICAgICAhaXNBbnlBcnJheUJ1ZmZlcihidWZmZXIpICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgY2FuIG9ubHkgYmUgY29uc3RydWN0ZWQgZnJvbSBVaW50OEFycmF5IG9yIG51bWJlcltdJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJfdHlwZSA9IHN1YlR5cGUgPz8gQmluYXJ5LkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDtcbiAgICAgICAgaWYgKGJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShCaW5hcnkuQlVGRkVSX1NJWkUpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEFycmF5LmlzQXJyYXkoYnVmZmVyKVxuICAgICAgICAgICAgICAgID8gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShidWZmZXIpXG4gICAgICAgICAgICAgICAgOiBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSB0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1dChieXRlVmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlVmFsdWUgPT09ICdzdHJpbmcnICYmIGJ5dGVWYWx1ZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29ubHkgYWNjZXB0cyBzaW5nbGUgY2hhcmFjdGVyIFN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBieXRlVmFsdWUgIT09ICdudW1iZXInICYmIGJ5dGVWYWx1ZS5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvbmx5IGFjY2VwdHMgc2luZ2xlIGNoYXJhY3RlciBVaW50OEFycmF5IG9yIEFycmF5Jyk7XG4gICAgICAgIGxldCBkZWNvZGVkQnl0ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkZWNvZGVkQnl0ZSA9IGJ5dGVWYWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBieXRlVmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBkZWNvZGVkQnl0ZSA9IGJ5dGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlY29kZWRCeXRlID0gYnl0ZVZhbHVlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWNvZGVkQnl0ZSA8IDAgfHwgZGVjb2RlZEJ5dGUgPiAyNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ29ubHkgYWNjZXB0cyBudW1iZXIgaW4gYSB2YWxpZCB1bnNpZ25lZCBieXRlIHJhbmdlIDAtMjU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGggPiB0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gZGVjb2RlZEJ5dGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFjZSA9IEJ5dGVVdGlscy5hbGxvY2F0ZShCaW5hcnkuQlVGRkVSX1NJWkUgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3U3BhY2Uuc2V0KHRoaXMuYnVmZmVyLCAwKTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbmV3U3BhY2U7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclt0aGlzLnBvc2l0aW9uKytdID0gZGVjb2RlZEJ5dGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGUoc2VxdWVuY2UsIG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoIDwgb2Zmc2V0ICsgc2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTcGFjZSA9IEJ5dGVVdGlscy5hbGxvY2F0ZSh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoICsgc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld1NwYWNlLnNldCh0aGlzLmJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld1NwYWNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc2VxdWVuY2UpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5zZXQoQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKHNlcXVlbmNlKSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPVxuICAgICAgICAgICAgICAgIG9mZnNldCArIHNlcXVlbmNlLmJ5dGVMZW5ndGggPiB0aGlzLnBvc2l0aW9uID8gb2Zmc2V0ICsgc2VxdWVuY2UubGVuZ3RoIDogdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VxdWVuY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdpbnB1dCBjYW5ub3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZChwb3NpdGlvbiwgbGVuZ3RoKSB7XG4gICAgICAgIGxlbmd0aCA9IGxlbmd0aCAmJiBsZW5ndGggPiAwID8gbGVuZ3RoIDogdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgfVxuICAgIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoID09PSB0aGlzLnBvc2l0aW9uXG4gICAgICAgICAgICA/IHRoaXMuYnVmZmVyXG4gICAgICAgICAgICA6IHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbikpO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyLnN1YmFycmF5KDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvVVRGOCh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5wb3NpdGlvbiwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvVVRGOCh0aGlzLmJ1ZmZlciwgMCwgdGhpcy5wb3NpdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIpO1xuICAgICAgICBjb25zdCBzdWJUeXBlID0gTnVtYmVyKHRoaXMuc3ViX3R5cGUpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICRiaW5hcnk6IGJhc2U2NFN0cmluZyxcbiAgICAgICAgICAgICAgICAkdHlwZTogc3ViVHlwZS5sZW5ndGggPT09IDEgPyAnMCcgKyBzdWJUeXBlIDogc3ViVHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGJpbmFyeToge1xuICAgICAgICAgICAgICAgIGJhc2U2NDogYmFzZTY0U3RyaW5nLFxuICAgICAgICAgICAgICAgIHN1YlR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9VVUlEKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfVVVJRCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVVUlEKHRoaXMuYnVmZmVyLnNsaWNlKDAsIHRoaXMucG9zaXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCaW5hcnkgc3ViX3R5cGUgXCIke3RoaXMuc3ViX3R5cGV9XCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgY29udmVydGluZyB0byBVVUlELiBPbmx5IFwiJHtCaW5hcnkuU1VCVFlQRV9VVUlEfVwiIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleCwgc3ViVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShCeXRlVXRpbHMuZnJvbUhleChoZXgpLCBzdWJUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0LCBzdWJUeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmluYXJ5KEJ5dGVVdGlscy5mcm9tQmFzZTY0KGJhc2U2NCksIHN1YlR5cGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBsZXQgdHlwZTtcbiAgICAgICAgaWYgKCckYmluYXJ5JyBpbiBkb2MpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSAmJiB0eXBlb2YgZG9jLiRiaW5hcnkgPT09ICdzdHJpbmcnICYmICckdHlwZScgaW4gZG9jKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kdHlwZSA/IHBhcnNlSW50KGRvYy4kdHlwZSwgMTYpIDogMDtcbiAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJGJpbmFyeSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGRvYy4kYmluYXJ5LnN1YlR5cGUgPyBwYXJzZUludChkb2MuJGJpbmFyeS5zdWJUeXBlLCAxNikgOiAwO1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gQnl0ZVV0aWxzLmZyb21CYXNlNjQoZG9jLiRiaW5hcnkuYmFzZTY0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJyR1dWlkJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHR5cGUgPSA0O1xuICAgICAgICAgICAgZGF0YSA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGRvYy4kdXVpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbmV4cGVjdGVkIEJpbmFyeSBFeHRlbmRlZCBKU09OIGZvcm1hdCAke0pTT04uc3RyaW5naWZ5KGRvYyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPyBuZXcgVVVJRChkYXRhKSA6IG5ldyBCaW5hcnkoZGF0YSwgdHlwZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IGJhc2U2NEFyZyA9IGluc3BlY3QoYmFzZTY0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgc3ViVHlwZUFyZyA9IGluc3BlY3QodGhpcy5zdWJfdHlwZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgQmluYXJ5LmNyZWF0ZUZyb21CYXNlNjQoJHtiYXNlNjRBcmd9LCAke3N1YlR5cGVBcmd9KWA7XG4gICAgfVxufVxuQmluYXJ5LkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCA9IDA7XG5CaW5hcnkuQlVGRkVSX1NJWkUgPSAyNTY7XG5CaW5hcnkuU1VCVFlQRV9ERUZBVUxUID0gMDtcbkJpbmFyeS5TVUJUWVBFX0ZVTkNUSU9OID0gMTtcbkJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkgPSAyO1xuQmluYXJ5LlNVQlRZUEVfVVVJRF9PTEQgPSAzO1xuQmluYXJ5LlNVQlRZUEVfVVVJRCA9IDQ7XG5CaW5hcnkuU1VCVFlQRV9NRDUgPSA1O1xuQmluYXJ5LlNVQlRZUEVfRU5DUllQVEVEID0gNjtcbkJpbmFyeS5TVUJUWVBFX0NPTFVNTiA9IDc7XG5CaW5hcnkuU1VCVFlQRV9TRU5TSVRJVkUgPSA4O1xuQmluYXJ5LlNVQlRZUEVfVVNFUl9ERUZJTkVEID0gMTI4O1xuY29uc3QgVVVJRF9CWVRFX0xFTkdUSCA9IDE2O1xuY29uc3QgVVVJRF9XSVRIT1VUX0RBU0hFUyA9IC9eWzAtOUEtRl17MzJ9JC9pO1xuY29uc3QgVVVJRF9XSVRIX0RBU0hFUyA9IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pO1xuY2xhc3MgVVVJRCBleHRlbmRzIEJpbmFyeSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBVVUlELmdlbmVyYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVVUlEKSB7XG4gICAgICAgICAgICBieXRlcyA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShuZXcgVWludDhBcnJheShpbnB1dC5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpICYmIGlucHV0LmJ5dGVMZW5ndGggPT09IFVVSURfQllURV9MRU5HVEgpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBieXRlcyA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBVVUlEIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBVVUlELCBhIDE2IGJ5dGUgQnVmZmVyIG9yIGEgMzIvMzYgY2hhcmFjdGVyIGhleCBzdHJpbmcgKGRhc2hlcyBleGNsdWRlZC9pbmNsdWRlZCwgZm9ybWF0OiB4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGJ5dGVzLCBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0hleFN0cmluZyhpbmNsdWRlRGFzaGVzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5jbHVkZURhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgNCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSg0LCA2KSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDYsIDgpKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoOCwgMTApKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoMTAsIDE2KSlcbiAgICAgICAgICAgIF0uam9pbignLScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVySWQpIHtcbiAgICAgICAgaWYgKCFvdGhlcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVySWQgaW5zdGFuY2VvZiBVVUlEKSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyhvdGhlcklkLmlkLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy5lcXVhbHMobmV3IFVVSUQob3RoZXJJZCkuaWQsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0JpbmFyeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkodGhpcy5pZCwgQmluYXJ5LlNVQlRZUEVfVVVJRCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBCeXRlVXRpbHMucmFuZG9tQnl0ZXMoVVVJRF9CWVRFX0xFTkdUSCk7XG4gICAgICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuICAgICAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZChpbnB1dCkge1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBVVUlELmlzVmFsaWRVVUlEU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVaW50OEFycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmJ5dGVMZW5ndGggPT09IFVVSURfQllURV9MRU5HVEg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbnB1dC5fYnNvbnR5cGUgPT09ICdCaW5hcnknICYmXG4gICAgICAgICAgICBpbnB1dC5zdWJfdHlwZSA9PT0gdGhpcy5TVUJUWVBFX1VVSUQgJiZcbiAgICAgICAgICAgIGlucHV0LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAxNik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBVVUlELmJ5dGVzRnJvbVN0cmluZyhoZXhTdHJpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQoYnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGJ5dGVzRnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICBpZiAoIVVVSUQuaXNWYWxpZFVVSURTdHJpbmcocmVwcmVzZW50YXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdVVUlEIHN0cmluZyByZXByZXNlbnRhdGlvbiBtdXN0IGJlIDMyIGhleCBkaWdpdHMgb3IgY2Fub25pY2FsIGh5cGhlbmF0ZWQgcmVwcmVzZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmZyb21IZXgocmVwcmVzZW50YXRpb24ucmVwbGFjZSgvLS9nLCAnJykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZFVVSURTdHJpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFVVSURfV0lUSE9VVF9EQVNIRVMudGVzdChyZXByZXNlbnRhdGlvbikgfHwgVVVJRF9XSVRIX0RBU0hFUy50ZXN0KHJlcHJlc2VudGF0aW9uKTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgVVVJRCgke2luc3BlY3QodGhpcy50b0hleFN0cmluZygpLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIENvZGUgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnQ29kZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHNjb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlID8/IG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29kZTogdGhpcy5jb2RlLCBzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMuY29kZSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUsICRzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZShkb2MuJGNvZGUsIGRvYy4kc2NvcGUpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBsZXQgcGFyYW1ldGVyc1N0cmluZyA9IGluc3BlY3QodGhpcy5jb2RlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbXVsdGlMaW5lRm4gPSBwYXJhbWV0ZXJzU3RyaW5nLmluY2x1ZGVzKCdcXG4nKTtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1ldGVyc1N0cmluZyArPSBgLCR7bXVsdGlMaW5lRm4gPyAnXFxuJyA6ICcgJ30ke2luc3BlY3QodGhpcy5zY29wZSwgb3B0aW9ucyl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRpbmdOZXdsaW5lID0gbXVsdGlMaW5lRm4gJiYgdGhpcy5zY29wZSA9PT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGBuZXcgQ29kZSgke211bHRpTGluZUZuID8gJ1xcbicgOiAnJ30ke3BhcmFtZXRlcnNTdHJpbmd9JHtlbmRpbmdOZXdsaW5lID8gJ1xcbicgOiAnJ30pYDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzREJSZWZMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJyRpZCcgaW4gdmFsdWUgJiZcbiAgICAgICAgdmFsdWUuJGlkICE9IG51bGwgJiZcbiAgICAgICAgJyRyZWYnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS4kcmVmID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAoISgnJGRiJyBpbiB2YWx1ZSkgfHwgKCckZGInIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS4kZGIgPT09ICdzdHJpbmcnKSkpO1xufVxuY2xhc3MgREJSZWYgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnREJSZWYnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBvaWQsIGRiLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBjb2xsZWN0aW9uLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGRiID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMub2lkID0gb2lkO1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzIHx8IHt9O1xuICAgIH1cbiAgICBnZXQgbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgbmFtZXNwYWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICRyZWY6IHRoaXMuY29sbGVjdGlvbixcbiAgICAgICAgICAgICRpZDogdGhpcy5vaWRcbiAgICAgICAgfSwgdGhpcy5maWVsZHMpO1xuICAgICAgICBpZiAodGhpcy5kYiAhPSBudWxsKVxuICAgICAgICAgICAgby4kZGIgPSB0aGlzLmRiO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IG8gPSB7XG4gICAgICAgICAgICAkcmVmOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAkaWQ6IHRoaXMub2lkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGIpXG4gICAgICAgICAgICBvLiRkYiA9IHRoaXMuZGI7XG4gICAgICAgIG8gPSBPYmplY3QuYXNzaWduKG8sIHRoaXMuZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZG9jKTtcbiAgICAgICAgZGVsZXRlIGNvcHkuJHJlZjtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGlkO1xuICAgICAgICBkZWxldGUgY29weS4kZGI7XG4gICAgICAgIHJldHVybiBuZXcgREJSZWYoZG9jLiRyZWYsIGRvYy4kaWQsIGRvYy4kZGIsIGNvcHkpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgaW5zcGVjdCh0aGlzLm5hbWVzcGFjZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBpbnNwZWN0KHRoaXMub2lkLCBvcHRpb25zKSxcbiAgICAgICAgICAgIC4uLih0aGlzLmRiID8gW2luc3BlY3QodGhpcy5kYiwgb3B0aW9ucyldIDogW10pLFxuICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKS5sZW5ndGggPiAwID8gW2luc3BlY3QodGhpcy5maWVsZHMsIG9wdGlvbnMpXSA6IFtdKVxuICAgICAgICBdO1xuICAgICAgICBhcmdzWzFdID0gaW5zcGVjdCA9PT0gZGVmYXVsdEluc3BlY3QgPyBgbmV3IE9iamVjdElkKCR7YXJnc1sxXX0pYCA6IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBgbmV3IERCUmVmKCR7YXJncy5qb2luKCcsICcpfSlgO1xuICAgIH1cbn1cblxubGV0IHdhc20gPSB1bmRlZmluZWQ7XG50cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xufVxuY2F0Y2gge1xufVxuY29uc3QgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuY29uc3QgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuY29uc3QgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuY29uc3QgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG5jb25zdCBJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IFVJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIID0gMjA7XG5jb25zdCBERUNJTUFMX1JFR19FWCA9IC9eKFxcKz8wfChcXCt8LSk/WzEtOV1bMC05XSopJC87XG5jbGFzcyBMb25nIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0xvbmcnO1xuICAgIH1cbiAgICBnZXQgX19pc0xvbmdfXygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvdyA9IDAsIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbG93ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBMb25nLmZyb21CaWdJbnQobG93LCAhIWhpZ2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBMb25nLmZyb21TdHJpbmcobG93LCAhIWhpZ2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICAgICAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIGxldCBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGUpXG4gICAgICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCksIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgaWYgKHN0ciA9PT0gJ05hTicgfHwgc3RyID09PSAnSW5maW5pdHknIHx8IHN0ciA9PT0gJytJbmZpbml0eScgfHwgc3RyID09PSAnLUluZmluaXR5JylcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAocmFkaXggPSB1bnNpZ25lZCksICh1bnNpZ25lZCA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICAgICAgfVxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDgpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IExvbmcuWkVSTztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgICAgICAgICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCBzaXplKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoTG9uZy5mcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICAgICAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgKGJ5dGVzWzFdIDw8IDgpIHwgKGJ5dGVzWzJdIDw8IDE2KSB8IChieXRlc1szXSA8PCAyNCksIGJ5dGVzWzRdIHwgKGJ5dGVzWzVdIDw8IDgpIHwgKGJ5dGVzWzZdIDw8IDE2KSB8IChieXRlc1s3XSA8PCAyNCksIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcoKGJ5dGVzWzRdIDw8IDI0KSB8IChieXRlc1s1XSA8PCAxNikgfCAoYnl0ZXNbNl0gPDwgOCkgfCBieXRlc1s3XSwgKGJ5dGVzWzBdIDw8IDI0KSB8IChieXRlc1sxXSA8PCAxNikgfCAoYnl0ZXNbMl0gPDwgOCkgfCBieXRlc1szXSwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNMb25nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ19faXNMb25nX18nIGluIHZhbHVlICYmXG4gICAgICAgICAgICB2YWx1ZS5fX2lzTG9uZ19fID09PSB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgYWRkKGFkZGVuZCkge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGFkZGVuZCkpXG4gICAgICAgICAgICBhZGRlbmQgPSBMb25nLmZyb21WYWx1ZShhZGRlbmQpO1xuICAgICAgICBjb25zdCBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjMyID0gYWRkZW5kLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBiMDAgPSBhZGRlbmQubG93ICYgMHhmZmZmO1xuICAgICAgICBsZXQgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgYW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLCBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8XG4gICAgICAgICAgICAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwKVxuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiAxO1xuICAgIH1cbiAgICBjb21wKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpO1xuICAgIH1cbiAgICBkaXZpZGUoZGl2aXNvcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IExvbmcuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcbiAgICAgICAgICAgICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgbGV0IGFwcHJveCwgcmVtLCByZXM7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoTG9uZy5PTkUpIHx8IGRpdmlzb3IuZXEoTG9uZy5ORUdfT05FKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5PTkU7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoTG9uZy5aRVJPKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gTG9uZy5PTkUgOiBMb25nLk5FR19PTkU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgICAgICAgICAgcmVzID0gTG9uZy5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5VT05FO1xuICAgICAgICAgICAgcmVzID0gTG9uZy5VWkVSTztcbiAgICAgICAgfVxuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xuICAgICAgICAgICAgY29uc3QgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IE1hdGgucG93KDIsIGxvZzIgLSA0OCk7XG4gICAgICAgICAgICBsZXQgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCk7XG4gICAgICAgICAgICBsZXQgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuT05FO1xuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGRpdihkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShkaXZpc29yKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIGdldEhpZ2hCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xuICAgIH1cbiAgICBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICAgIH1cbiAgICBnZXRMb3dCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfVxuICAgIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICAgIH1cbiAgICBnZXROdW1CaXRzQWJzKCkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5oaWdoICE9PSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgICAgIGxldCBiaXQ7XG4gICAgICAgIGZvciAoYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwO1xuICAgIH1cbiAgICBndChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbihvdGhlcik7XG4gICAgfVxuICAgIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgZ2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgaXNFdmVuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xuICAgIH1cbiAgICBpc09kZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xuICAgIH1cbiAgICBpc1Bvc2l0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICAgIH1cbiAgICBsZXNzVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8IDA7XG4gICAgfVxuICAgIGx0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKG90aGVyKTtcbiAgICB9XG4gICAgbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7XG4gICAgfVxuICAgIGx0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBtb2R1bG8oZGl2aXNvcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IExvbmcuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgY29uc3QgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gICAgfVxuICAgIG1vZChkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsbyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmVtKGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxvKGRpdmlzb3IpO1xuICAgIH1cbiAgICBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhtdWx0aXBsaWVyKSlcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBMb25nLmZyb21WYWx1ZShtdWx0aXBsaWVyKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHdhc20ubXVsKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpO1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IExvbmcuTUlOX1ZBTFVFIDogTG9uZy5aRVJPO1xuICAgICAgICBpZiAobXVsdGlwbGllci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XG4gICAgICAgIGlmICh0aGlzLmx0KExvbmcuVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChMb25nLlRXT19QV1JfMjQpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBjb25zdCBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gICAgICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG11bChtdWx0aXBsaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KG11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9WQUxVRTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKExvbmcuT05FKTtcbiAgICB9XG4gICAgbmVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKTtcbiAgICB9XG4gICAgbm90KCkge1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBub3RFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG5lcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RFcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBuZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RFcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhudW1CaXRzKSlcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBzaGwobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdExlZnQobnVtQml0cyk7XG4gICAgfVxuICAgIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgc2hyKG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgbnVtQml0cyAmPSA2MztcbiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gdGhpcy5oaWdoO1xuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvdyA9IHRoaXMubG93O1xuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaHJfdShudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hydShudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKTtcbiAgICB9XG4gICAgc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKHN1YnRyYWhlbmQpKVxuICAgICAgICAgICAgc3VidHJhaGVuZCA9IExvbmcuZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG4gICAgfVxuICAgIHN1YihzdWJ0cmFoZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KHN1YnRyYWhlbmQpO1xuICAgIH1cbiAgICB0b0ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRvQnl0ZXMobGUpIHtcbiAgICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG4gICAgfVxuICAgIHRvQnl0ZXNMRSgpIHtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsbyAmIDB4ZmYsXG4gICAgICAgICAgICAobG8gPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgaGkgPj4+IDI0XG4gICAgICAgIF07XG4gICAgfVxuICAgIHRvQnl0ZXNCRSgpIHtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoaSA+Pj4gMjQsXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaGkgPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgbG8gJiAweGZmXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRvU2lnbmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXhMb25nID0gTG9uZy5mcm9tTnVtYmVyKHJhZGl4KSwgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSwgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgbGV0IHJlbSA9IHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwO1xuICAgICAgICAgICAgbGV0IGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRvVW5zaWduZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICAgIH1cbiAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBlcXooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzWmVybygpO1xuICAgIH1cbiAgICBsZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJMb25nOiB0aGlzLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlQmlnSW50NjQgPSBmYWxzZSwgcmVsYXhlZCA9IHRydWUgfSA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBpZiAoZG9jLiRudW1iZXJMb25nLmxlbmd0aCA+IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCckbnVtYmVyTG9uZyBzdHJpbmcgaXMgdG9vIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIURFQ0lNQUxfUkVHX0VYLnRlc3QoZG9jLiRudW1iZXJMb25nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgJG51bWJlckxvbmcgc3RyaW5nIFwiJHtkb2MuJG51bWJlckxvbmd9XCIgaXMgaW4gYW4gaW52YWxpZCBmb3JtYXRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludFJlc3VsdCA9IEJpZ0ludChkb2MuJG51bWJlckxvbmcpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oNjQsIGJpZ0ludFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9uZ1Jlc3VsdCA9IExvbmcuZnJvbVN0cmluZyhkb2MuJG51bWJlckxvbmcpO1xuICAgICAgICBpZiAocmVsYXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdSZXN1bHQudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9uZ1Jlc3VsdDtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgY29uc3QgbG9uZ1ZhbCA9IGluc3BlY3QodGhpcy50b1N0cmluZygpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdW5zaWduZWRWYWwgPSB0aGlzLnVuc2lnbmVkID8gYCwgJHtpbnNwZWN0KHRoaXMudW5zaWduZWQsIG9wdGlvbnMpfWAgOiAnJztcbiAgICAgICAgcmV0dXJuIGBuZXcgTG9uZygke2xvbmdWYWx9JHt1bnNpZ25lZFZhbH0pYDtcbiAgICB9XG59XG5Mb25nLlRXT19QV1JfMjQgPSBMb25nLmZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBMb25nLmZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweGZmZmZmZmZmIHwgMCwgdHJ1ZSk7XG5Mb25nLlpFUk8gPSBMb25nLmZyb21JbnQoMCk7XG5Mb25nLlVaRVJPID0gTG9uZy5mcm9tSW50KDAsIHRydWUpO1xuTG9uZy5PTkUgPSBMb25nLmZyb21JbnQoMSk7XG5Mb25nLlVPTkUgPSBMb25nLmZyb21JbnQoMSwgdHJ1ZSk7XG5Mb25nLk5FR19PTkUgPSBMb25nLmZyb21JbnQoLTEpO1xuTG9uZy5NQVhfVkFMVUUgPSBMb25nLmZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweDdmZmZmZmZmIHwgMCwgZmFsc2UpO1xuTG9uZy5NSU5fVkFMVUUgPSBMb25nLmZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbmNvbnN0IFBBUlNFX1NUUklOR19SRUdFWFAgPSAvXihcXCt8LSk/KFxcZCt8KFxcZCpcXC5cXGQqKSk/KEV8ZSk/KFstK10pPyhcXGQrKT8kLztcbmNvbnN0IFBBUlNFX0lORl9SRUdFWFAgPSAvXihcXCt8LSk/KEluZmluaXR5fGluZikkL2k7XG5jb25zdCBQQVJTRV9OQU5fUkVHRVhQID0gL14oXFwrfC0pP05hTiQvaTtcbmNvbnN0IEVYUE9ORU5UX01BWCA9IDYxMTE7XG5jb25zdCBFWFBPTkVOVF9NSU4gPSAtNjE3NjtcbmNvbnN0IEVYUE9ORU5UX0JJQVMgPSA2MTc2O1xuY29uc3QgTUFYX0RJR0lUUyA9IDM0O1xuY29uc3QgTkFOX0JVRkZFUiA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoW1xuICAgIDB4N2MsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0ucmV2ZXJzZSgpKTtcbmNvbnN0IElORl9ORUdBVElWRV9CVUZGRVIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFtcbiAgICAweGY4LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dLnJldmVyc2UoKSk7XG5jb25zdCBJTkZfUE9TSVRJVkVfQlVGRkVSID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbXG4gICAgMHg3OCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMFxuXS5yZXZlcnNlKCkpO1xuY29uc3QgRVhQT05FTlRfUkVHRVggPSAvXihbLStdKT8oXFxkKyk/JC87XG5jb25zdCBDT01CSU5BVElPTl9NQVNLID0gMHgxZjtcbmNvbnN0IEVYUE9ORU5UX01BU0sgPSAweDNmZmY7XG5jb25zdCBDT01CSU5BVElPTl9JTkZJTklUWSA9IDMwO1xuY29uc3QgQ09NQklOQVRJT05fTkFOID0gMzE7XG5mdW5jdGlvbiBpc0RpZ2l0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUludCh2YWx1ZSwgMTApKTtcbn1cbmZ1bmN0aW9uIGRpdmlkZXUxMjgodmFsdWUpIHtcbiAgICBjb25zdCBESVZJU09SID0gTG9uZy5mcm9tTnVtYmVyKDEwMDAgKiAxMDAwICogMTAwMCk7XG4gICAgbGV0IF9yZW0gPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgaWYgKCF2YWx1ZS5wYXJ0c1swXSAmJiAhdmFsdWUucGFydHNbMV0gJiYgIXZhbHVlLnBhcnRzWzJdICYmICF2YWx1ZS5wYXJ0c1szXSkge1xuICAgICAgICByZXR1cm4geyBxdW90aWVudDogdmFsdWUsIHJlbTogX3JlbSB9O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgX3JlbSA9IF9yZW0uc2hpZnRMZWZ0KDMyKTtcbiAgICAgICAgX3JlbSA9IF9yZW0uYWRkKG5ldyBMb25nKHZhbHVlLnBhcnRzW2ldLCAwKSk7XG4gICAgICAgIHZhbHVlLnBhcnRzW2ldID0gX3JlbS5kaXYoRElWSVNPUikubG93O1xuICAgICAgICBfcmVtID0gX3JlbS5tb2R1bG8oRElWSVNPUik7XG4gICAgfVxuICAgIHJldHVybiB7IHF1b3RpZW50OiB2YWx1ZSwgcmVtOiBfcmVtIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseTY0eDIobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7IGhpZ2g6IExvbmcuZnJvbU51bWJlcigwKSwgbG93OiBMb25nLmZyb21OdW1iZXIoMCkgfTtcbiAgICB9XG4gICAgY29uc3QgbGVmdEhpZ2ggPSBsZWZ0LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMik7XG4gICAgY29uc3QgbGVmdExvdyA9IG5ldyBMb25nKGxlZnQuZ2V0TG93Qml0cygpLCAwKTtcbiAgICBjb25zdCByaWdodEhpZ2ggPSByaWdodC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpO1xuICAgIGNvbnN0IHJpZ2h0TG93ID0gbmV3IExvbmcocmlnaHQuZ2V0TG93Qml0cygpLCAwKTtcbiAgICBsZXQgcHJvZHVjdEhpZ2ggPSBsZWZ0SGlnaC5tdWx0aXBseShyaWdodEhpZ2gpO1xuICAgIGxldCBwcm9kdWN0TWlkID0gbGVmdEhpZ2gubXVsdGlwbHkocmlnaHRMb3cpO1xuICAgIGNvbnN0IHByb2R1Y3RNaWQyID0gbGVmdExvdy5tdWx0aXBseShyaWdodEhpZ2gpO1xuICAgIGxldCBwcm9kdWN0TG93ID0gbGVmdExvdy5tdWx0aXBseShyaWdodExvdyk7XG4gICAgcHJvZHVjdEhpZ2ggPSBwcm9kdWN0SGlnaC5hZGQocHJvZHVjdE1pZC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpKTtcbiAgICBwcm9kdWN0TWlkID0gbmV3IExvbmcocHJvZHVjdE1pZC5nZXRMb3dCaXRzKCksIDApXG4gICAgICAgIC5hZGQocHJvZHVjdE1pZDIpXG4gICAgICAgIC5hZGQocHJvZHVjdExvdy5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpKTtcbiAgICBwcm9kdWN0SGlnaCA9IHByb2R1Y3RIaWdoLmFkZChwcm9kdWN0TWlkLnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RMb3cgPSBwcm9kdWN0TWlkLnNoaWZ0TGVmdCgzMikuYWRkKG5ldyBMb25nKHByb2R1Y3RMb3cuZ2V0TG93Qml0cygpLCAwKSk7XG4gICAgcmV0dXJuIHsgaGlnaDogcHJvZHVjdEhpZ2gsIGxvdzogcHJvZHVjdExvdyB9O1xufVxuZnVuY3Rpb24gbGVzc1RoYW4obGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCB1aGxlZnQgPSBsZWZ0LmhpZ2ggPj4+IDA7XG4gICAgY29uc3QgdWhyaWdodCA9IHJpZ2h0LmhpZ2ggPj4+IDA7XG4gICAgaWYgKHVobGVmdCA8IHVocmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVobGVmdCA9PT0gdWhyaWdodCkge1xuICAgICAgICBjb25zdCB1bGxlZnQgPSBsZWZ0LmxvdyA+Pj4gMDtcbiAgICAgICAgY29uc3QgdWxyaWdodCA9IHJpZ2h0LmxvdyA+Pj4gMDtcbiAgICAgICAgaWYgKHVsbGVmdCA8IHVscmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW52YWxpZEVycihzdHJpbmcsIG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBcIiR7c3RyaW5nfVwiIGlzIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nIC0gJHttZXNzYWdlfWApO1xufVxuY2xhc3MgRGVjaW1hbDEyOCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEZWNpbWFsMTI4JztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBEZWNpbWFsMTI4LmZyb21TdHJpbmcoYnl0ZXMpLmJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheShieXRlcykpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0RlY2ltYWwxMjggbXVzdCB0YWtlIGEgQnVmZmVyIG9mIDE2IGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdEZWNpbWFsMTI4IG11c3QgdGFrZSBhIEJ1ZmZlciBvciBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5fZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbiwgeyBhbGxvd1JvdW5kaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmdXaXRoUm91bmRpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguX2Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24sIHsgYWxsb3dSb3VuZGluZzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgIGxldCBzYXdTaWduID0gZmFsc2U7XG4gICAgICAgIGxldCBzYXdSYWRpeCA9IGZhbHNlO1xuICAgICAgICBsZXQgZm91bmROb25aZXJvID0gZmFsc2U7XG4gICAgICAgIGxldCBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgIGxldCBuRGlnaXRzUmVhZCA9IDA7XG4gICAgICAgIGxldCBuRGlnaXRzID0gMDtcbiAgICAgICAgbGV0IHJhZGl4UG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgZmlyc3ROb25aZXJvID0gMDtcbiAgICAgICAgY29uc3QgZGlnaXRzID0gWzBdO1xuICAgICAgICBsZXQgbkRpZ2l0c1N0b3JlZCA9IDA7XG4gICAgICAgIGxldCBkaWdpdHNJbnNlcnQgPSAwO1xuICAgICAgICBsZXQgbGFzdERpZ2l0ID0gMDtcbiAgICAgICAgbGV0IGV4cG9uZW50ID0gMDtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kSGlnaCA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRMb3cgPSBuZXcgTG9uZygwLCAwKTtcbiAgICAgICAgbGV0IGJpYXNlZEV4cG9uZW50ID0gMDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uLmxlbmd0aCA+PSA3MDAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaW5nTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9TVFJJTkdfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgaW5mTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9JTkZfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgbmFuTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9OQU5fUkVHRVhQKTtcbiAgICAgICAgaWYgKCghc3RyaW5nTWF0Y2ggJiYgIWluZk1hdGNoICYmICFuYW5NYXRjaCkgfHwgcmVwcmVzZW50YXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZ01hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZE51bWJlciA9IHN0cmluZ01hdGNoWzJdO1xuICAgICAgICAgICAgY29uc3QgZSA9IHN0cmluZ01hdGNoWzRdO1xuICAgICAgICAgICAgY29uc3QgZXhwU2lnbiA9IHN0cmluZ01hdGNoWzVdO1xuICAgICAgICAgICAgY29uc3QgZXhwTnVtYmVyID0gc3RyaW5nTWF0Y2hbNl07XG4gICAgICAgICAgICBpZiAoZSAmJiBleHBOdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBleHBvbmVudCBwb3dlcicpO1xuICAgICAgICAgICAgaWYgKGUgJiYgdW5zaWduZWROdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBleHBvbmVudCBiYXNlJyk7XG4gICAgICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkICYmIChleHBTaWduIHx8IGV4cE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBlIGJlZm9yZSBleHBvbmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICcrJyB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICctJykge1xuICAgICAgICAgICAgc2F3U2lnbiA9IHRydWU7XG4gICAgICAgICAgICBpc05lZ2F0aXZlID0gcmVwcmVzZW50YXRpb25baW5kZXgrK10gPT09ICctJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRGlnaXQocmVwcmVzZW50YXRpb25baW5kZXhdKSAmJiByZXByZXNlbnRhdGlvbltpbmRleF0gIT09ICcuJykge1xuICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ2knIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGlzTmVnYXRpdmUgPyBJTkZfTkVHQVRJVkVfQlVGRkVSIDogSU5GX1BPU0lUSVZFX0JVRkZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdOJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNEaWdpdChyZXByZXNlbnRhdGlvbltpbmRleF0pIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3UmFkaXgpXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdjb250YWlucyBtdWx0aXBsZSBwZXJpb2RzJyk7XG4gICAgICAgICAgICAgICAgc2F3UmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBNQVhfRElHSVRTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSAhPT0gJzAnIHx8IGZvdW5kTm9uWmVybykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kTm9uWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gbkRpZ2l0c1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm91bmROb25aZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzW2RpZ2l0c0luc2VydCsrXSA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2luZGV4XSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBuRGlnaXRzU3RvcmVkID0gbkRpZ2l0c1N0b3JlZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kTm9uWmVybylcbiAgICAgICAgICAgICAgICBuRGlnaXRzID0gbkRpZ2l0cyArIDE7XG4gICAgICAgICAgICBpZiAoc2F3UmFkaXgpXG4gICAgICAgICAgICAgICAgcmFkaXhQb3NpdGlvbiA9IHJhZGl4UG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgbkRpZ2l0c1JlYWQgPSBuRGlnaXRzUmVhZCArIDE7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F3UmFkaXggJiYgIW5EaWdpdHNSZWFkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignJyArIHJlcHJlc2VudGF0aW9uICsgJyBub3QgYSB2YWxpZCBEZWNpbWFsMTI4IHN0cmluZycpO1xuICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnZScgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnRScpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVwcmVzZW50YXRpb24uc3Vic3RyKCsraW5kZXgpLm1hdGNoKEVYUE9ORU5UX1JFR0VYKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzJdKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQobWF0Y2hbMF0sIDEwKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgaWYgKCFuRGlnaXRzU3RvcmVkKSB7XG4gICAgICAgICAgICBkaWdpdHNbMF0gPSAwO1xuICAgICAgICAgICAgbkRpZ2l0cyA9IDE7XG4gICAgICAgICAgICBuRGlnaXRzU3RvcmVkID0gMTtcbiAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3REaWdpdCA9IG5EaWdpdHNTdG9yZWQgLSAxO1xuICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBuRGlnaXRzO1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIHNpZ25pZmljYW50RGlnaXRzIC0gMSArIE51bWJlcihzYXdTaWduKSArIE51bWJlcihzYXdSYWRpeCldID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBzaWduaWZpY2FudERpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvbmVudCA8PSByYWRpeFBvc2l0aW9uICYmIHJhZGl4UG9zaXRpb24gPiBleHBvbmVudCArICgxIDw8IDE0KSkge1xuICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gcmFkaXhQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZXhwb25lbnQgPiBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCArIDE7XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ID49IE1BWF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93Um91bmRpbmcpIHtcbiAgICAgICAgICAgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDAgJiYgc2lnbmlmaWNhbnREaWdpdHMgPCBuRGlnaXRzU3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUlOO1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdERpZ2l0ID0gbGFzdERpZ2l0IC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnaXRzU3RyaW5nID0gZGlnaXRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlnaXRzU3RyaW5nLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUFYO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3REaWdpdCArIDEgPCBzaWduaWZpY2FudERpZ2l0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbmRPZlN0cmluZyA9IG5EaWdpdHNSZWFkO1xuICAgICAgICAgICAgICAgIGlmIChzYXdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZlN0cmluZyA9IGVuZE9mU3RyaW5nICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhd1NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2ZTdHJpbmcgPSBlbmRPZlN0cmluZyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kRGlnaXQgPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAxXSwgMTApO1xuICAgICAgICAgICAgICAgIGxldCByb3VuZEJpdCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgPj0gNSkge1xuICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IGRpZ2l0c1tsYXN0RGlnaXRdICUgMiA9PT0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDI7IGkgPCBlbmRPZlN0cmluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ldLCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRCaXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kQml0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkSWR4ID0gbGFzdERpZ2l0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZElkeCA+PSAwOyBkSWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2RpZ2l0c1tkSWR4XSA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZElkeF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkSWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZElkeF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGlzTmVnYXRpdmUgPyBJTkZfTkVHQVRJVkVfQlVGRkVSIDogSU5GX1BPU0lUSVZFX0JVRkZFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01JTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdleHBvbmVudCB1bmRlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltuRGlnaXRzIC0gMSArIE51bWJlcihzYXdTaWduKSArIE51bWJlcihzYXdSYWRpeCldICE9PSAnMCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnaW5leGFjdCByb3VuZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5EaWdpdHMgPSBuRGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHNbbGFzdERpZ2l0XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2luZXhhY3Qgcm91bmRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPCBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ICsgMSA8IHNpZ25pZmljYW50RGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYXdTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kRGlnaXQgPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAxXSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdpbmV4YWN0IHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdERpZ2l0IDwgMTcpIHtcbiAgICAgICAgICAgIGxldCBkSWR4ID0gMDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4KytdKTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkSWR4ID0gMDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeCsrXSk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQgLSAxNzsgZElkeCsrKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gc2lnbmlmaWNhbmRIaWdoLm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IHNpZ25pZmljYW5kSGlnaC5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHgrK10pO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduaWZpY2FuZCA9IG11bHRpcGx5NjR4MihzaWduaWZpY2FuZEhpZ2gsIExvbmcuZnJvbVN0cmluZygnMTAwMDAwMDAwMDAwMDAwMDAwJykpO1xuICAgICAgICBzaWduaWZpY2FuZC5sb3cgPSBzaWduaWZpY2FuZC5sb3cuYWRkKHNpZ25pZmljYW5kTG93KTtcbiAgICAgICAgaWYgKGxlc3NUaGFuKHNpZ25pZmljYW5kLmxvdywgc2lnbmlmaWNhbmRMb3cpKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZC5oaWdoID0gc2lnbmlmaWNhbmQuaGlnaC5hZGQoTG9uZy5mcm9tTnVtYmVyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBiaWFzZWRFeHBvbmVudCA9IGV4cG9uZW50ICsgRVhQT05FTlRfQklBUztcbiAgICAgICAgY29uc3QgZGVjID0geyBsb3c6IExvbmcuZnJvbU51bWJlcigwKSwgaGlnaDogTG9uZy5mcm9tTnVtYmVyKDApIH07XG4gICAgICAgIGlmIChzaWduaWZpY2FuZC5oaWdoLnNoaWZ0UmlnaHRVbnNpZ25lZCg0OSkuYW5kKExvbmcuZnJvbU51bWJlcigxKSkuZXF1YWxzKExvbmcuZnJvbU51bWJlcigxKSkpIHtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tTnVtYmVyKDB4Mykuc2hpZnRMZWZ0KDYxKSk7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCkuYW5kKExvbmcuZnJvbU51bWJlcigweDNmZmYpLnNoaWZ0TGVmdCg0NykpKTtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3Ioc2lnbmlmaWNhbmQuaGlnaC5hbmQoTG9uZy5mcm9tTnVtYmVyKDB4N2ZmZmZmZmZmZmZmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21OdW1iZXIoYmlhc2VkRXhwb25lbnQgJiAweDNmZmYpLnNoaWZ0TGVmdCg0OSkpO1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihzaWduaWZpY2FuZC5oaWdoLmFuZChMb25nLmZyb21OdW1iZXIoMHgxZmZmZmZmZmZmZmZmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlYy5sb3cgPSBzaWduaWZpY2FuZC5sb3c7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbVN0cmluZygnOTIyMzM3MjAzNjg1NDc3NTgwOCcpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGVVbnNhZmUoMTYpO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5sb3cubG93ICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmxvdyA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMubG93LmhpZ2ggJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cuaGlnaCA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5oaWdoLmxvdyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2gubG93ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmhpZ2guaGlnaCAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5oaWdoID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gMjQpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgYmlhc2VkX2V4cG9uZW50O1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRfZGlnaXRzID0gMDtcbiAgICAgICAgY29uc3Qgc2lnbmlmaWNhbmQgPSBuZXcgQXJyYXkoMzYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc2lnbmlmaWNhbmRbaV0gPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgaXNfemVybyA9IGZhbHNlO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRfbXNiO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmQxMjggPSB7IHBhcnRzOiBbMCwgMCwgMCwgMF0gfTtcbiAgICAgICAgbGV0IGosIGs7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IFtdO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnl0ZXM7XG4gICAgICAgIGNvbnN0IGxvdyA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBjb25zdCBtaWRsID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGNvbnN0IG1pZGggPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgY29uc3QgaGlnaCA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGRlYyA9IHtcbiAgICAgICAgICAgIGxvdzogbmV3IExvbmcobG93LCBtaWRsKSxcbiAgICAgICAgICAgIGhpZ2g6IG5ldyBMb25nKG1pZGgsIGhpZ2gpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWMuaGlnaC5sZXNzVGhhbihMb25nLlpFUk8pKSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbWJpbmF0aW9uID0gKGhpZ2ggPj4gMjYpICYgQ09NQklOQVRJT05fTUFTSztcbiAgICAgICAgaWYgKGNvbWJpbmF0aW9uID4+IDMgPT09IDMpIHtcbiAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbiA9PT0gQ09NQklOQVRJT05fSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpICsgJ0luZmluaXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbWJpbmF0aW9uID09PSBDT01CSU5BVElPTl9OQU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaWFzZWRfZXhwb25lbnQgPSAoaGlnaCA+PiAxNSkgJiBFWFBPTkVOVF9NQVNLO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kX21zYiA9IDB4MDggKyAoKGhpZ2ggPj4gMTQpICYgMHgwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9tc2IgPSAoaGlnaCA+PiAxNCkgJiAweDA3O1xuICAgICAgICAgICAgYmlhc2VkX2V4cG9uZW50ID0gKGhpZ2ggPj4gMTcpICYgRVhQT05FTlRfTUFTSztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBvbmVudCA9IGJpYXNlZF9leHBvbmVudCAtIEVYUE9ORU5UX0JJQVM7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzBdID0gKGhpZ2ggJiAweDNmZmYpICsgKChzaWduaWZpY2FuZF9tc2IgJiAweGYpIDw8IDE0KTtcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMV0gPSBtaWRoO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1syXSA9IG1pZGw7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzNdID0gbG93O1xuICAgICAgICBpZiAoc2lnbmlmaWNhbmQxMjgucGFydHNbMF0gPT09IDAgJiZcbiAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzFdID09PSAwICYmXG4gICAgICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1syXSA9PT0gMCAmJlxuICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbM10gPT09IDApIHtcbiAgICAgICAgICAgIGlzX3plcm8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMzsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVhc3RfZGlnaXRzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkaXZpZGV1MTI4KHNpZ25pZmljYW5kMTI4KTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZDEyOCA9IHJlc3VsdC5xdW90aWVudDtcbiAgICAgICAgICAgICAgICBsZWFzdF9kaWdpdHMgPSByZXN1bHQucmVtLmxvdztcbiAgICAgICAgICAgICAgICBpZiAoIWxlYXN0X2RpZ2l0cylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gODsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRbayAqIDkgKyBqXSA9IGxlYXN0X2RpZ2l0cyAlIDEwO1xuICAgICAgICAgICAgICAgICAgICBsZWFzdF9kaWdpdHMgPSBNYXRoLmZsb29yKGxlYXN0X2RpZ2l0cyAvIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3plcm8pIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IDE7XG4gICAgICAgICAgICBzaWduaWZpY2FuZFtpbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gMzY7XG4gICAgICAgICAgICB3aGlsZSAoIXNpZ25pZmljYW5kW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NpZW50aWZpY19leHBvbmVudCA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDEgKyBleHBvbmVudDtcbiAgICAgICAgaWYgKHNjaWVudGlmaWNfZXhwb25lbnQgPj0gMzQgfHwgc2NpZW50aWZpY19leHBvbmVudCA8PSAtNyB8fCBleHBvbmVudCA+IDApIHtcbiAgICAgICAgICAgIGlmIChzaWduaWZpY2FuZF9kaWdpdHMgPiAzNCkge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAkezB9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID4gMClcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYEUrJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBvbmVudCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGBFJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSBzaWduaWZpY2FuZF9kaWdpdHMgLSAxO1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW5kX2RpZ2l0cykge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcucHVzaCgnRScpO1xuICAgICAgICAgICAgaWYgKHNjaWVudGlmaWNfZXhwb25lbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCske3NjaWVudGlmaWNfZXhwb25lbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzY2llbnRpZmljX2V4cG9uZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4cG9uZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByYWRpeF9wb3NpdGlvbiA9IHNpZ25pZmljYW5kX2RpZ2l0cyArIGV4cG9uZW50O1xuICAgICAgICAgICAgICAgIGlmIChyYWRpeF9wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWRpeF9wb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJy4nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFkaXhfcG9zaXRpb24rKyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduaWZpY2FuZF9kaWdpdHMgLSBNYXRoLm1heChyYWRpeF9wb3NpdGlvbiAtIDEsIDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguZnJvbVN0cmluZyhkb2MuJG51bWJlckRlY2ltYWwpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBkMTI4c3RyaW5nID0gaW5zcGVjdCh0aGlzLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYG5ldyBEZWNpbWFsMTI4KCR7ZDEyOHN0cmluZ30pYDtcbiAgICB9XG59XG5cbmNsYXNzIERvdWJsZSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEb3VibGUnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSArdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMubGVnYWN5IHx8IChvcHRpb25zLnJlbGF4ZWQgJiYgaXNGaW5pdGUodGhpcy52YWx1ZSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pcyhNYXRoLnNpZ24odGhpcy52YWx1ZSksIC0wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckRvdWJsZTogJy0wLjAnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRudW1iZXJEb3VibGU6IE51bWJlci5pc0ludGVnZXIodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlLnRvRml4ZWQoMSkgOiB0aGlzLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRvdWJsZVZhbHVlID0gcGFyc2VGbG9hdChkb2MuJG51bWJlckRvdWJsZSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCA/IGRvdWJsZVZhbHVlIDogbmV3IERvdWJsZShkb3VibGVWYWx1ZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIHJldHVybiBgbmV3IERvdWJsZSgke2luc3BlY3QodGhpcy52YWx1ZSwgb3B0aW9ucyl9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBJbnQzMiBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdJbnQzMic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9ICt2YWx1ZSB8IDA7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMucmVsYXhlZCB8fCBvcHRpb25zLmxlZ2FjeSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckludDogdGhpcy52YWx1ZS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQgPyBwYXJzZUludChkb2MuJG51bWJlckludCwgMTApIDogbmV3IEludDMyKGRvYy4kbnVtYmVySW50KTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgSW50MzIoJHtpbnNwZWN0KHRoaXMudmFsdWUsIG9wdGlvbnMpfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgTWF4S2V5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ01heEtleSc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbWF4S2V5OiAxIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1heEtleSgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gJ25ldyBNYXhLZXkoKSc7XG4gICAgfVxufVxuXG5jbGFzcyBNaW5LZXkgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnTWluS2V5JztcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICRtaW5LZXk6IDEgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWluS2V5KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAnbmV3IE1pbktleSgpJztcbiAgICB9XG59XG5cbmNvbnN0IEZMT0FUID0gbmV3IEZsb2F0NjRBcnJheSgxKTtcbmNvbnN0IEZMT0FUX0JZVEVTID0gbmV3IFVpbnQ4QXJyYXkoRkxPQVQuYnVmZmVyLCAwLCA4KTtcbkZMT0FUWzBdID0gLTE7XG5jb25zdCBpc0JpZ0VuZGlhbiA9IEZMT0FUX0JZVEVTWzddID09PSAwO1xuY29uc3QgTnVtYmVyVXRpbHMgPSB7XG4gICAgZ2V0Tm9ubmVnYXRpdmVJbnQzMkxFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChzb3VyY2Vbb2Zmc2V0ICsgM10gPiAxMjcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTaXplIGNhbm5vdCBiZSBuZWdhdGl2ZSBhdCBvZmZzZXQ6ICR7b2Zmc2V0fWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoc291cmNlW29mZnNldF0gfFxuICAgICAgICAgICAgKHNvdXJjZVtvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDNdIDw8IDI0KSk7XG4gICAgfSxcbiAgICBnZXRJbnQzMkxFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAoc291cmNlW29mZnNldF0gfFxuICAgICAgICAgICAgKHNvdXJjZVtvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgICAgICAgICAoc291cmNlW29mZnNldCArIDNdIDw8IDI0KSk7XG4gICAgfSxcbiAgICBnZXRVaW50MzJMRShzb3VyY2UsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKHNvdXJjZVtvZmZzZXRdICtcbiAgICAgICAgICAgIHNvdXJjZVtvZmZzZXQgKyAxXSAqIDI1NiArXG4gICAgICAgICAgICBzb3VyY2Vbb2Zmc2V0ICsgMl0gKiA2NTUzNiArXG4gICAgICAgICAgICBzb3VyY2Vbb2Zmc2V0ICsgM10gKiAxNjc3NzIxNik7XG4gICAgfSxcbiAgICBnZXRVaW50MzJCRShzb3VyY2UsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKHNvdXJjZVtvZmZzZXQgKyAzXSArXG4gICAgICAgICAgICBzb3VyY2Vbb2Zmc2V0ICsgMl0gKiAyNTYgK1xuICAgICAgICAgICAgc291cmNlW29mZnNldCArIDFdICogNjU1MzYgK1xuICAgICAgICAgICAgc291cmNlW29mZnNldF0gKiAxNjc3NzIxNik7XG4gICAgfSxcbiAgICBnZXRCaWdJbnQ2NExFKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGxvID0gTnVtYmVyVXRpbHMuZ2V0VWludDMyTEUoc291cmNlLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBoaSA9IE51bWJlclV0aWxzLmdldFVpbnQzMkxFKHNvdXJjZSwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0TEU6IGlzQmlnRW5kaWFuXG4gICAgICAgID8gKHNvdXJjZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s3XSA9IHNvdXJjZVtvZmZzZXRdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbNl0gPSBzb3VyY2Vbb2Zmc2V0ICsgMV07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s1XSA9IHNvdXJjZVtvZmZzZXQgKyAyXTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzRdID0gc291cmNlW29mZnNldCArIDNdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbM10gPSBzb3VyY2Vbb2Zmc2V0ICsgNF07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1syXSA9IHNvdXJjZVtvZmZzZXQgKyA1XTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzFdID0gc291cmNlW29mZnNldCArIDZdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbMF0gPSBzb3VyY2Vbb2Zmc2V0ICsgN107XG4gICAgICAgICAgICByZXR1cm4gRkxPQVRbMF07XG4gICAgICAgIH1cbiAgICAgICAgOiAoc291cmNlLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzBdID0gc291cmNlW29mZnNldF07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1sxXSA9IHNvdXJjZVtvZmZzZXQgKyAxXTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzJdID0gc291cmNlW29mZnNldCArIDJdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbM10gPSBzb3VyY2Vbb2Zmc2V0ICsgM107XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s0XSA9IHNvdXJjZVtvZmZzZXQgKyA0XTtcbiAgICAgICAgICAgIEZMT0FUX0JZVEVTWzVdID0gc291cmNlW29mZnNldCArIDVdO1xuICAgICAgICAgICAgRkxPQVRfQllURVNbNl0gPSBzb3VyY2Vbb2Zmc2V0ICsgNl07XG4gICAgICAgICAgICBGTE9BVF9CWVRFU1s3XSA9IHNvdXJjZVtvZmZzZXQgKyA3XTtcbiAgICAgICAgICAgIHJldHVybiBGTE9BVFswXTtcbiAgICAgICAgfSxcbiAgICBzZXRJbnQzMkJFKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDNdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMl0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfSxcbiAgICBzZXRJbnQzMkxFKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldF0gPSB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPj4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9IHZhbHVlO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDJdID0gdmFsdWU7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgM10gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfSxcbiAgICBzZXRCaWdJbnQ2NExFKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1hc2szMmJpdHMgPSBCaWdJbnQoNDI5NDk2NzI5NSk7XG4gICAgICAgIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIG1hc2szMmJpdHMpO1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXRdID0gbG87XG4gICAgICAgIGxvID4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAxXSA9IGxvO1xuICAgICAgICBsbyA+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMl0gPSBsbztcbiAgICAgICAgbG8gPj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDNdID0gbG87XG4gICAgICAgIGxldCBoaSA9IE51bWJlcigodmFsdWUgPj4gQmlnSW50KDMyKSkgJiBtYXNrMzJiaXRzKTtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgNF0gPSBoaTtcbiAgICAgICAgaGkgPj49IDg7XG4gICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDVdID0gaGk7XG4gICAgICAgIGhpID4+PSA4O1xuICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyA2XSA9IGhpO1xuICAgICAgICBoaSA+Pj0gODtcbiAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgN10gPSBoaTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0TEU6IGlzQmlnRW5kaWFuXG4gICAgICAgID8gKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBGTE9BVFswXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0XSA9IEZMT0FUX0JZVEVTWzddO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMV0gPSBGTE9BVF9CWVRFU1s2XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDJdID0gRkxPQVRfQllURVNbNV07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAzXSA9IEZMT0FUX0JZVEVTWzRdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgNF0gPSBGTE9BVF9CWVRFU1szXTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDVdID0gRkxPQVRfQllURVNbMl07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyA2XSA9IEZMT0FUX0JZVEVTWzFdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgN10gPSBGTE9BVF9CWVRFU1swXTtcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG4gICAgICAgIDogKGRlc3RpbmF0aW9uLCBvZmZzZXQsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBGTE9BVFswXSA9IHZhbHVlO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0XSA9IEZMT0FUX0JZVEVTWzBdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgMV0gPSBGTE9BVF9CWVRFU1sxXTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDJdID0gRkxPQVRfQllURVNbMl07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyAzXSA9IEZMT0FUX0JZVEVTWzNdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgNF0gPSBGTE9BVF9CWVRFU1s0XTtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uW29mZnNldCArIDVdID0gRkxPQVRfQllURVNbNV07XG4gICAgICAgICAgICBkZXN0aW5hdGlvbltvZmZzZXQgKyA2XSA9IEZMT0FUX0JZVEVTWzZdO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bb2Zmc2V0ICsgN10gPSBGTE9BVF9CWVRFU1s3XTtcbiAgICAgICAgICAgIHJldHVybiA4O1xuICAgICAgICB9XG59O1xuXG5jb25zdCBjaGVja0ZvckhleFJlZ0V4cCA9IG5ldyBSZWdFeHAoJ15bMC05YS1mQS1GXXsyNH0kJyk7XG5sZXQgUFJPQ0VTU19VTklRVUUgPSBudWxsO1xuY2xhc3MgT2JqZWN0SWQgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnT2JqZWN0SWQnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpbnB1dElkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGxldCB3b3JraW5nSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXRJZCA9PT0gJ29iamVjdCcgJiYgaW5wdXRJZCAmJiAnaWQnIGluIGlucHV0SWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXRJZC5pZCAhPT0gJ3N0cmluZycgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhpbnB1dElkLmlkKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBtdXN0IGhhdmUgYW4gaWQgdGhhdCBpcyBvZiB0eXBlIHN0cmluZyBvciBCdWZmZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgndG9IZXhTdHJpbmcnIGluIGlucHV0SWQgJiYgdHlwZW9mIGlucHV0SWQudG9IZXhTdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB3b3JraW5nSWQgPSBCeXRlVXRpbHMuZnJvbUhleChpbnB1dElkLnRvSGV4U3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya2luZ0lkID0gaW5wdXRJZC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdvcmtpbmdJZCA9IGlucHV0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtpbmdJZCA9PSBudWxsIHx8IHR5cGVvZiB3b3JraW5nSWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IE9iamVjdElkLmdlbmVyYXRlKHR5cGVvZiB3b3JraW5nSWQgPT09ICdudW1iZXInID8gd29ya2luZ0lkIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcod29ya2luZ0lkKSAmJiB3b3JraW5nSWQuYnl0ZUxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKHdvcmtpbmdJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHdvcmtpbmdJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh3b3JraW5nSWQubGVuZ3RoID09PSAyNCAmJiBjaGVja0ZvckhleFJlZ0V4cC50ZXN0KHdvcmtpbmdJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IEJ5dGVVdGlscy5mcm9tSGV4KHdvcmtpbmdJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdpbnB1dCBtdXN0IGJlIGEgMjQgY2hhcmFjdGVyIGhleCBzdHJpbmcsIDEyIGJ5dGUgVWludDhBcnJheSwgb3IgYW4gaW50ZWdlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIGRvZXMgbm90IG1hdGNoIHRoZSBhY2NlcHRlZCB0eXBlcycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3RJZC5jYWNoZUhleFN0cmluZykge1xuICAgICAgICAgICAgdGhpcy5fX2lkID0gQnl0ZVV0aWxzLnRvSGV4KHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgIH1cbiAgICBzZXQgaWQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9faWQgPSBCeXRlVXRpbHMudG9IZXgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSGV4U3RyaW5nKCkge1xuICAgICAgICBpZiAoT2JqZWN0SWQuY2FjaGVIZXhTdHJpbmcgJiYgdGhpcy5fX2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2lkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleFN0cmluZyA9IEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nICYmICF0aGlzLl9faWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19pZCA9IGhleFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4U3RyaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW5jKCkge1xuICAgICAgICByZXR1cm4gKE9iamVjdElkLmluZGV4ID0gKE9iamVjdElkLmluZGV4ICsgMSkgJSAweGZmZmZmZik7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSh0aW1lKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmMgPSBPYmplY3RJZC5nZXRJbmMoKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlVW5zYWZlKDEyKTtcbiAgICAgICAgTnVtYmVyVXRpbHMuc2V0SW50MzJCRShidWZmZXIsIDAsIHRpbWUpO1xuICAgICAgICBpZiAoUFJPQ0VTU19VTklRVUUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFBST0NFU1NfVU5JUVVFID0gQnl0ZVV0aWxzLnJhbmRvbUJ5dGVzKDUpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlcls0XSA9IFBST0NFU1NfVU5JUVVFWzBdO1xuICAgICAgICBidWZmZXJbNV0gPSBQUk9DRVNTX1VOSVFVRVsxXTtcbiAgICAgICAgYnVmZmVyWzZdID0gUFJPQ0VTU19VTklRVUVbMl07XG4gICAgICAgIGJ1ZmZlcls3XSA9IFBST0NFU1NfVU5JUVVFWzNdO1xuICAgICAgICBidWZmZXJbOF0gPSBQUk9DRVNTX1VOSVFVRVs0XTtcbiAgICAgICAgYnVmZmVyWzExXSA9IGluYyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlclsxMF0gPSAoaW5jID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyWzldID0gKGluYyA+PiAxNikgJiAweGZmO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4JylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgc3RhdGljIGlzKHZhcmlhYmxlKSB7XG4gICAgICAgIHJldHVybiAodmFyaWFibGUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhcmlhYmxlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ19ic29udHlwZScgaW4gdmFyaWFibGUgJiZcbiAgICAgICAgICAgIHZhcmlhYmxlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJyk7XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcklkKSB7XG4gICAgICAgIGlmIChvdGhlcklkID09PSB1bmRlZmluZWQgfHwgb3RoZXJJZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3RJZC5pcyhvdGhlcklkKSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmJ1ZmZlclsxMV0gPT09IG90aGVySWQuYnVmZmVyWzExXSAmJiBCeXRlVXRpbHMuZXF1YWxzKHRoaXMuYnVmZmVyLCBvdGhlcklkLmJ1ZmZlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RoZXJJZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBvdGhlcklkLnRvTG93ZXJDYXNlKCkgPT09IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvdGhlcklkLnRvSGV4U3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zdCBvdGhlcklkU3RyaW5nID0gb3RoZXJJZC50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgY29uc3QgdGhpc0lkU3RyaW5nID0gdGhpcy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdGhlcklkU3RyaW5nID09PSAnc3RyaW5nJyAmJiBvdGhlcklkU3RyaW5nLnRvTG93ZXJDYXNlKCkgPT09IHRoaXNJZFN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldFRpbWVzdGFtcCgpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZSA9IE51bWJlclV0aWxzLmdldFVpbnQzMkJFKHRoaXMuYnVmZmVyLCAwKTtcbiAgICAgICAgdGltZXN0YW1wLnNldFRpbWUoTWF0aC5mbG9vcih0aW1lKSAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUGsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gICAgc2VyaWFsaXplSW50byh1aW50OGFycmF5LCBpbmRleCkge1xuICAgICAgICB1aW50OGFycmF5W2luZGV4XSA9IHRoaXMuYnVmZmVyWzBdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgMV0gPSB0aGlzLmJ1ZmZlclsxXTtcbiAgICAgICAgdWludDhhcnJheVtpbmRleCArIDJdID0gdGhpcy5idWZmZXJbMl07XG4gICAgICAgIHVpbnQ4YXJyYXlbaW5kZXggKyAzXSA9IHRoaXMuYnVmZmVyWzNdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgNF0gPSB0aGlzLmJ1ZmZlcls0XTtcbiAgICAgICAgdWludDhhcnJheVtpbmRleCArIDVdID0gdGhpcy5idWZmZXJbNV07XG4gICAgICAgIHVpbnQ4YXJyYXlbaW5kZXggKyA2XSA9IHRoaXMuYnVmZmVyWzZdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgN10gPSB0aGlzLmJ1ZmZlcls3XTtcbiAgICAgICAgdWludDhhcnJheVtpbmRleCArIDhdID0gdGhpcy5idWZmZXJbOF07XG4gICAgICAgIHVpbnQ4YXJyYXlbaW5kZXggKyA5XSA9IHRoaXMuYnVmZmVyWzldO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgMTBdID0gdGhpcy5idWZmZXJbMTBdO1xuICAgICAgICB1aW50OGFycmF5W2luZGV4ICsgMTFdID0gdGhpcy5idWZmZXJbMTFdO1xuICAgICAgICByZXR1cm4gMTI7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tVGltZSh0aW1lKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxMik7XG4gICAgICAgIGZvciAobGV0IGkgPSAxMTsgaSA+PSA0OyBpLS0pXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICBOdW1iZXJVdGlscy5zZXRJbnQzMkJFKGJ1ZmZlciwgMCwgdGltZSk7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoYnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21IZXhTdHJpbmcoaGV4U3RyaW5nKSB7XG4gICAgICAgIGlmIChoZXhTdHJpbmc/Lmxlbmd0aCAhPT0gMjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2hleCBzdHJpbmcgbXVzdCBiZSAyNCBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChCeXRlVXRpbHMuZnJvbUhleChoZXhTdHJpbmcpKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIGlmIChiYXNlNjQ/Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2Jhc2U2NCBzdHJpbmcgbXVzdCBiZSAxNiBjaGFyYWN0ZXJzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzVmFsaWQoaWQpIHtcbiAgICAgICAgaWYgKGlkID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuZXcgT2JqZWN0SWQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICBpZiAodGhpcy50b0hleFN0cmluZylcbiAgICAgICAgICAgIHJldHVybiB7ICRvaWQ6IHRoaXMudG9IZXhTdHJpbmcoKSB9O1xuICAgICAgICByZXR1cm4geyAkb2lkOiB0aGlzLnRvU3RyaW5nKCdoZXgnKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChkb2MuJG9pZCk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIHJldHVybiBgbmV3IE9iamVjdElkKCR7aW5zcGVjdCh0aGlzLnRvSGV4U3RyaW5nKCksIG9wdGlvbnMpfSlgO1xuICAgIH1cbn1cbk9iamVjdElkLmluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYpO1xuXG5mdW5jdGlvbiBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkge1xuICAgIGxldCB0b3RhbExlbmd0aCA9IDQgKyAxO1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNhbGN1bGF0ZUVsZW1lbnQoaS50b1N0cmluZygpLCBvYmplY3RbaV0sIHNlcmlhbGl6ZUZ1bmN0aW9ucywgdHJ1ZSwgaWdub3JlVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Q/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvQlNPTigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGNhbGN1bGF0ZUVsZW1lbnQoa2V5LCBvYmplY3Rba2V5XSwgc2VyaWFsaXplRnVuY3Rpb25zLCBmYWxzZSwgaWdub3JlVW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWxMZW5ndGg7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVFbGVtZW50KG5hbWUsIHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMgPSBmYWxzZSwgaXNBcnJheSA9IGZhbHNlLCBpZ25vcmVVbmRlZmluZWQgPSBmYWxzZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWU/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQlNPTigpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDEgKyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxICsgNCArIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZSkgKyAxO1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlID49IEpTX0lOVF9NSU4gJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA8PSBKU19JTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID49IEJTT05fSU5UMzJfTUlOICYmIHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICBpZiAoaXNBcnJheSB8fCAhaWdub3JlVW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEgKyAxKTtcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHZhbHVlLl9ic29udHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICAgICAgICAgICAgICAgaXNBbnlBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMSArIDQgKyAxKSArIHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDggKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoMTYgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLnNjb3BlICE9IG51bGwgJiYgT2JqZWN0LmtleXModmFsdWUuc2NvcGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5jb2RlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLnNjb3BlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluYXJ5ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGJpbmFyeS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGJpbmFyeS5wb3NpdGlvbiArIDEgKyA0ICsgMSArIDQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIChiaW5hcnkucG9zaXRpb24gKyAxICsgNCArIDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdTeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmRlcmVkX3ZhbHVlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgICAkcmVmOiB2YWx1ZS5jb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAkaWQ6IHZhbHVlLm9pZFxuICAgICAgICAgICAgICAgIH0sIHZhbHVlLmZpZWxkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmRiICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZF92YWx1ZXNbJyRkYiddID0gdmFsdWUuZGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICBpbnRlcm5hbENhbGN1bGF0ZU9iamVjdFNpemUob3JkZXJlZF92YWx1ZXMsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLmdsb2JhbCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5pZ25vcmVDYXNlID8gMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHZhbHVlLm11bHRpbGluZSA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnBhdHRlcm4pICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5vcHRpb25zKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKHZhbHVlLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLnRvU3RyaW5nKCkpICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBhbHBoYWJldGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnNwbGl0KCcnKS5zb3J0KCkuam9pbignJyk7XG59XG5jbGFzcyBCU09OUmVnRXhwIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05SZWdFeHAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGF0dGVybiA9IHBhdHRlcm47XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGFscGhhYmV0aXplKG9wdGlvbnMgPz8gJycpO1xuICAgICAgICBpZiAodGhpcy5wYXR0ZXJuLmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIFJlZ2V4IHBhdHRlcm5zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMucGF0dGVybil9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmRleE9mKCdcXHgwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiBSZWdleCBvcHRpb25zIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KHRoaXMub3B0aW9ucyl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9uc1tpXSA9PT0gJ2knIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAnbScgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd4JyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ2wnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAncycgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICd1JykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBUaGUgcmVndWxhciBleHByZXNzaW9uIG9wdGlvbiBbJHt0aGlzLm9wdGlvbnNbaV19XSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zID8gb3B0aW9ucy5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpIDogJyc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJHJlZ2V4OiB0aGlzLnBhdHRlcm4sICRvcHRpb25zOiB0aGlzLm9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyAkcmVndWxhckV4cHJlc3Npb246IHsgcGF0dGVybjogdGhpcy5wYXR0ZXJuLCBvcHRpb25zOiB0aGlzLm9wdGlvbnMgfSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgaWYgKCckcmVnZXgnIGluIGRvYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2MuJHJlZ2V4ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmIChkb2MuJHJlZ2V4Ll9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCU09OUmVnRXhwKGRvYy4kcmVnZXgsIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kb3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICgnJHJlZ3VsYXJFeHByZXNzaW9uJyBpbiBkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQlNPTlJlZ0V4cChkb2MuJHJlZ3VsYXJFeHByZXNzaW9uLnBhdHRlcm4sIEJTT05SZWdFeHAucGFyc2VPcHRpb25zKGRvYy4kcmVndWxhckV4cHJlc3Npb24ub3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVuZXhwZWN0ZWQgQlNPTlJlZ0V4cCBFSlNPTiBvYmplY3QgZm9ybTogJHtKU09OLnN0cmluZ2lmeShkb2MpfWApO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGNvbnN0IHN0eWxpemUgPSBnZXRTdHlsaXplRnVuY3Rpb24ob3B0aW9ucykgPz8gKHYgPT4gdik7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gc3R5bGl6ZShpbnNwZWN0KHRoaXMucGF0dGVybiksICdyZWdleHAnKTtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBzdHlsaXplKGluc3BlY3QodGhpcy5vcHRpb25zKSwgJ3JlZ2V4cCcpO1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OUmVnRXhwKCR7cGF0dGVybn0sICR7ZmxhZ3N9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBCU09OU3ltYm9sIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05TeW1ib2wnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkc3ltYm9sOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEJTT05TeW1ib2woZG9jLiRzeW1ib2wpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBCU09OU3ltYm9sKCR7aW5zcGVjdCh0aGlzLnZhbHVlLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNvbnN0IExvbmdXaXRob3V0T3ZlcnJpZGVzQ2xhc3MgPSBMb25nO1xuY2xhc3MgVGltZXN0YW1wIGV4dGVuZHMgTG9uZ1dpdGhvdXRPdmVycmlkZXNDbGFzcyB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdUaW1lc3RhbXAnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihsb3cpIHtcbiAgICAgICAgaWYgKGxvdyA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlcigwLCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgc3VwZXIobG93LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChMb25nLmlzTG9uZyhsb3cpKSB7XG4gICAgICAgICAgICBzdXBlcihsb3cubG93LCBsb3cuaGlnaCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvdyA9PT0gJ29iamVjdCcgJiYgJ3QnIGluIGxvdyAmJiAnaScgaW4gbG93KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvdy50ICE9PSAnbnVtYmVyJyAmJiAodHlwZW9mIGxvdy50ICE9PSAnb2JqZWN0JyB8fCBsb3cudC5fYnNvbnR5cGUgIT09ICdJbnQzMicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIHQgYXMgYSBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG93LmkgIT09ICdudW1iZXInICYmICh0eXBlb2YgbG93LmkgIT09ICdvYmplY3QnIHx8IGxvdy5pLl9ic29udHlwZSAhPT0gJ0ludDMyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgaSBhcyBhIG51bWJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IE51bWJlcihsb3cudCk7XG4gICAgICAgICAgICBjb25zdCBpID0gTnVtYmVyKGxvdy5pKTtcbiAgICAgICAgICAgIGlmICh0IDwgMCB8fCBOdW1iZXIuaXNOYU4odCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgYSBwb3NpdGl2ZSB0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA8IDAgfHwgTnVtYmVyLmlzTmFOKGkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGEgcG9zaXRpdmUgaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHQgPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIHQgZXF1YWwgb3IgbGVzcyB0aGFuIHVpbnQzMiBtYXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBpIGVxdWFsIG9yIGxlc3MgdGhhbiB1aW50MzIgbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdXBlcihpLCB0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0EgVGltZXN0YW1wIGNhbiBvbmx5IGJlIGNvbnN0cnVjdGVkIHdpdGg6IGJpZ2ludCwgTG9uZywgb3IgeyB0OiBudW1iZXI7IGk6IG51bWJlciB9Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJHRpbWVzdGFtcDogdGhpcy50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKExvbmcuZnJvbUludCh2YWx1ZSwgdHJ1ZSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChMb25nLmZyb21OdW1iZXIodmFsdWUsIHRydWUpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHsgaTogbG93Qml0cywgdDogaGlnaEJpdHMgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHN0ciwgb3B0UmFkaXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoTG9uZy5mcm9tU3RyaW5nKHN0ciwgdHJ1ZSwgb3B0UmFkaXgpKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICR0aW1lc3RhbXA6IHsgdDogdGhpcy5oaWdoID4+PiAwLCBpOiB0aGlzLmxvdyA+Pj4gMCB9IH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICBjb25zdCBpID0gTG9uZy5pc0xvbmcoZG9jLiR0aW1lc3RhbXAuaSlcbiAgICAgICAgICAgID8gZG9jLiR0aW1lc3RhbXAuaS5nZXRMb3dCaXRzVW5zaWduZWQoKVxuICAgICAgICAgICAgOiBkb2MuJHRpbWVzdGFtcC5pO1xuICAgICAgICBjb25zdCB0ID0gTG9uZy5pc0xvbmcoZG9jLiR0aW1lc3RhbXAudClcbiAgICAgICAgICAgID8gZG9jLiR0aW1lc3RhbXAudC5nZXRMb3dCaXRzVW5zaWduZWQoKVxuICAgICAgICAgICAgOiBkb2MuJHRpbWVzdGFtcC50O1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7IHQsIGkgfSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIGNvbnN0IHQgPSBpbnNwZWN0KHRoaXMuaGlnaCA+Pj4gMCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGkgPSBpbnNwZWN0KHRoaXMubG93ID4+PiAwLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGBuZXcgVGltZXN0YW1wKHsgdDogJHt0fSwgaTogJHtpfSB9KWA7XG4gICAgfVxufVxuVGltZXN0YW1wLk1BWF9WQUxVRSA9IExvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFO1xuXG5jb25zdCBKU19JTlRfTUFYX0xPTkcgPSBMb25nLmZyb21OdW1iZXIoSlNfSU5UX01BWCk7XG5jb25zdCBKU19JTlRfTUlOX0xPTkcgPSBMb25nLmZyb21OdW1iZXIoSlNfSU5UX01JTik7XG5mdW5jdGlvbiBpbnRlcm5hbERlc2VyaWFsaXplKGJ1ZmZlciwgb3B0aW9ucywgaXNBcnJheSkge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID09IG51bGwgPyB7fSA6IG9wdGlvbnM7XG4gICAgY29uc3QgaW5kZXggPSBvcHRpb25zICYmIG9wdGlvbnMuaW5kZXggPyBvcHRpb25zLmluZGV4IDogMDtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICBpZiAoc2l6ZSA8IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgYnNvbiBzaXplIG11c3QgYmUgPj0gNSwgaXMgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSAmJiBidWZmZXIubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmxlbmd0aH0gbXVzdCBiZSA+PSBic29uIHNpemUgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemUgJiYgYnVmZmVyLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmxlbmd0aH0gbXVzdCA9PT0gYnNvbiBzaXplICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgaWYgKHNpemUgKyBpbmRleCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYChic29uIHNpemUgJHtzaXplfSArIG9wdGlvbnMuaW5kZXggJHtpbmRleH0gbXVzdCBiZSA8PSBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmJ5dGVMZW5ndGh9KWApO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyW2luZGV4ICsgc2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoXCJPbmUgb2JqZWN0LCBzaXplZCBjb3JyZWN0bHksIHdpdGggYSBzcG90IGZvciBhbiBFT08sIGJ1dCB0aGUgRU9PIGlzbid0IDB4MDBcIik7XG4gICAgfVxuICAgIHJldHVybiBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGluZGV4LCBvcHRpb25zLCBpc0FycmF5KTtcbn1cbmNvbnN0IGFsbG93ZWREQlJlZktleXMgPSAvXlxcJHJlZiR8XlxcJGlkJHxeXFwkZGIkLztcbmZ1bmN0aW9uIGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgaW5kZXgsIG9wdGlvbnMsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZpZWxkc0FzUmF3ID0gb3B0aW9uc1snZmllbGRzQXNSYXcnXSA9PSBudWxsID8gbnVsbCA6IG9wdGlvbnNbJ2ZpZWxkc0FzUmF3J107XG4gICAgY29uc3QgcmF3ID0gb3B0aW9uc1sncmF3J10gPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9uc1sncmF3J107XG4gICAgY29uc3QgYnNvblJlZ0V4cCA9IHR5cGVvZiBvcHRpb25zWydic29uUmVnRXhwJ10gPT09ICdib29sZWFuJyA/IG9wdGlvbnNbJ2Jzb25SZWdFeHAnXSA6IGZhbHNlO1xuICAgIGNvbnN0IHByb21vdGVCdWZmZXJzID0gb3B0aW9ucy5wcm9tb3RlQnVmZmVycyA/PyBmYWxzZTtcbiAgICBjb25zdCBwcm9tb3RlTG9uZ3MgPSBvcHRpb25zLnByb21vdGVMb25ncyA/PyB0cnVlO1xuICAgIGNvbnN0IHByb21vdGVWYWx1ZXMgPSBvcHRpb25zLnByb21vdGVWYWx1ZXMgPz8gdHJ1ZTtcbiAgICBjb25zdCB1c2VCaWdJbnQ2NCA9IG9wdGlvbnMudXNlQmlnSW50NjQgPz8gZmFsc2U7XG4gICAgaWYgKHVzZUJpZ0ludDY0ICYmICFwcm9tb3RlVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ011c3QgZWl0aGVyIHJlcXVlc3QgYmlnaW50IG9yIExvbmcgZm9yIGludDY0IGRlc2VyaWFsaXphdGlvbicpO1xuICAgIH1cbiAgICBpZiAodXNlQmlnSW50NjQgJiYgIXByb21vdGVMb25ncykge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdNdXN0IGVpdGhlciByZXF1ZXN0IGJpZ2ludCBvciBMb25nIGZvciBpbnQ2NCBkZXNlcmlhbGl6YXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IG9wdGlvbnMudmFsaWRhdGlvbiA9PSBudWxsID8geyB1dGY4OiB0cnVlIH0gOiBvcHRpb25zLnZhbGlkYXRpb247XG4gICAgbGV0IGdsb2JhbFVURlZhbGlkYXRpb24gPSB0cnVlO1xuICAgIGxldCB2YWxpZGF0aW9uU2V0dGluZztcbiAgICBsZXQgdXRmOEtleXNTZXQ7XG4gICAgY29uc3QgdXRmOFZhbGlkYXRlZEtleXMgPSB2YWxpZGF0aW9uLnV0Zjg7XG4gICAgaWYgKHR5cGVvZiB1dGY4VmFsaWRhdGVkS2V5cyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZhbGlkYXRpb25TZXR0aW5nID0gdXRmOFZhbGlkYXRlZEtleXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBnbG9iYWxVVEZWYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHV0ZjhWYWxpZGF0aW9uVmFsdWVzID0gT2JqZWN0LmtleXModXRmOFZhbGlkYXRlZEtleXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdXRmOFZhbGlkYXRlZEtleXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1dGY4VmFsaWRhdGlvblZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1VURi04IHZhbGlkYXRpb24gc2V0dGluZyBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHV0ZjhWYWxpZGF0aW9uVmFsdWVzWzBdICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggdmFsaWRhdGlvbiBvcHRpb24sIG11c3Qgc3BlY2lmeSBib29sZWFuIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb25TZXR0aW5nID0gdXRmOFZhbGlkYXRpb25WYWx1ZXNbMF07XG4gICAgICAgIGlmICghdXRmOFZhbGlkYXRpb25WYWx1ZXMuZXZlcnkoaXRlbSA9PiBpdGVtID09PSB2YWxpZGF0aW9uU2V0dGluZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggdmFsaWRhdGlvbiBvcHRpb24gLSBrZXlzIG11c3QgYmUgYWxsIHRydWUgb3IgYWxsIGZhbHNlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgIHV0ZjhLZXlzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh1dGY4VmFsaWRhdGVkS2V5cykpIHtcbiAgICAgICAgICAgIHV0ZjhLZXlzU2V0LmFkZChrZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDUpXG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlIDwgNSBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgaW5kZXggKz0gNDtcbiAgICBpZiAoc2l6ZSA8IDUgfHwgc2l6ZSA+IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlJyk7XG4gICAgY29uc3Qgb2JqZWN0ID0gaXNBcnJheSA/IFtdIDoge307XG4gICAgbGV0IGFycmF5SW5kZXggPSAwO1xuICAgIGNvbnN0IGRvbmUgPSBmYWxzZTtcbiAgICBsZXQgaXNQb3NzaWJsZURCUmVmID0gaXNBcnJheSA/IGZhbHNlIDogbnVsbDtcbiAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudFR5cGUgPSBidWZmZXJbaW5kZXgrK107XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgaSA9IGluZGV4O1xuICAgICAgICB3aGlsZSAoYnVmZmVyW2ldICE9PSAweDAwICYmIGkgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPj0gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCYWQgQlNPTiBEb2N1bWVudDogaWxsZWdhbCBDU3RyaW5nJyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpc0FycmF5ID8gYXJyYXlJbmRleCsrIDogQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpLCBmYWxzZSk7XG4gICAgICAgIGxldCBzaG91bGRWYWxpZGF0ZUtleSA9IHRydWU7XG4gICAgICAgIGlmIChnbG9iYWxVVEZWYWxpZGF0aW9uIHx8IHV0ZjhLZXlzU2V0Py5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHNob3VsZFZhbGlkYXRlS2V5ID0gdmFsaWRhdGlvblNldHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaG91bGRWYWxpZGF0ZUtleSA9ICF2YWxpZGF0aW9uU2V0dGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQb3NzaWJsZURCUmVmICE9PSBmYWxzZSAmJiBuYW1lWzBdID09PSAnJCcpIHtcbiAgICAgICAgICAgIGlzUG9zc2libGVEQlJlZiA9IGFsbG93ZWREQlJlZktleXMudGVzdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWU7XG4gICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1NUUklORykge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9PSUQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9pZCA9IEJ5dGVVdGlscy5hbGxvY2F0ZVVuc2FmZSgxMik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEyOyBpKyspXG4gICAgICAgICAgICAgICAgb2lkW2ldID0gYnVmZmVyW2luZGV4ICsgaV07XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBPYmplY3RJZChvaWQpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDEyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfSU5UICYmIHByb21vdGVWYWx1ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBJbnQzMihOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpKTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9JTlQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9OVU1CRVIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyVXRpbHMuZ2V0RmxvYXQ2NExFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgICAgIGlmIChwcm9tb3RlVmFsdWVzID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBEb3VibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfREFURSkge1xuICAgICAgICAgICAgY29uc3QgbG93Qml0cyA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBoaWdoQml0cyA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCArIDQpO1xuICAgICAgICAgICAgaW5kZXggKz0gODtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUobmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMpLnRvTnVtYmVyKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQk9PTEVBTikge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpbmRleF0gIT09IDAgJiYgYnVmZmVyW2luZGV4XSAhPT0gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdpbGxlZ2FsIGJvb2xlYW4gdHlwZSB2YWx1ZScpO1xuICAgICAgICAgICAgdmFsdWUgPSBidWZmZXJbaW5kZXgrK10gPT09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9PQkpFQ1QpIHtcbiAgICAgICAgICAgIGNvbnN0IF9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0U2l6ZSA8PSAwIHx8IG9iamVjdFNpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIGVtYmVkZGVkIGRvY3VtZW50IGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgb2JqZWN0U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHZhbGlkYXRpb246IHsgdXRmODogc2hvdWxkVmFsaWRhdGVLZXkgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBvYmplY3RPcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0FSUkFZKSB7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgbGV0IGFycmF5T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzdG9wSW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgICAgICBpZiAoZmllbGRzQXNSYXcgJiYgZmllbGRzQXNSYXdbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHJhdzogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlPcHRpb25zID0geyAuLi5hcnJheU9wdGlvbnMsIHZhbGlkYXRpb246IHsgdXRmODogc2hvdWxkVmFsaWRhdGVLZXkgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIF9pbmRleCwgYXJyYXlPcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlcltpbmRleCAtIDFdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2ludmFsaWQgYXJyYXkgdGVybWluYXRvciBieXRlJyk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IHN0b3BJbmRleClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0ZWQgYXJyYXkgYnNvbicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfVU5ERUZJTkVEKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX05VTEwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0xPTkcpIHtcbiAgICAgICAgICAgIGlmICh1c2VCaWdJbnQ2NCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTnVtYmVyVXRpbHMuZ2V0QmlnSW50NjRMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG93Qml0cyA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaEJpdHMgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXggKyA0KTtcbiAgICAgICAgICAgICAgICBpbmRleCArPSA4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvbmcgPSBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHByb21vdGVMb25ncyAmJiBwcm9tb3RlVmFsdWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmcubGVzc1RoYW5PckVxdWFsKEpTX0lOVF9NQVhfTE9ORykgJiYgbG9uZy5ncmVhdGVyVGhhbk9yRXF1YWwoSlNfSU5UX01JTl9MT05HKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbG9uZy50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBsb25nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsb25nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0RFQ0lNQUwxMjgpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gQnl0ZVV0aWxzLmFsbG9jYXRlVW5zYWZlKDE2KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKylcbiAgICAgICAgICAgICAgICBieXRlc1tpXSA9IGJ1ZmZlcltpbmRleCArIGldO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE2O1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgRGVjaW1hbDEyOChieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9CSU5BUlkpIHtcbiAgICAgICAgICAgIGxldCBiaW5hcnlTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEJpbmFyeVNpemUgPSBiaW5hcnlTaXplO1xuICAgICAgICAgICAgY29uc3Qgc3ViVHlwZSA9IGJ1ZmZlcltpbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdOZWdhdGl2ZSBiaW5hcnkgdHlwZSBlbGVtZW50IHNpemUgZm91bmQnKTtcbiAgICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgc2l6ZSBsYXJnZXIgdGhhbiBkb2N1bWVudCBzaXplJyk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyWydzbGljZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSkge1xuICAgICAgICAgICAgICAgICAgICBiaW5hcnlTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignTmVnYXRpdmUgYmluYXJ5IHR5cGUgZWxlbWVudCBzaXplIGZvdW5kIGZvciBzdWJ0eXBlIDB4MDInKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIGxvbmcgYmluYXJ5IHNpemUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCB0b3RhbEJpbmFyeVNpemUgLSA0KVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IHR5cGUgd2l0aCBzdWJ0eXBlIDB4MDIgY29udGFpbnMgdG9vIHNob3J0IGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9tb3RlQnVmZmVycyAmJiBwcm9tb3RlVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBCaW5hcnkoYnVmZmVyLnNsaWNlKGluZGV4LCBpbmRleCArIGJpbmFyeVNpemUpLCBzdWJUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YlR5cGUgPT09IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgJiYgVVVJRC5pc1ZhbGlkKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VVSUQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVNpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IDApXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdOZWdhdGl2ZSBiaW5hcnkgdHlwZSBlbGVtZW50IHNpemUgZm91bmQgZm9yIHN1YnR5cGUgMHgwMicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA+IHRvdGFsQmluYXJ5U2l6ZSAtIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gbG9uZyBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5U2l6ZSA8IHRvdGFsQmluYXJ5U2l6ZSAtIDQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSB3aXRoIHN1YnR5cGUgMHgwMiBjb250YWlucyB0b28gc2hvcnQgYmluYXJ5IHNpemUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb21vdGVCdWZmZXJzICYmIHByb21vdGVWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBCeXRlVXRpbHMuYWxsb2NhdGVVbnNhZmUoYmluYXJ5U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBiaW5hcnlTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gYnVmZmVyW2luZGV4ICsgaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IEJpbmFyeShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgYmluYXJ5U2l6ZSksIHN1YlR5cGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ViVHlwZSA9PT0gQlNPTl9CSU5BUllfU1VCVFlQRV9VVUlEX05FVyAmJiBVVUlELmlzVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVVVJRCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIGJpbmFyeVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9SRUdFWFAgJiYgYnNvblJlZ0V4cCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cE9wdGlvbnMgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGksIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zQXJyYXkgPSBuZXcgQXJyYXkocmVnRXhwT3B0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlZ0V4cE9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlZ0V4cE9wdGlvbnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnZyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zQXJyYXlbaV0gPSAnaSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBSZWdFeHAoc291cmNlLCBvcHRpb25zQXJyYXkuam9pbignJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfUkVHRVhQICYmIGJzb25SZWdFeHAgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGkgPSBpbmRleDtcbiAgICAgICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+PSBidWZmZXIubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZ0V4cE9wdGlvbnMgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGksIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBCU09OUmVnRXhwKHNvdXJjZSwgcmVnRXhwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9TWU1CT0wpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ltYm9sID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICB2YWx1ZSA9IHByb21vdGVWYWx1ZXMgPyBzeW1ib2wgOiBuZXcgQlNPTlN5bWJvbChzeW1ib2wpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9USU1FU1RBTVApIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFRpbWVzdGFtcCh7XG4gICAgICAgICAgICAgICAgaTogTnVtYmVyVXRpbHMuZ2V0VWludDMyTEUoYnVmZmVyLCBpbmRleCksXG4gICAgICAgICAgICAgICAgdDogTnVtYmVyVXRpbHMuZ2V0VWludDMyTEUoYnVmZmVyLCBpbmRleCArIDQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9NSU5fS0VZKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBNaW5LZXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX01BWF9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE1heEtleSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQ09ERSkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSA0O1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ29kZShmdW5jdGlvblN0cmluZyk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0NPREVfV19TQ09QRSkge1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgICAgICBpZiAodG90YWxTaXplIDwgNCArIDQgKyA0ICsgMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIHNob3J0ZXIgbWluaW11bSBleHBlY3RlZCBsZW5ndGgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25TdHJpbmcgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICAgICAgY29uc3QgX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTaXplID0gTnVtYmVyVXRpbHMuZ2V0SW50MzJMRShidWZmZXIsIGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZGVzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBfaW5kZXgsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBvYmplY3RTaXplO1xuICAgICAgICAgICAgaWYgKHRvdGFsU2l6ZSA8IDQgKyA0ICsgb2JqZWN0U2l6ZSArIHN0cmluZ1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb2RlX3dfc2NvcGUgdG90YWwgc2l6ZSBpcyB0b28gc2hvcnQsIHRydW5jYXRpbmcgc2NvcGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPiA0ICsgNCArIG9iamVjdFNpemUgKyBzdHJpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgaXMgdG9vIGxvbmcsIGNsaXBzIG91dGVyIGRvY3VtZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDb2RlKGZ1bmN0aW9uU3RyaW5nLCBzY29wZU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9EQlBPSU5URVIpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBOdW1iZXJVdGlscy5nZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgpO1xuICAgICAgICAgICAgaW5kZXggKz0gNDtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uICE9IG51bGwgJiYgdmFsaWRhdGlvbi51dGY4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVV0ZjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCBzdHJpbmcgaW4gQlNPTiBkb2N1bWVudCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgICAgICBjb25zdCBvaWRCdWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGVVbnNhZmUoMTIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICAgICAgICAgIG9pZEJ1ZmZlcltpXSA9IGJ1ZmZlcltpbmRleCArIGldO1xuICAgICAgICAgICAgY29uc3Qgb2lkID0gbmV3IE9iamVjdElkKG9pZEJ1ZmZlcik7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTI7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEQlJlZihuYW1lc3BhY2UsIG9pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBEZXRlY3RlZCB1bmtub3duIEJTT04gdHlwZSAke2VsZW1lbnRUeXBlLnRvU3RyaW5nKDE2KX0gZm9yIGZpZWxkbmFtZSBcIiR7bmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzaXplICE9PSBpbmRleCAtIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgaWYgKGlzQXJyYXkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IGFycmF5IGJzb24nKTtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29ycnVwdCBvYmplY3QgYnNvbicpO1xuICAgIH1cbiAgICBpZiAoIWlzUG9zc2libGVEQlJlZilcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICBpZiAoaXNEQlJlZkxpa2Uob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqZWN0KTtcbiAgICAgICAgZGVsZXRlIGNvcHkuJHJlZjtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGlkO1xuICAgICAgICBkZWxldGUgY29weS4kZGI7XG4gICAgICAgIHJldHVybiBuZXcgREJSZWYob2JqZWN0LiRyZWYsIG9iamVjdC4kaWQsIG9iamVjdC4kZGIsIGNvcHkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG5jb25zdCByZWdleHAgPSAvXFx4MDAvO1xuY29uc3QgaWdub3JlS2V5cyA9IG5ldyBTZXQoWyckZGInLCAnJHJlZicsICckaWQnLCAnJGNsdXN0ZXJUaW1lJ10pO1xuZnVuY3Rpb24gc2VyaWFsaXplU3RyaW5nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfU1RSSU5HO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzICsgMTtcbiAgICBidWZmZXJbaW5kZXggLSAxXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIHZhbHVlLCBpbmRleCArIDQpO1xuICAgIE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSArIDEpO1xuICAgIGluZGV4ID0gaW5kZXggKyA0ICsgc2l6ZTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBPYmplY3QuaXModmFsdWUsIC0wKTtcbiAgICBjb25zdCB0eXBlID0gIWlzTmVnYXRpdmVaZXJvICYmXG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJlxuICAgICAgICB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTlxuICAgICAgICA/IEJTT05fREFUQV9JTlRcbiAgICAgICAgOiBCU09OX0RBVEFfTlVNQkVSO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHR5cGU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBpZiAodHlwZSA9PT0gQlNPTl9EQVRBX0lOVCkge1xuICAgICAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEZsb2F0NjRMRShidWZmZXIsIGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0xPTkc7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCArPSBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEJpZ0ludDY0TEUoYnVmZmVyLCBpbmRleCwgdmFsdWUpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIF8sIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQk9PTEVBTjtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHZhbHVlID8gMSA6IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RBVEU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBkYXRlSW5NaWxpcyA9IExvbmcuZnJvbU51bWJlcih2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIGNvbnN0IGxvd0JpdHMgPSBkYXRlSW5NaWxpcy5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSBkYXRlSW5NaWxpcy5nZXRIaWdoQml0cygpO1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgbG93Qml0cyk7XG4gICAgaW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBoaWdoQml0cyk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2UubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3ZhbHVlICcgKyB2YWx1ZS5zb3VyY2UgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUuc291cmNlLCBpbmRleCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBpZiAodmFsdWUuaWdub3JlQ2FzZSlcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMHg2OTtcbiAgICBpZiAodmFsdWUuZ2xvYmFsKVxuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAweDczO1xuICAgIGlmICh2YWx1ZS5tdWx0aWxpbmUpXG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4NmQ7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnBhdHRlcm4ubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3BhdHRlcm4gJyArIHZhbHVlLnBhdHRlcm4gKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUucGF0dGVybiwgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgY29uc3Qgc29ydGVkT3B0aW9ucyA9IHZhbHVlLm9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKTtcbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgc29ydGVkT3B0aW9ucywgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX01JTl9LRVk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTUFYX0tFWTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09JRDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGluZGV4ICs9IHZhbHVlLnNlcmlhbGl6ZUludG8oYnVmZmVyLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHNpemUpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDtcbiAgICBpZiAoc2l6ZSA8PSAxNikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIGldID0gdmFsdWVbaV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgfVxuICAgIGluZGV4ID0gaW5kZXggKyBzaXplO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCkge1xuICAgIGlmIChwYXRoLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ2Fubm90IGNvbnZlcnQgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEJTT04nKTtcbiAgICB9XG4gICAgcGF0aC5hZGQodmFsdWUpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gQlNPTl9EQVRBX0FSUkFZIDogQlNPTl9EQVRBX09CSkVDVDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGVuZEluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIHZhbHVlLCBjaGVja0tleXMsIGluZGV4LCBkZXB0aCArIDEsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICBwYXRoLmRlbGV0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGVuZEluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RFQ0lNQUwxMjg7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspXG4gICAgICAgIGJ1ZmZlcltpbmRleCArIGldID0gdmFsdWUuYnl0ZXNbaV07XG4gICAgcmV0dXJuIGluZGV4ICsgMTY7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPVxuICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyA/IEJTT05fREFUQV9MT05HIDogQlNPTl9EQVRBX1RJTUVTVEFNUDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGxvd0JpdHMgPSB2YWx1ZS5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSB2YWx1ZS5nZXRIaWdoQml0cygpO1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgbG93Qml0cyk7XG4gICAgaW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBoaWdoQml0cyk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9JTlQ7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9OVU1CRVI7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBpbmRleCArPSBOdW1iZXJVdGlscy5zZXRGbG9hdDY0TEUoYnVmZmVyLCBpbmRleCwgdmFsdWUudmFsdWUpO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgIE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSk7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzID0gZmFsc2UsIGRlcHRoID0gMCwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCA9IHRydWUsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUuc2NvcGUgJiYgdHlwZW9mIHZhbHVlLnNjb3BlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERV9XX1NDT1BFO1xuICAgICAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQ7XG4gICAgICAgIGNvbnN0IGNvZGVTaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgICAgICBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIGNvZGVTaXplKTtcbiAgICAgICAgYnVmZmVyW2luZGV4ICsgNCArIGNvZGVTaXplIC0gMV0gPSAwO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgY29kZVNpemUgKyA0O1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCB2YWx1ZS5zY29wZSwgY2hlY2tLZXlzLCBpbmRleCwgZGVwdGggKyAxLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgIGluZGV4ID0gZW5kSW5kZXggLSAxO1xuICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgICAgIHN0YXJ0SW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIHN0YXJ0SW5kZXgsIHRvdGFsU2l6ZSk7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERTtcbiAgICAgICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IHZhbHVlLmNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGZ1bmN0aW9uU3RyaW5nLCBpbmRleCArIDQpICsgMTtcbiAgICAgICAgTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBzaXplKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZGF0YSA9IHZhbHVlLmJ1ZmZlcjtcbiAgICBsZXQgc2l6ZSA9IHZhbHVlLnBvc2l0aW9uO1xuICAgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSlcbiAgICAgICAgc2l6ZSA9IHNpemUgKyA0O1xuICAgIGluZGV4ICs9IE51bWJlclV0aWxzLnNldEludDMyTEUoYnVmZmVyLCBpbmRleCwgc2l6ZSk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgaWYgKHZhbHVlLnN1Yl90eXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgIHNpemUgPSBzaXplIC0gNDtcbiAgICAgICAgaW5kZXggKz0gTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBzaXplKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPD0gMTYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaW5kZXggKyBpXSA9IGRhdGFbaV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXIuc2V0KGRhdGEsIGluZGV4KTtcbiAgICB9XG4gICAgaW5kZXggPSBpbmRleCArIHZhbHVlLnBvc2l0aW9uO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX1NZTUJPTDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IHNpemUgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCB2YWx1ZS52YWx1ZSwgaW5kZXggKyA0KSArIDE7XG4gICAgTnVtYmVyVXRpbHMuc2V0SW50MzJMRShidWZmZXIsIGluZGV4LCBzaXplKTtcbiAgICBpbmRleCA9IGluZGV4ICsgNCArIHNpemUgLSAxO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplREJSZWYoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgcGF0aCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9PQkpFQ1Q7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgIGxldCBvdXRwdXQgPSB7XG4gICAgICAgICRyZWY6IHZhbHVlLmNvbGxlY3Rpb24gfHwgdmFsdWUubmFtZXNwYWNlLFxuICAgICAgICAkaWQ6IHZhbHVlLm9pZFxuICAgIH07XG4gICAgaWYgKHZhbHVlLmRiICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0LiRkYiA9IHZhbHVlLmRiO1xuICAgIH1cbiAgICBvdXRwdXQgPSBPYmplY3QuYXNzaWduKG91dHB1dCwgdmFsdWUuZmllbGRzKTtcbiAgICBjb25zdCBlbmRJbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvdXRwdXQsIGZhbHNlLCBpbmRleCwgZGVwdGggKyAxLCBzZXJpYWxpemVGdW5jdGlvbnMsIHRydWUsIHBhdGgpO1xuICAgIGNvbnN0IHNpemUgPSBlbmRJbmRleCAtIHN0YXJ0SW5kZXg7XG4gICAgc3RhcnRJbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgaW5kZXgsIHNpemUpO1xuICAgIHJldHVybiBlbmRJbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgc3RhcnRpbmdJbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKSB7XG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGJ1ZmZlclswXSA9IDB4MDU7XG4gICAgICAgICAgICBidWZmZXJbMV0gPSAweDAwO1xuICAgICAgICAgICAgYnVmZmVyWzJdID0gMHgwMDtcbiAgICAgICAgICAgIGJ1ZmZlclszXSA9IDB4MDA7XG4gICAgICAgICAgICBidWZmZXJbNF0gPSAweDAwO1xuICAgICAgICAgICAgcmV0dXJuIDU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignc2VyaWFsaXplIGRvZXMgbm90IHN1cHBvcnQgYW4gYXJyYXkgYXMgdGhlIHJvb3QgaW5wdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3NlcmlhbGl6ZSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1vYmplY3QgYXMgdGhlIHJvb3QgaW5wdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnX2Jzb250eXBlJyBpbiBvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5fYnNvbnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIHR5cGVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGFzIGEgZG9jdW1lbnRgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RhdGUob2JqZWN0KSB8fFxuICAgICAgICAgICAgaXNSZWdFeHAob2JqZWN0KSB8fFxuICAgICAgICAgICAgaXNVaW50OEFycmF5KG9iamVjdCkgfHxcbiAgICAgICAgICAgIGlzQW55QXJyYXlCdWZmZXIob2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgZGF0ZSwgcmVnZXhwLCB0eXBlZGFycmF5LCBhbmQgYXJyYXlidWZmZXIgY2Fubm90IGJlIEJTT04gZG9jdW1lbnRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aCA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgcGF0aC5hZGQob2JqZWN0KTtcbiAgICBsZXQgaW5kZXggPSBzdGFydGluZ0luZGV4ICsgNDtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtpfWA7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvYmplY3RbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlPy50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN0cmluZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURhdGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RvdWJsZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURvdWJsZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQ29kZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlN5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RCUmVmJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplREJSZWYoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0ludDMyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU1pbk1heChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAke1N0cmluZyh2YWx1ZS5fYnNvbnR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIE1hcCB8fCBpc01hcChvYmplY3QpKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gb2JqZWN0LmVudHJpZXMoKTtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyeSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGRvbmUgPSAhIWVudHJ5LmRvbmU7XG4gICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGVudHJ5LnZhbHVlWzBdO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gZW50cnkudmFsdWVbMV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlPy50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhaWdub3JlS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2tleSAnICsga2V5ICsgJyBtdXN0IG5vdCBjb250YWluIG51bGwgYnl0ZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJyQnID09PSBrZXlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2tleSAnICsga2V5ICsgXCIgbXVzdCBub3Qgc3RhcnQgd2l0aCAnJCdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2tleSAnICsga2V5ICsgXCIgbXVzdCBub3QgY29udGFpbiAnLidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN0cmluZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdW1iZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmlnSW50KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURhdGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBpZ25vcmVVbmRlZmluZWQgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RvdWJsZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURvdWJsZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlN5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RCUmVmJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplREJSZWYoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0ludDMyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU1pbk1heChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAke1N0cmluZyh2YWx1ZS5fYnNvbnR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIG9iamVjdD8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3QgPSBvYmplY3QudG9CU09OKCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCd0b0JTT04gZnVuY3Rpb24gZGlkIG5vdCByZXR1cm4gYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqZWN0KSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlPy50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvQlNPTigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiAhaWdub3JlS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2tleSAnICsga2V5ICsgJyBtdXN0IG5vdCBjb250YWluIG51bGwgYnl0ZXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoJyQnID09PSBrZXlbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2tleSAnICsga2V5ICsgXCIgbXVzdCBub3Qgc3RhcnQgd2l0aCAnJCdcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5LmluY2x1ZGVzKCcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2tleSAnICsga2V5ICsgXCIgbXVzdCBub3QgY29udGFpbiAnLidcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN0cmluZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdW1iZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmlnSW50KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURhdGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZVVuZGVmaW5lZCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZVtTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdElkKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09PSAnRGVjaW1hbDEyOCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURlY2ltYWwxMjgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdUaW1lc3RhbXAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRG91YmxlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQ29kZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIHNlcmlhbGl6ZUZ1bmN0aW9ucykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCaW5hcnknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaW5hcnkoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplU3ltYm9sKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEQlJlZihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnSW50MzInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVJbnQzMihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnTWF4S2V5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlLl9ic29udHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICR7U3RyaW5nKHZhbHVlLl9ic29udHlwZSl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5kZWxldGUob2JqZWN0KTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIGNvbnN0IHNpemUgPSBpbmRleCAtIHN0YXJ0aW5nSW5kZXg7XG4gICAgc3RhcnRpbmdJbmRleCArPSBOdW1iZXJVdGlscy5zZXRJbnQzMkxFKGJ1ZmZlciwgc3RhcnRpbmdJbmRleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG5mdW5jdGlvbiBpc0JTT05UeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ19ic29udHlwZScgaW4gdmFsdWUgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlLl9ic29udHlwZSA9PT0gJ3N0cmluZycpO1xufVxuY29uc3Qga2V5c1RvQ29kZWNzID0ge1xuICAgICRvaWQ6IE9iamVjdElkLFxuICAgICRiaW5hcnk6IEJpbmFyeSxcbiAgICAkdXVpZDogQmluYXJ5LFxuICAgICRzeW1ib2w6IEJTT05TeW1ib2wsXG4gICAgJG51bWJlckludDogSW50MzIsXG4gICAgJG51bWJlckRlY2ltYWw6IERlY2ltYWwxMjgsXG4gICAgJG51bWJlckRvdWJsZTogRG91YmxlLFxuICAgICRudW1iZXJMb25nOiBMb25nLFxuICAgICRtaW5LZXk6IE1pbktleSxcbiAgICAkbWF4S2V5OiBNYXhLZXksXG4gICAgJHJlZ2V4OiBCU09OUmVnRXhwLFxuICAgICRyZWd1bGFyRXhwcmVzc2lvbjogQlNPTlJlZ0V4cCxcbiAgICAkdGltZXN0YW1wOiBUaW1lc3RhbXBcbn07XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBpbjMyQml0UmFuZ2UgPSB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJiB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTjtcbiAgICAgICAgY29uc3QgaW42NEJpdFJhbmdlID0gdmFsdWUgPD0gQlNPTl9JTlQ2NF9NQVggJiYgdmFsdWUgPj0gQlNPTl9JTlQ2NF9NSU47XG4gICAgICAgIGlmIChvcHRpb25zLnJlbGF4ZWQgfHwgb3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgICBpZiAoaW4zMkJpdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW42NEJpdFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRG91YmxlKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGlmICh2YWx1ZS4kdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnJCcpICYmIHZhbHVlW2tdICE9IG51bGwpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjID0ga2V5c1RvQ29kZWNzW2tleXNbaV1dO1xuICAgICAgICBpZiAoYylcbiAgICAgICAgICAgIHJldHVybiBjLmZyb21FeHRlbmRlZEpTT04odmFsdWUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUuJGRhdGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkID0gdmFsdWUuJGRhdGU7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoTnVtYmVyKGQpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlJ1bnRpbWVFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgZm9yIEVKU09OIGRhdGU6ICR7dHlwZW9mIGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGQgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShEYXRlLnBhcnNlKGQpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKExvbmcuaXNMb25nKGQpKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkLnRvTnVtYmVyKCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdudW1iZXInICYmIG9wdGlvbnMucmVsYXhlZClcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKE51bWJlcihkKSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05SdW50aW1lRXJyb3IoYFVucmVjb2duaXplZCB0eXBlIGZvciBFSlNPTiBkYXRlOiAke3R5cGVvZiBkfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgIH1cbiAgICBpZiAodmFsdWUuJGNvZGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUuJHNjb3BlKSB7XG4gICAgICAgICAgICBjb3B5LiRzY29wZSA9IGRlc2VyaWFsaXplVmFsdWUodmFsdWUuJHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29kZS5mcm9tRXh0ZW5kZWRKU09OKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzREJSZWZMaWtlKHZhbHVlKSB8fCB2YWx1ZS4kZGJQb2ludGVyKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWx1ZS4kcmVmID8gdmFsdWUgOiB2YWx1ZS4kZGJQb2ludGVyO1xuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIERCUmVmKVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNvbnN0IGRvbGxhcktleXMgPSBPYmplY3Qua2V5cyh2KS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoJyQnKSk7XG4gICAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICAgIGRvbGxhcktleXMuZm9yRWFjaChrID0+IHtcbiAgICAgICAgICAgIGlmIChbJyRyZWYnLCAnJGlkJywgJyRkYiddLmluZGV4T2YoaykgPT09IC0xKVxuICAgICAgICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gREJSZWYuZnJvbUV4dGVuZGVkSlNPTih2KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXkoYXJyYXksIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYXJyYXkubWFwKCh2LCBpbmRleCkgPT4ge1xuICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnB1c2goeyBwcm9wZXJ0eU5hbWU6IGBpbmRleCAke2luZGV4fWAsIG9iajogbnVsbCB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVWYWx1ZSh2LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldElTT1N0cmluZyhkYXRlKSB7XG4gICAgY29uc3QgaXNvU3RyID0gZGF0ZS50b0lTT1N0cmluZygpO1xuICAgIHJldHVybiBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpICE9PSAwID8gaXNvU3RyIDogaXNvU3RyLnNsaWNlKDAsIC01KSArICdaJztcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IGlzTWFwKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0NhbiBvbmx5IHNlcmlhbGl6ZSBtYXBzIHdpdGggc3RyaW5nIGtleXMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9ialtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKG9iaiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucy5zZWVuT2JqZWN0cy5maW5kSW5kZXgoZW50cnkgPT4gZW50cnkub2JqID09PSB2YWx1ZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BzID0gb3B0aW9ucy5zZWVuT2JqZWN0cy5tYXAoZW50cnkgPT4gZW50cnkucHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdQYXJ0ID0gcHJvcHNcbiAgICAgICAgICAgICAgICAuc2xpY2UoMCwgaW5kZXgpXG4gICAgICAgICAgICAgICAgLm1hcChwcm9wID0+IGAke3Byb3B9IC0+IGApXG4gICAgICAgICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeVNlZW4gPSBwcm9wc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBjaXJjdWxhclBhcnQgPSAnIC0+ICcgK1xuICAgICAgICAgICAgICAgIHByb3BzXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZShpbmRleCArIDEsIHByb3BzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAocHJvcCA9PiBgJHtwcm9wfSAtPiBgKVxuICAgICAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gcHJvcHNbcHJvcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBsZWFkaW5nU3BhY2UgPSAnICcucmVwZWF0KGxlYWRpbmdQYXJ0Lmxlbmd0aCArIGFscmVhZHlTZWVuLmxlbmd0aCAvIDIpO1xuICAgICAgICAgICAgY29uc3QgZGFzaGVzID0gJy0nLnJlcGVhdChjaXJjdWxhclBhcnQubGVuZ3RoICsgKGFscmVhZHlTZWVuLmxlbmd0aCArIGN1cnJlbnQubGVuZ3RoKSAvIDIgLSAxKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEVKU09OOlxcbicgK1xuICAgICAgICAgICAgICAgIGAgICAgJHtsZWFkaW5nUGFydH0ke2FscmVhZHlTZWVufSR7Y2lyY3VsYXJQYXJ0fSR7Y3VycmVudH1cXG5gICtcbiAgICAgICAgICAgICAgICBgICAgICR7bGVhZGluZ1NwYWNlfVxcXFwke2Rhc2hlc30vYCk7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0c1tvcHRpb25zLnNlZW5PYmplY3RzLmxlbmd0aCAtIDFdLm9iaiA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVBcnJheSh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUgfHwgaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICBjb25zdCBkYXRlTnVtID0gdmFsdWUuZ2V0VGltZSgpLCBpblJhbmdlID0gZGF0ZU51bSA+IC0xICYmIGRhdGVOdW0gPCAyNTM0MDIzMTg4MDAwMDA7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVsYXhlZCAmJiBpblJhbmdlXG4gICAgICAgICAgICAgICAgPyB7ICRkYXRlOiB2YWx1ZS5nZXRUaW1lKCkgfVxuICAgICAgICAgICAgICAgIDogeyAkZGF0ZTogZ2V0SVNPU3RyaW5nKHZhbHVlKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlbGF4ZWQgJiYgaW5SYW5nZVxuICAgICAgICAgICAgPyB7ICRkYXRlOiBnZXRJU09TdHJpbmcodmFsdWUpIH1cbiAgICAgICAgICAgIDogeyAkZGF0ZTogeyAkbnVtYmVyTG9uZzogdmFsdWUuZ2V0VGltZSgpLnRvU3RyaW5nKCkgfSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAoIW9wdGlvbnMucmVsYXhlZCB8fCAhaXNGaW5pdGUodmFsdWUpKSkge1xuICAgICAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgIU9iamVjdC5pcyh2YWx1ZSwgLTApKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gQlNPTl9JTlQzMl9NSU4gJiYgdmFsdWUgPD0gQlNPTl9JTlQzMl9NQVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAkbnVtYmVySW50OiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPj0gQlNPTl9JTlQ2NF9NSU4gJiYgdmFsdWUgPD0gQlNPTl9JTlQ2NF9NQVgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJEb3VibGU6IE9iamVjdC5pcyh2YWx1ZSwgLTApID8gJy0wLjAnIDogdmFsdWUudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgICBpZiAoIW9wdGlvbnMucmVsYXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKS50b1N0cmluZygpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlcihCaWdJbnQuYXNJbnROKDY0LCB2YWx1ZSkpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgIGxldCBmbGFncyA9IHZhbHVlLmZsYWdzO1xuICAgICAgICBpZiAoZmxhZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS50b1N0cmluZygpLm1hdGNoKC9bZ2ltdXldKiQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGZsYWdzID0gbWF0Y2hbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnggPSBuZXcgQlNPTlJlZ0V4cCh2YWx1ZS5zb3VyY2UsIGZsYWdzKTtcbiAgICAgICAgcmV0dXJuIHJ4LnRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplRG9jdW1lbnQodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmNvbnN0IEJTT05fVFlQRV9NQVBQSU5HUyA9IHtcbiAgICBCaW5hcnk6IChvKSA9PiBuZXcgQmluYXJ5KG8udmFsdWUoKSwgby5zdWJfdHlwZSksXG4gICAgQ29kZTogKG8pID0+IG5ldyBDb2RlKG8uY29kZSwgby5zY29wZSksXG4gICAgREJSZWY6IChvKSA9PiBuZXcgREJSZWYoby5jb2xsZWN0aW9uIHx8IG8ubmFtZXNwYWNlLCBvLm9pZCwgby5kYiwgby5maWVsZHMpLFxuICAgIERlY2ltYWwxMjg6IChvKSA9PiBuZXcgRGVjaW1hbDEyOChvLmJ5dGVzKSxcbiAgICBEb3VibGU6IChvKSA9PiBuZXcgRG91YmxlKG8udmFsdWUpLFxuICAgIEludDMyOiAobykgPT4gbmV3IEludDMyKG8udmFsdWUpLFxuICAgIExvbmc6IChvKSA9PiBMb25nLmZyb21CaXRzKG8ubG93ICE9IG51bGwgPyBvLmxvdyA6IG8ubG93Xywgby5sb3cgIT0gbnVsbCA/IG8uaGlnaCA6IG8uaGlnaF8sIG8ubG93ICE9IG51bGwgPyBvLnVuc2lnbmVkIDogby51bnNpZ25lZF8pLFxuICAgIE1heEtleTogKCkgPT4gbmV3IE1heEtleSgpLFxuICAgIE1pbktleTogKCkgPT4gbmV3IE1pbktleSgpLFxuICAgIE9iamVjdElkOiAobykgPT4gbmV3IE9iamVjdElkKG8pLFxuICAgIEJTT05SZWdFeHA6IChvKSA9PiBuZXcgQlNPTlJlZ0V4cChvLnBhdHRlcm4sIG8ub3B0aW9ucyksXG4gICAgQlNPTlN5bWJvbDogKG8pID0+IG5ldyBCU09OU3ltYm9sKG8udmFsdWUpLFxuICAgIFRpbWVzdGFtcDogKG8pID0+IFRpbWVzdGFtcC5mcm9tQml0cyhvLmxvdywgby5oaWdoKVxufTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZURvY3VtZW50KGRvYywgb3B0aW9ucykge1xuICAgIGlmIChkb2MgPT0gbnVsbCB8fCB0eXBlb2YgZG9jICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignbm90IGFuIG9iamVjdCBpbnN0YW5jZScpO1xuICAgIGNvbnN0IGJzb250eXBlID0gZG9jLl9ic29udHlwZTtcbiAgICBpZiAodHlwZW9mIGJzb250eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBfZG9jID0ge307XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkb2MpKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnB1c2goeyBwcm9wZXJ0eU5hbWU6IG5hbWUsIG9iajogbnVsbCB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXJpYWxpemVWYWx1ZShkb2NbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX2RvYywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZG9jW25hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RvYztcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9jICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGRvYyA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgdHlwZW9mIGRvYy5fYnNvbnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgIGRvY1tTeW1ib2wuZm9yKCdAQG1kYi5ic29uLnZlcnNpb24nKV0gIT09IEJTT05fTUFKT1JfVkVSU0lPTikge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0JTT05UeXBlKGRvYykpIHtcbiAgICAgICAgbGV0IG91dERvYyA9IGRvYztcbiAgICAgICAgaWYgKHR5cGVvZiBvdXREb2MudG9FeHRlbmRlZEpTT04gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlciA9IEJTT05fVFlQRV9NQVBQSU5HU1tkb2MuX2Jzb250eXBlXTtcbiAgICAgICAgICAgIGlmICghbWFwcGVyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAnICsgZG9jLl9ic29udHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXREb2MgPSBtYXBwZXIob3V0RG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnNvbnR5cGUgPT09ICdDb2RlJyAmJiBvdXREb2Muc2NvcGUpIHtcbiAgICAgICAgICAgIG91dERvYyA9IG5ldyBDb2RlKG91dERvYy5jb2RlLCBzZXJpYWxpemVWYWx1ZShvdXREb2Muc2NvcGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChic29udHlwZSA9PT0gJ0RCUmVmJyAmJiBvdXREb2Mub2lkKSB7XG4gICAgICAgICAgICBvdXREb2MgPSBuZXcgREJSZWYoc2VyaWFsaXplVmFsdWUob3V0RG9jLmNvbGxlY3Rpb24sIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2Mub2lkLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmRiLCBvcHRpb25zKSwgc2VyaWFsaXplVmFsdWUob3V0RG9jLmZpZWxkcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXREb2MudG9FeHRlbmRlZEpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdfYnNvbnR5cGUgbXVzdCBiZSBhIHN0cmluZywgYnV0IHdhczogJyArIHR5cGVvZiBic29udHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2UodGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVqc29uT3B0aW9ucyA9IHtcbiAgICAgICAgdXNlQmlnSW50NjQ6IG9wdGlvbnM/LnVzZUJpZ0ludDY0ID8/IGZhbHNlLFxuICAgICAgICByZWxheGVkOiBvcHRpb25zPy5yZWxheGVkID8/IHRydWUsXG4gICAgICAgIGxlZ2FjeTogb3B0aW9ucz8ubGVnYWN5ID8/IGZhbHNlXG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0LCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoa2V5LmluZGV4T2YoJ1xceDAwJykgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBCU09OIERvY3VtZW50IGZpZWxkIG5hbWVzIGNhbm5vdCBjb250YWluIG51bGwgYnl0ZXMsIGZvdW5kOiAke0pTT04uc3RyaW5naWZ5KGtleSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplVmFsdWUodmFsdWUsIGVqc29uT3B0aW9ucyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSwgb3B0aW9ucykge1xuICAgIGlmIChzcGFjZSAhPSBudWxsICYmIHR5cGVvZiBzcGFjZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0aW9ucyA9IHNwYWNlO1xuICAgICAgICBzcGFjZSA9IDA7XG4gICAgfVxuICAgIGlmIChyZXBsYWNlciAhPSBudWxsICYmIHR5cGVvZiByZXBsYWNlciA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocmVwbGFjZXIpKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXBsYWNlcjtcbiAgICAgICAgcmVwbGFjZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHNwYWNlID0gMDtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyByZWxheGVkOiB0cnVlLCBsZWdhY3k6IGZhbHNlIH0sIG9wdGlvbnMsIHtcbiAgICAgICAgc2Vlbk9iamVjdHM6IFt7IHByb3BlcnR5TmFtZTogJyhyb290KScsIG9iajogbnVsbCB9XVxuICAgIH0pO1xuICAgIGNvbnN0IGRvYyA9IHNlcmlhbGl6ZVZhbHVlKHZhbHVlLCBzZXJpYWxpemVPcHRpb25zKTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZG9jLCByZXBsYWNlciwgc3BhY2UpO1xufVxuZnVuY3Rpb24gRUpTT05zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmdpZnkodmFsdWUsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIEVKU09OZGVzZXJpYWxpemUoZWpzb24sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gcGFyc2UoSlNPTi5zdHJpbmdpZnkoZWpzb24pLCBvcHRpb25zKTtcbn1cbmNvbnN0IEVKU09OID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbkVKU09OLnBhcnNlID0gcGFyc2U7XG5FSlNPTi5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5FSlNPTi5zZXJpYWxpemUgPSBFSlNPTnNlcmlhbGl6ZTtcbkVKU09OLmRlc2VyaWFsaXplID0gRUpTT05kZXNlcmlhbGl6ZTtcbk9iamVjdC5mcmVlemUoRUpTT04pO1xuXG5mdW5jdGlvbiBnZXRTaXplKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIE51bWJlclV0aWxzLmdldE5vbm5lZ2F0aXZlSW50MzJMRShzb3VyY2UsIG9mZnNldCk7XG4gICAgfVxuICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKCdCU09OIHNpemUgY2Fubm90IGJlIG5lZ2F0aXZlJywgb2Zmc2V0LCB7IGNhdXNlIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmROdWxsKGJ5dGVzLCBvZmZzZXQpIHtcbiAgICBsZXQgbnVsbFRlcm1pbmF0b3JPZmZzZXQgPSBvZmZzZXQ7XG4gICAgZm9yICg7IGJ5dGVzW251bGxUZXJtaW5hdG9yT2Zmc2V0XSAhPT0gMHgwMDsgbnVsbFRlcm1pbmF0b3JPZmZzZXQrKylcbiAgICAgICAgO1xuICAgIGlmIChudWxsVGVybWluYXRvck9mZnNldCA9PT0gYnl0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKCdOdWxsIHRlcm1pbmF0b3Igbm90IGZvdW5kJywgb2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGxUZXJtaW5hdG9yT2Zmc2V0O1xufVxuZnVuY3Rpb24gcGFyc2VUb0VsZW1lbnRzKGJ5dGVzLCBzdGFydE9mZnNldCA9IDApIHtcbiAgICBzdGFydE9mZnNldCA/Pz0gMDtcbiAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgNSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKGBJbnB1dCBtdXN0IGJlIGF0IGxlYXN0IDUgYnl0ZXMsIGdvdCAke2J5dGVzLmxlbmd0aH0gYnl0ZXNgLCBzdGFydE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGRvY3VtZW50U2l6ZSA9IGdldFNpemUoYnl0ZXMsIHN0YXJ0T2Zmc2V0KTtcbiAgICBpZiAoZG9jdW1lbnRTaXplID4gYnl0ZXMubGVuZ3RoIC0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05PZmZzZXRFcnJvcihgUGFyc2VkIGRvY3VtZW50U2l6ZSAoJHtkb2N1bWVudFNpemV9IGJ5dGVzKSBkb2VzIG5vdCBtYXRjaCBpbnB1dCBsZW5ndGggKCR7Ynl0ZXMubGVuZ3RofSBieXRlcylgLCBzdGFydE9mZnNldCk7XG4gICAgfVxuICAgIGlmIChieXRlc1tzdGFydE9mZnNldCArIGRvY3VtZW50U2l6ZSAtIDFdICE9PSAweDAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09OT2Zmc2V0RXJyb3IoJ0JTT04gZG9jdW1lbnRzIG11c3QgZW5kIGluIDB4MDAnLCBzdGFydE9mZnNldCArIGRvY3VtZW50U2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgbGV0IG9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgNDtcbiAgICB3aGlsZSAob2Zmc2V0IDw9IGRvY3VtZW50U2l6ZSArIHN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBieXRlc1tvZmZzZXRdO1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgaWYgKHR5cGUgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgLSBzdGFydE9mZnNldCAhPT0gZG9jdW1lbnRTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05PZmZzZXRFcnJvcihgSW52YWxpZCAweDAwIHR5cGUgYnl0ZWAsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBjb25zdCBuYW1lTGVuZ3RoID0gZmluZE51bGwoYnl0ZXMsIG9mZnNldCkgLSBuYW1lT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgKz0gbmFtZUxlbmd0aCArIDE7XG4gICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgIGlmICh0eXBlID09PSAxIHx8XG4gICAgICAgICAgICB0eXBlID09PSAxOCB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gOSB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMTcpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMTYpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gNykge1xuICAgICAgICAgICAgbGVuZ3RoID0gMTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMTkpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMTAgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IDYgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IDEyNyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMjU1KSB7XG4gICAgICAgICAgICBsZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICBsZW5ndGggPSBmaW5kTnVsbChieXRlcywgZmluZE51bGwoYnl0ZXMsIG9mZnNldCkgKyAxKSArIDEgLSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMyB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gNCB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMTUpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IGdldFNpemUoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gMiB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gNSB8fFxuICAgICAgICAgICAgdHlwZSA9PT0gMTIgfHxcbiAgICAgICAgICAgIHR5cGUgPT09IDEzIHx8XG4gICAgICAgICAgICB0eXBlID09PSAxNCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gZ2V0U2l6ZShieXRlcywgb2Zmc2V0KSArIDQ7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gNSkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDEyKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoICs9IDEyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05PZmZzZXRFcnJvcihgSW52YWxpZCAweCR7dHlwZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKX0gdHlwZSBieXRlYCwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoID4gZG9jdW1lbnRTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTk9mZnNldEVycm9yKCd2YWx1ZSByZXBvcnRzIGxlbmd0aCBsYXJnZXIgdGhhbiBkb2N1bWVudCcsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudHMucHVzaChbdHlwZSwgbmFtZU9mZnNldCwgbmFtZUxlbmd0aCwgb2Zmc2V0LCBsZW5ndGhdKTtcbiAgICAgICAgb2Zmc2V0ICs9IGxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnRzO1xufVxuXG5jb25zdCBvbkRlbWFuZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5vbkRlbWFuZC5wYXJzZVRvRWxlbWVudHMgPSBwYXJzZVRvRWxlbWVudHM7XG5vbkRlbWFuZC5CeXRlVXRpbHMgPSBCeXRlVXRpbHM7XG5vbkRlbWFuZC5OdW1iZXJVdGlscyA9IE51bWJlclV0aWxzO1xuT2JqZWN0LmZyZWV6ZShvbkRlbWFuZCk7XG5cbmNvbnN0IE1BWFNJWkUgPSAxMDI0ICogMTAyNCAqIDE3O1xubGV0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShNQVhTSVpFKTtcbmZ1bmN0aW9uIHNldEludGVybmFsQnVmZmVyU2l6ZShzaXplKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShzaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjaGVja0tleXMgPSB0eXBlb2Ygb3B0aW9ucy5jaGVja0tleXMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2hlY2tLZXlzIDogZmFsc2U7XG4gICAgY29uc3Qgc2VyaWFsaXplRnVuY3Rpb25zID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA6IGZhbHNlO1xuICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuICAgIGNvbnN0IG1pbkludGVybmFsQnVmZmVyU2l6ZSA9IHR5cGVvZiBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA6IE1BWFNJWkU7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBtaW5JbnRlcm5hbEJ1ZmZlclNpemUpIHtcbiAgICAgICAgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKG1pbkludGVybmFsQnVmZmVyU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgMCwgMCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIG51bGwpO1xuICAgIGNvbnN0IGZpbmlzaGVkQnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlVW5zYWZlKHNlcmlhbGl6YXRpb25JbmRleCk7XG4gICAgZmluaXNoZWRCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCAwKTtcbiAgICByZXR1cm4gZmluaXNoZWRCdWZmZXI7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgob2JqZWN0LCBmaW5hbEJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcbiAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkIDogdHJ1ZTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gdHlwZW9mIG9wdGlvbnMuaW5kZXggPT09ICdudW1iZXInID8gb3B0aW9ucy5pbmRleCA6IDA7XG4gICAgY29uc3Qgc2VyaWFsaXphdGlvbkluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCAwLCAwLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgbnVsbCk7XG4gICAgZmluYWxCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICByZXR1cm4gc3RhcnRJbmRleCArIHNlcmlhbGl6YXRpb25JbmRleCAtIDE7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShidWZmZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBpbnRlcm5hbERlc2VyaWFsaXplKEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG4gICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG4gICAgcmV0dXJuIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZShvYmplY3QsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RyZWFtKGRhdGEsIHN0YXJ0SW5kZXgsIG51bWJlck9mRG9jdW1lbnRzLCBkb2N1bWVudHMsIGRvY1N0YXJ0SW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemU6IHRydWUsIGluZGV4OiAwIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRG9jdW1lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlclV0aWxzLmdldEludDMyTEUoYnVmZmVyRGF0YSwgaW5kZXgpO1xuICAgICAgICBpbnRlcm5hbE9wdGlvbnMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgZG9jdW1lbnRzW2RvY1N0YXJ0SW5kZXggKyBpXSA9IGludGVybmFsRGVzZXJpYWxpemUoYnVmZmVyRGF0YSwgaW50ZXJuYWxPcHRpb25zKTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIHNpemU7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cblxudmFyIGJzb24gPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEJTT05FcnJvcjogQlNPTkVycm9yLFxuICAgIEJTT05PZmZzZXRFcnJvcjogQlNPTk9mZnNldEVycm9yLFxuICAgIEJTT05SZWdFeHA6IEJTT05SZWdFeHAsXG4gICAgQlNPTlJ1bnRpbWVFcnJvcjogQlNPTlJ1bnRpbWVFcnJvcixcbiAgICBCU09OU3ltYm9sOiBCU09OU3ltYm9sLFxuICAgIEJTT05UeXBlOiBCU09OVHlwZSxcbiAgICBCU09OVmFsdWU6IEJTT05WYWx1ZSxcbiAgICBCU09OVmVyc2lvbkVycm9yOiBCU09OVmVyc2lvbkVycm9yLFxuICAgIEJpbmFyeTogQmluYXJ5LFxuICAgIENvZGU6IENvZGUsXG4gICAgREJSZWY6IERCUmVmLFxuICAgIERlY2ltYWwxMjg6IERlY2ltYWwxMjgsXG4gICAgRG91YmxlOiBEb3VibGUsXG4gICAgRUpTT046IEVKU09OLFxuICAgIEludDMyOiBJbnQzMixcbiAgICBMb25nOiBMb25nLFxuICAgIE1heEtleTogTWF4S2V5LFxuICAgIE1pbktleTogTWluS2V5LFxuICAgIE9iamVjdElkOiBPYmplY3RJZCxcbiAgICBUaW1lc3RhbXA6IFRpbWVzdGFtcCxcbiAgICBVVUlEOiBVVUlELFxuICAgIGNhbGN1bGF0ZU9iamVjdFNpemU6IGNhbGN1bGF0ZU9iamVjdFNpemUsXG4gICAgZGVzZXJpYWxpemU6IGRlc2VyaWFsaXplLFxuICAgIGRlc2VyaWFsaXplU3RyZWFtOiBkZXNlcmlhbGl6ZVN0cmVhbSxcbiAgICBvbkRlbWFuZDogb25EZW1hbmQsXG4gICAgc2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4OiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgsXG4gICAgc2V0SW50ZXJuYWxCdWZmZXJTaXplOiBzZXRJbnRlcm5hbEJ1ZmZlclNpemVcbn0pO1xuXG5leHBvcnRzLkJTT04gPSBic29uO1xuZXhwb3J0cy5CU09ORXJyb3IgPSBCU09ORXJyb3I7XG5leHBvcnRzLkJTT05PZmZzZXRFcnJvciA9IEJTT05PZmZzZXRFcnJvcjtcbmV4cG9ydHMuQlNPTlJlZ0V4cCA9IEJTT05SZWdFeHA7XG5leHBvcnRzLkJTT05SdW50aW1lRXJyb3IgPSBCU09OUnVudGltZUVycm9yO1xuZXhwb3J0cy5CU09OU3ltYm9sID0gQlNPTlN5bWJvbDtcbmV4cG9ydHMuQlNPTlR5cGUgPSBCU09OVHlwZTtcbmV4cG9ydHMuQlNPTlZhbHVlID0gQlNPTlZhbHVlO1xuZXhwb3J0cy5CU09OVmVyc2lvbkVycm9yID0gQlNPTlZlcnNpb25FcnJvcjtcbmV4cG9ydHMuQmluYXJ5ID0gQmluYXJ5O1xuZXhwb3J0cy5Db2RlID0gQ29kZTtcbmV4cG9ydHMuREJSZWYgPSBEQlJlZjtcbmV4cG9ydHMuRGVjaW1hbDEyOCA9IERlY2ltYWwxMjg7XG5leHBvcnRzLkRvdWJsZSA9IERvdWJsZTtcbmV4cG9ydHMuRUpTT04gPSBFSlNPTjtcbmV4cG9ydHMuSW50MzIgPSBJbnQzMjtcbmV4cG9ydHMuTG9uZyA9IExvbmc7XG5leHBvcnRzLk1heEtleSA9IE1heEtleTtcbmV4cG9ydHMuTWluS2V5ID0gTWluS2V5O1xuZXhwb3J0cy5PYmplY3RJZCA9IE9iamVjdElkO1xuZXhwb3J0cy5UaW1lc3RhbXAgPSBUaW1lc3RhbXA7XG5leHBvcnRzLlVVSUQgPSBVVUlEO1xuZXhwb3J0cy5jYWxjdWxhdGVPYmplY3RTaXplID0gY2FsY3VsYXRlT2JqZWN0U2l6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbmV4cG9ydHMuZGVzZXJpYWxpemVTdHJlYW0gPSBkZXNlcmlhbGl6ZVN0cmVhbTtcbmV4cG9ydHMub25EZW1hbmQgPSBvbkRlbWFuZDtcbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZXhwb3J0cy5zZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXggPSBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXg7XG5leHBvcnRzLnNldEludGVybmFsQnVmZmVyU2l6ZSA9IHNldEludGVybmFsQnVmZmVyU2l6ZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJzb24uY2pzLm1hcFxuIl0sIm5hbWVzIjpbImlzQW55QXJyYXlCdWZmZXIiLCJ2YWx1ZSIsImluY2x1ZGVzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiaXNVaW50OEFycmF5IiwiaXNSZWdFeHAiLCJkIiwiaXNNYXAiLCJpc0RhdGUiLCJkZWZhdWx0SW5zcGVjdCIsIngiLCJfb3B0aW9ucyIsIkpTT04iLCJzdHJpbmdpZnkiLCJrIiwidiIsIiRudW1iZXJMb25nIiwiZnJvbUVudHJpZXMiLCJnZXRTdHlsaXplRnVuY3Rpb24iLCJvcHRpb25zIiwic3R5bGl6ZUV4aXN0cyIsInN0eWxpemUiLCJCU09OX01BSk9SX1ZFUlNJT04iLCJCU09OX0lOVDMyX01BWCIsIkJTT05fSU5UMzJfTUlOIiwiQlNPTl9JTlQ2NF9NQVgiLCJNYXRoIiwicG93IiwiQlNPTl9JTlQ2NF9NSU4iLCJKU19JTlRfTUFYIiwiSlNfSU5UX01JTiIsIkJTT05fREFUQV9OVU1CRVIiLCJCU09OX0RBVEFfU1RSSU5HIiwiQlNPTl9EQVRBX09CSkVDVCIsIkJTT05fREFUQV9BUlJBWSIsIkJTT05fREFUQV9CSU5BUlkiLCJCU09OX0RBVEFfVU5ERUZJTkVEIiwiQlNPTl9EQVRBX09JRCIsIkJTT05fREFUQV9CT09MRUFOIiwiQlNPTl9EQVRBX0RBVEUiLCJCU09OX0RBVEFfTlVMTCIsIkJTT05fREFUQV9SRUdFWFAiLCJCU09OX0RBVEFfREJQT0lOVEVSIiwiQlNPTl9EQVRBX0NPREUiLCJCU09OX0RBVEFfU1lNQk9MIiwiQlNPTl9EQVRBX0NPREVfV19TQ09QRSIsIkJTT05fREFUQV9JTlQiLCJCU09OX0RBVEFfVElNRVNUQU1QIiwiQlNPTl9EQVRBX0xPTkciLCJCU09OX0RBVEFfREVDSU1BTDEyOCIsIkJTT05fREFUQV9NSU5fS0VZIiwiQlNPTl9EQVRBX01BWF9LRVkiLCJCU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQiLCJCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXIiwiQlNPTlR5cGUiLCJmcmVlemUiLCJkb3VibGUiLCJzdHJpbmciLCJvYmplY3QiLCJhcnJheSIsImJpbkRhdGEiLCJ1bmRlZmluZWQiLCJvYmplY3RJZCIsImJvb2wiLCJkYXRlIiwibnVsbCIsInJlZ2V4IiwiZGJQb2ludGVyIiwiamF2YXNjcmlwdCIsInN5bWJvbCIsImphdmFzY3JpcHRXaXRoU2NvcGUiLCJpbnQiLCJ0aW1lc3RhbXAiLCJsb25nIiwiZGVjaW1hbCIsIm1pbktleSIsIm1heEtleSIsIkJTT05FcnJvciIsIkVycm9yIiwiYnNvbkVycm9yIiwibmFtZSIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImlzQlNPTkVycm9yIiwiQlNPTlZlcnNpb25FcnJvciIsIkJTT05SdW50aW1lRXJyb3IiLCJCU09OT2Zmc2V0RXJyb3IiLCJvZmZzZXQiLCJGSVJTVF9CSVQiLCJGSVJTVF9UV09fQklUUyIsIkZJUlNUX1RIUkVFX0JJVFMiLCJGSVJTVF9GT1VSX0JJVFMiLCJGSVJTVF9GSVZFX0JJVFMiLCJUV09fQklUX0NIQVIiLCJUSFJFRV9CSVRfQ0hBUiIsIkZPVVJfQklUX0NIQVIiLCJDT05USU5VSU5HX0NIQVIiLCJ2YWxpZGF0ZVV0ZjgiLCJieXRlcyIsInN0YXJ0IiwiZW5kIiwiY29udGludWF0aW9uIiwiaSIsImJ5dGUiLCJ0cnlSZWFkQmFzaWNMYXRpbiIsInVpbnQ4YXJyYXkiLCJsZW5ndGgiLCJzdHJpbmdCeXRlTGVuZ3RoIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwibGF0aW5CeXRlcyIsInB1c2giLCJ0cnlXcml0ZUJhc2ljTGF0aW4iLCJkZXN0aW5hdGlvbiIsInNvdXJjZSIsImNoYXJPZmZzZXQiLCJkZXN0aW5hdGlvbk9mZnNldCIsImNoYXIiLCJjaGFyQ29kZUF0Iiwibm9kZWpzTWF0aFJhbmRvbUJ5dGVzIiwiYnl0ZUxlbmd0aCIsIm5vZGVKc0J5dGVVdGlscyIsImZyb21OdW1iZXJBcnJheSIsIkFycmF5IiwiZnJvbSIsImZsb29yIiwicmFuZG9tIiwibm9kZWpzUmFuZG9tQnl0ZXMiLCJyZXF1aXJlIiwicmFuZG9tQnl0ZXMiLCJ0b0xvY2FsQnVmZmVyVHlwZSIsInBvdGVudGlhbEJ1ZmZlciIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJieXRlT2Zmc2V0Iiwic3RyaW5nVGFnIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJhbGxvY2F0ZSIsInNpemUiLCJhbGxvYyIsImFsbG9jYXRlVW5zYWZlIiwiYWxsb2NVbnNhZmUiLCJlcXVhbHMiLCJhIiwiYiIsImZyb21CYXNlNjQiLCJiYXNlNjQiLCJ0b0Jhc2U2NCIsImZyb21JU084ODU5MSIsImNvZGVQb2ludHMiLCJ0b0lTTzg4NTkxIiwiZnJvbUhleCIsImhleCIsInRvSGV4IiwidG9VVEY4IiwiZmF0YWwiLCJiYXNpY0xhdGluIiwidXRmOEJ5dGVMZW5ndGgiLCJpbnB1dCIsImVuY29kZVVURjhJbnRvIiwibGF0aW5CeXRlc1dyaXR0ZW4iLCJ3cml0ZSIsImlzUmVhY3ROYXRpdmUiLCJuYXZpZ2F0b3IiLCJnbG9iYWxUaGlzIiwicHJvZHVjdCIsIndlYk1hdGhSYW5kb21CeXRlcyIsIlJhbmdlRXJyb3IiLCJ3ZWJCeXRlVXRpbHMiLCJ3ZWJSYW5kb21CeXRlcyIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsImNvbnNvbGUiLCJ3YXJuIiwiSEVYX0RJR0lUIiwicG90ZW50aWFsVWludDhhcnJheSIsIlVpbnQ4QXJyYXkiLCJzbGljZSIsIlR5cGVFcnJvciIsImF0b2IiLCJjIiwiYnRvYSIsIlVpbnQxNkFycmF5Iiwiam9pbiIsImV2ZW5MZW5ndGhIZXgiLCJmaXJzdERpZ2l0Iiwic2Vjb25kRGlnaXQiLCJ0ZXN0IiwiaGV4RGlnaXQiLCJOdW1iZXIiLCJwYXJzZUludCIsInBhZFN0YXJ0IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJjYXVzZSIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwic2V0IiwiaGFzR2xvYmFsQnVmZmVyIiwiX2lzQnVmZmVyIiwiQnl0ZVV0aWxzIiwiQlNPTlZhbHVlIiwiZm9yIiwiZGVwdGgiLCJpbnNwZWN0IiwiQmluYXJ5IiwiX2Jzb250eXBlIiwic3ViVHlwZSIsImlzQXJyYXkiLCJzdWJfdHlwZSIsIkJVRkZFUl9TSVpFIiwicG9zaXRpb24iLCJwdXQiLCJieXRlVmFsdWUiLCJkZWNvZGVkQnl0ZSIsIm5ld1NwYWNlIiwic2VxdWVuY2UiLCJyZWFkIiwic3ViYXJyYXkiLCJ0b0pTT04iLCJlbmNvZGluZyIsInRvRXh0ZW5kZWRKU09OIiwiYmFzZTY0U3RyaW5nIiwibGVnYWN5IiwiJGJpbmFyeSIsIiR0eXBlIiwidG9VVUlEIiwiU1VCVFlQRV9VVUlEIiwiVVVJRCIsImNyZWF0ZUZyb21IZXhTdHJpbmciLCJjcmVhdGVGcm9tQmFzZTY0IiwiZnJvbUV4dGVuZGVkSlNPTiIsImRvYyIsImRhdGEiLCJ0eXBlIiwiYnl0ZXNGcm9tU3RyaW5nIiwiJHV1aWQiLCJiYXNlNjRBcmciLCJzdWJUeXBlQXJnIiwiU1VCVFlQRV9ERUZBVUxUIiwiU1VCVFlQRV9GVU5DVElPTiIsIlNVQlRZUEVfQllURV9BUlJBWSIsIlNVQlRZUEVfVVVJRF9PTEQiLCJTVUJUWVBFX01ENSIsIlNVQlRZUEVfRU5DUllQVEVEIiwiU1VCVFlQRV9DT0xVTU4iLCJTVUJUWVBFX1NFTlNJVElWRSIsIlNVQlRZUEVfVVNFUl9ERUZJTkVEIiwiVVVJRF9CWVRFX0xFTkdUSCIsIlVVSURfV0lUSE9VVF9EQVNIRVMiLCJVVUlEX1dJVEhfREFTSEVTIiwiZ2VuZXJhdGUiLCJpZCIsInRvSGV4U3RyaW5nIiwiaW5jbHVkZURhc2hlcyIsIm90aGVySWQiLCJ0b0JpbmFyeSIsImlzVmFsaWQiLCJpc1ZhbGlkVVVJRFN0cmluZyIsImhleFN0cmluZyIsInJlcHJlc2VudGF0aW9uIiwicmVwbGFjZSIsIkNvZGUiLCJjb2RlIiwic2NvcGUiLCIkY29kZSIsIiRzY29wZSIsInBhcmFtZXRlcnNTdHJpbmciLCJtdWx0aUxpbmVGbiIsImVuZGluZ05ld2xpbmUiLCJpc0RCUmVmTGlrZSIsIiRpZCIsIiRyZWYiLCIkZGIiLCJEQlJlZiIsImNvbGxlY3Rpb24iLCJvaWQiLCJkYiIsImZpZWxkcyIsInBhcnRzIiwic3BsaXQiLCJzaGlmdCIsIm5hbWVzcGFjZSIsIm8iLCJhc3NpZ24iLCJjb3B5IiwiYXJncyIsImtleXMiLCJ3YXNtIiwiV2ViQXNzZW1ibHkiLCJJbnN0YW5jZSIsIk1vZHVsZSIsImV4cG9ydHMiLCJUV09fUFdSXzE2X0RCTCIsIlRXT19QV1JfMjRfREJMIiwiVFdPX1BXUl8zMl9EQkwiLCJUV09fUFdSXzY0X0RCTCIsIlRXT19QV1JfNjNfREJMIiwiSU5UX0NBQ0hFIiwiVUlOVF9DQUNIRSIsIk1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIIiwiREVDSU1BTF9SRUdfRVgiLCJMb25nIiwiX19pc0xvbmdfXyIsImxvdyIsImhpZ2giLCJ1bnNpZ25lZCIsImZyb21CaWdJbnQiLCJmcm9tU3RyaW5nIiwiZnJvbUJpdHMiLCJsb3dCaXRzIiwiaGlnaEJpdHMiLCJmcm9tSW50Iiwib2JqIiwiY2FjaGVkT2JqIiwiY2FjaGUiLCJmcm9tTnVtYmVyIiwiaXNOYU4iLCJVWkVSTyIsIlpFUk8iLCJNQVhfVU5TSUdORURfVkFMVUUiLCJNSU5fVkFMVUUiLCJNQVhfVkFMVUUiLCJuZWciLCJzdHIiLCJyYWRpeCIsInAiLCJpbmRleE9mIiwic3Vic3RyaW5nIiwicmFkaXhUb1Bvd2VyIiwicmVzdWx0IiwibWluIiwicG93ZXIiLCJtdWwiLCJhZGQiLCJmcm9tQnl0ZXMiLCJsZSIsImZyb21CeXRlc0xFIiwiZnJvbUJ5dGVzQkUiLCJpc0xvbmciLCJmcm9tVmFsdWUiLCJ2YWwiLCJhZGRlbmQiLCJhNDgiLCJhMzIiLCJhMTYiLCJhMDAiLCJiNDgiLCJiMzIiLCJiMTYiLCJiMDAiLCJjNDgiLCJjMzIiLCJjMTYiLCJjMDAiLCJhbmQiLCJvdGhlciIsImNvbXBhcmUiLCJlcSIsInRoaXNOZWciLCJpc05lZ2F0aXZlIiwib3RoZXJOZWciLCJzdWIiLCJjb21wIiwiZGl2aWRlIiwiZGl2aXNvciIsImlzWmVybyIsImRpdl91IiwiZGl2X3MiLCJnZXRfaGlnaCIsImFwcHJveCIsInJlbSIsInJlcyIsIk9ORSIsIk5FR19PTkUiLCJoYWxmVGhpcyIsInNociIsImRpdiIsInNobCIsInRvVW5zaWduZWQiLCJndCIsInNocnUiLCJVT05FIiwiZ3RlIiwibWF4IiwidG9OdW1iZXIiLCJsb2cyIiwiY2VpbCIsImxvZyIsIkxOMiIsImRlbHRhIiwiYXBwcm94UmVzIiwiYXBwcm94UmVtIiwiZ2V0SGlnaEJpdHMiLCJnZXRIaWdoQml0c1Vuc2lnbmVkIiwiZ2V0TG93Qml0cyIsImdldExvd0JpdHNVbnNpZ25lZCIsImdldE51bUJpdHNBYnMiLCJiaXQiLCJncmVhdGVyVGhhbiIsImdyZWF0ZXJUaGFuT3JFcXVhbCIsImdlIiwiaXNFdmVuIiwiaXNPZGQiLCJpc1Bvc2l0aXZlIiwibGVzc1RoYW4iLCJsdCIsImxlc3NUaGFuT3JFcXVhbCIsImx0ZSIsIm1vZHVsbyIsInJlbV91IiwicmVtX3MiLCJtb2QiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJUV09fUFdSXzI0IiwibmVnYXRlIiwibm90Iiwibm90RXF1YWxzIiwibmVxIiwibmUiLCJvciIsInNoaWZ0TGVmdCIsIm51bUJpdHMiLCJ0b0ludCIsInNoaWZ0UmlnaHQiLCJzaGlmdFJpZ2h0VW5zaWduZWQiLCJzaHJfdSIsInN1YnRyYWN0Iiwic3VidHJhaGVuZCIsInRvQmlnSW50IiwiQmlnSW50IiwidG9CeXRlcyIsInRvQnl0ZXNMRSIsInRvQnl0ZXNCRSIsImhpIiwibG8iLCJ0b1NpZ25lZCIsInJhZGl4TG9uZyIsInJlbTEiLCJyZW1EaXYiLCJpbnR2YWwiLCJkaWdpdHMiLCJ4b3IiLCJlcXoiLCJyZWxheGVkIiwidXNlQmlnSW50NjQiLCJiaWdJbnRSZXN1bHQiLCJhc0ludE4iLCJsb25nUmVzdWx0IiwibG9uZ1ZhbCIsInVuc2lnbmVkVmFsIiwiUEFSU0VfU1RSSU5HX1JFR0VYUCIsIlBBUlNFX0lORl9SRUdFWFAiLCJQQVJTRV9OQU5fUkVHRVhQIiwiRVhQT05FTlRfTUFYIiwiRVhQT05FTlRfTUlOIiwiRVhQT05FTlRfQklBUyIsIk1BWF9ESUdJVFMiLCJOQU5fQlVGRkVSIiwicmV2ZXJzZSIsIklORl9ORUdBVElWRV9CVUZGRVIiLCJJTkZfUE9TSVRJVkVfQlVGRkVSIiwiRVhQT05FTlRfUkVHRVgiLCJDT01CSU5BVElPTl9NQVNLIiwiRVhQT05FTlRfTUFTSyIsIkNPTUJJTkFUSU9OX0lORklOSVRZIiwiQ09NQklOQVRJT05fTkFOIiwiaXNEaWdpdCIsImRpdmlkZXUxMjgiLCJESVZJU09SIiwiX3JlbSIsInF1b3RpZW50IiwibXVsdGlwbHk2NHgyIiwibGVmdCIsInJpZ2h0IiwibGVmdEhpZ2giLCJsZWZ0TG93IiwicmlnaHRIaWdoIiwicmlnaHRMb3ciLCJwcm9kdWN0SGlnaCIsInByb2R1Y3RNaWQiLCJwcm9kdWN0TWlkMiIsInByb2R1Y3RMb3ciLCJ1aGxlZnQiLCJ1aHJpZ2h0IiwidWxsZWZ0IiwidWxyaWdodCIsImludmFsaWRFcnIiLCJEZWNpbWFsMTI4IiwiX2Zyb21TdHJpbmciLCJhbGxvd1JvdW5kaW5nIiwiZnJvbVN0cmluZ1dpdGhSb3VuZGluZyIsInNhd1NpZ24iLCJzYXdSYWRpeCIsImZvdW5kTm9uWmVybyIsInNpZ25pZmljYW50RGlnaXRzIiwibkRpZ2l0c1JlYWQiLCJuRGlnaXRzIiwicmFkaXhQb3NpdGlvbiIsImZpcnN0Tm9uWmVybyIsIm5EaWdpdHNTdG9yZWQiLCJkaWdpdHNJbnNlcnQiLCJsYXN0RGlnaXQiLCJleHBvbmVudCIsInNpZ25pZmljYW5kSGlnaCIsInNpZ25pZmljYW5kTG93IiwiYmlhc2VkRXhwb25lbnQiLCJpbmRleCIsInN0cmluZ01hdGNoIiwibWF0Y2giLCJpbmZNYXRjaCIsIm5hbk1hdGNoIiwidW5zaWduZWROdW1iZXIiLCJlIiwiZXhwU2lnbiIsImV4cE51bWJlciIsInN1YnN0ciIsImRpZ2l0c1N0cmluZyIsImVuZE9mU3RyaW5nIiwicm91bmREaWdpdCIsInJvdW5kQml0IiwiZElkeCIsInNpZ25pZmljYW5kIiwiZGVjIiwiYmlhc2VkX2V4cG9uZW50Iiwic2lnbmlmaWNhbmRfZGlnaXRzIiwiaXNfemVybyIsInNpZ25pZmljYW5kX21zYiIsInNpZ25pZmljYW5kMTI4IiwiaiIsIm1pZGwiLCJtaWRoIiwiY29tYmluYXRpb24iLCJsZWFzdF9kaWdpdHMiLCJzY2llbnRpZmljX2V4cG9uZW50IiwicmFkaXhfcG9zaXRpb24iLCIkbnVtYmVyRGVjaW1hbCIsImQxMjhzdHJpbmciLCJEb3VibGUiLCJ2YWx1ZU9mIiwiaXNGaW5pdGUiLCJpcyIsInNpZ24iLCIkbnVtYmVyRG91YmxlIiwiaXNJbnRlZ2VyIiwidG9GaXhlZCIsImRvdWJsZVZhbHVlIiwicGFyc2VGbG9hdCIsIkludDMyIiwiJG51bWJlckludCIsIk1heEtleSIsIiRtYXhLZXkiLCJNaW5LZXkiLCIkbWluS2V5IiwiRkxPQVQiLCJGbG9hdDY0QXJyYXkiLCJGTE9BVF9CWVRFUyIsImlzQmlnRW5kaWFuIiwiTnVtYmVyVXRpbHMiLCJnZXROb25uZWdhdGl2ZUludDMyTEUiLCJnZXRJbnQzMkxFIiwiZ2V0VWludDMyTEUiLCJnZXRVaW50MzJCRSIsImdldEJpZ0ludDY0TEUiLCJnZXRGbG9hdDY0TEUiLCJzZXRJbnQzMkJFIiwic2V0SW50MzJMRSIsInNldEJpZ0ludDY0TEUiLCJtYXNrMzJiaXRzIiwic2V0RmxvYXQ2NExFIiwiY2hlY2tGb3JIZXhSZWdFeHAiLCJSZWdFeHAiLCJQUk9DRVNTX1VOSVFVRSIsIk9iamVjdElkIiwiaW5wdXRJZCIsIndvcmtpbmdJZCIsImNhY2hlSGV4U3RyaW5nIiwiX19pZCIsImdldEluYyIsInRpbWUiLCJEYXRlIiwibm93IiwiaW5jIiwidmFyaWFibGUiLCJ0b0xvd2VyQ2FzZSIsIm90aGVySWRTdHJpbmciLCJ0aGlzSWRTdHJpbmciLCJnZXRUaW1lc3RhbXAiLCJzZXRUaW1lIiwiY3JlYXRlUGsiLCJzZXJpYWxpemVJbnRvIiwiY3JlYXRlRnJvbVRpbWUiLCIkb2lkIiwiaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplIiwic2VyaWFsaXplRnVuY3Rpb25zIiwiaWdub3JlVW5kZWZpbmVkIiwidG90YWxMZW5ndGgiLCJjYWxjdWxhdGVFbGVtZW50IiwidG9CU09OIiwia2V5IiwiYmluYXJ5Iiwib3JkZXJlZF92YWx1ZXMiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwicGF0dGVybiIsImFscGhhYmV0aXplIiwic29ydCIsIkJTT05SZWdFeHAiLCJwYXJzZU9wdGlvbnMiLCIkcmVnZXgiLCIkb3B0aW9ucyIsIiRyZWd1bGFyRXhwcmVzc2lvbiIsImZsYWdzIiwiQlNPTlN5bWJvbCIsIiRzeW1ib2wiLCJMb25nV2l0aG91dE92ZXJyaWRlc0NsYXNzIiwiVGltZXN0YW1wIiwidCIsIiR0aW1lc3RhbXAiLCJvcHRSYWRpeCIsIkpTX0lOVF9NQVhfTE9ORyIsIkpTX0lOVF9NSU5fTE9ORyIsImludGVybmFsRGVzZXJpYWxpemUiLCJhbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSIsImRlc2VyaWFsaXplT2JqZWN0IiwiYWxsb3dlZERCUmVmS2V5cyIsImZpZWxkc0FzUmF3IiwicmF3IiwiYnNvblJlZ0V4cCIsInByb21vdGVCdWZmZXJzIiwicHJvbW90ZUxvbmdzIiwicHJvbW90ZVZhbHVlcyIsInZhbGlkYXRpb24iLCJ1dGY4IiwiZ2xvYmFsVVRGVmFsaWRhdGlvbiIsInZhbGlkYXRpb25TZXR0aW5nIiwidXRmOEtleXNTZXQiLCJ1dGY4VmFsaWRhdGVkS2V5cyIsInV0ZjhWYWxpZGF0aW9uVmFsdWVzIiwibWFwIiwiZXZlcnkiLCJpdGVtIiwiU2V0Iiwic3RhcnRJbmRleCIsImFycmF5SW5kZXgiLCJkb25lIiwiaXNQb3NzaWJsZURCUmVmIiwiZWxlbWVudFR5cGUiLCJzaG91bGRWYWxpZGF0ZUtleSIsImhhcyIsInN0cmluZ1NpemUiLCJfaW5kZXgiLCJvYmplY3RTaXplIiwib2JqZWN0T3B0aW9ucyIsImFycmF5T3B0aW9ucyIsInN0b3BJbmRleCIsImJpbmFyeVNpemUiLCJ0b3RhbEJpbmFyeVNpemUiLCJyZWdFeHBPcHRpb25zIiwib3B0aW9uc0FycmF5IiwiZnVuY3Rpb25TdHJpbmciLCJ0b3RhbFNpemUiLCJzY29wZU9iamVjdCIsIm9pZEJ1ZmZlciIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwicmVnZXhwIiwiaWdub3JlS2V5cyIsInNlcmlhbGl6ZVN0cmluZyIsIm51bWJlck9mV3JpdHRlbkJ5dGVzIiwic2VyaWFsaXplTnVtYmVyIiwiaXNOZWdhdGl2ZVplcm8iLCJpc1NhZmVJbnRlZ2VyIiwic2VyaWFsaXplQmlnSW50Iiwic2VyaWFsaXplTnVsbCIsIl8iLCJzZXJpYWxpemVCb29sZWFuIiwic2VyaWFsaXplRGF0ZSIsImRhdGVJbk1pbGlzIiwiZ2V0VGltZSIsInNlcmlhbGl6ZVJlZ0V4cCIsInNlcmlhbGl6ZUJTT05SZWdFeHAiLCJzb3J0ZWRPcHRpb25zIiwic2VyaWFsaXplTWluTWF4Iiwic2VyaWFsaXplT2JqZWN0SWQiLCJzZXJpYWxpemVCdWZmZXIiLCJzZXJpYWxpemVPYmplY3QiLCJjaGVja0tleXMiLCJwYXRoIiwiZW5kSW5kZXgiLCJkZWxldGUiLCJzZXJpYWxpemVEZWNpbWFsMTI4Iiwic2VyaWFsaXplTG9uZyIsInNlcmlhbGl6ZUludDMyIiwic2VyaWFsaXplRG91YmxlIiwic2VyaWFsaXplRnVuY3Rpb24iLCJzZXJpYWxpemVDb2RlIiwiY29kZVNpemUiLCJzZXJpYWxpemVCaW5hcnkiLCJzZXJpYWxpemVTeW1ib2wiLCJzZXJpYWxpemVEQlJlZiIsIm91dHB1dCIsInN0YXJ0aW5nSW5kZXgiLCJNYXAiLCJpdGVyYXRvciIsImVudHJpZXMiLCJlbnRyeSIsIm5leHQiLCJpc0JTT05UeXBlIiwia2V5c1RvQ29kZWNzIiwiZGVzZXJpYWxpemVWYWx1ZSIsImluMzJCaXRSYW5nZSIsImluNjRCaXRSYW5nZSIsIiR1bmRlZmluZWQiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiJGRhdGUiLCJwYXJzZSIsIiRkYlBvaW50ZXIiLCJkb2xsYXJLZXlzIiwidmFsaWQiLCJmb3JFYWNoIiwic2VyaWFsaXplQXJyYXkiLCJzZWVuT2JqZWN0cyIsInByb3BlcnR5TmFtZSIsInNlcmlhbGl6ZVZhbHVlIiwicG9wIiwiZ2V0SVNPU3RyaW5nIiwiaXNvU3RyIiwidG9JU09TdHJpbmciLCJnZXRVVENNaWxsaXNlY29uZHMiLCJjcmVhdGUiLCJmaW5kSW5kZXgiLCJwcm9wcyIsImxlYWRpbmdQYXJ0IiwicHJvcCIsImFscmVhZHlTZWVuIiwiY2lyY3VsYXJQYXJ0IiwiY3VycmVudCIsImxlYWRpbmdTcGFjZSIsInJlcGVhdCIsImRhc2hlcyIsImRhdGVOdW0iLCJpblJhbmdlIiwicngiLCJzZXJpYWxpemVEb2N1bWVudCIsIkJTT05fVFlQRV9NQVBQSU5HUyIsImxvd18iLCJoaWdoXyIsInVuc2lnbmVkXyIsImJzb250eXBlIiwiX2RvYyIsIm91dERvYyIsIm1hcHBlciIsInRleHQiLCJlanNvbk9wdGlvbnMiLCJyZXBsYWNlciIsInNwYWNlIiwic2VyaWFsaXplT3B0aW9ucyIsIkVKU09Oc2VyaWFsaXplIiwiRUpTT05kZXNlcmlhbGl6ZSIsImVqc29uIiwiRUpTT04iLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsImdldFNpemUiLCJmaW5kTnVsbCIsIm51bGxUZXJtaW5hdG9yT2Zmc2V0IiwicGFyc2VUb0VsZW1lbnRzIiwic3RhcnRPZmZzZXQiLCJkb2N1bWVudFNpemUiLCJlbGVtZW50cyIsIm5hbWVPZmZzZXQiLCJuYW1lTGVuZ3RoIiwib25EZW1hbmQiLCJNQVhTSVpFIiwic2V0SW50ZXJuYWxCdWZmZXJTaXplIiwibWluSW50ZXJuYWxCdWZmZXJTaXplIiwic2VyaWFsaXphdGlvbkluZGV4IiwiZmluaXNoZWRCdWZmZXIiLCJzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgiLCJmaW5hbEJ1ZmZlciIsImNhbGN1bGF0ZU9iamVjdFNpemUiLCJkZXNlcmlhbGl6ZVN0cmVhbSIsIm51bWJlck9mRG9jdW1lbnRzIiwiZG9jdW1lbnRzIiwiZG9jU3RhcnRJbmRleCIsImludGVybmFsT3B0aW9ucyIsImJ1ZmZlckRhdGEiLCJic29uIiwiX19wcm90b19fIiwiQlNPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bson/lib/bson.cjs\n");

/***/ })

};
;