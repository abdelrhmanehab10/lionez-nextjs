"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pg-pool";
exports.ids = ["vendor-chunks/pg-pool"];
exports.modules = {

/***/ "(ssr)/./node_modules/pg-pool/index.js":
/*!***************************************!*\
  !*** ./node_modules/pg-pool/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst NOOP = function() {};\nconst removeWhere = (list, predicate)=>{\n    const i = list.findIndex(predicate);\n    return i === -1 ? undefined : list.splice(i, 1)[0];\n};\nclass IdleItem {\n    constructor(client, idleListener, timeoutId){\n        this.client = client;\n        this.idleListener = idleListener;\n        this.timeoutId = timeoutId;\n    }\n}\nclass PendingItem {\n    constructor(callback){\n        this.callback = callback;\n    }\n}\nfunction throwOnDoubleRelease() {\n    throw new Error(\"Release called on client which has already been released to the pool.\");\n}\nfunction promisify(Promise, callback) {\n    if (callback) {\n        return {\n            callback: callback,\n            result: undefined\n        };\n    }\n    let rej;\n    let res;\n    const cb = function(err, client) {\n        err ? rej(err) : res(client);\n    };\n    const result = new Promise(function(resolve, reject) {\n        res = resolve;\n        rej = reject;\n    }).catch((err)=>{\n        // replace the stack trace that leads to `TCP.onStreamRead` with one that leads back to the\n        // application that created the query\n        Error.captureStackTrace(err);\n        throw err;\n    });\n    return {\n        callback: cb,\n        result: result\n    };\n}\nfunction makeIdleListener(pool, client) {\n    return function idleListener(err) {\n        err.client = client;\n        client.removeListener(\"error\", idleListener);\n        client.on(\"error\", ()=>{\n            pool.log(\"additional client error after disconnection due to error\", err);\n        });\n        pool._remove(client);\n        // TODO - document that once the pool emits an error\n        // the client has already been closed & purged and is unusable\n        pool.emit(\"error\", err, client);\n    };\n}\nclass Pool extends EventEmitter {\n    constructor(options, Client){\n        super();\n        this.options = Object.assign({}, options);\n        if (options != null && \"password\" in options) {\n            // \"hiding\" the password so it doesn't show up in stack traces\n            // or if the client is console.logged\n            Object.defineProperty(this.options, \"password\", {\n                configurable: true,\n                enumerable: false,\n                writable: true,\n                value: options.password\n            });\n        }\n        if (options != null && options.ssl && options.ssl.key) {\n            // \"hiding\" the ssl->key so it doesn't show up in stack traces\n            // or if the client is console.logged\n            Object.defineProperty(this.options.ssl, \"key\", {\n                enumerable: false\n            });\n        }\n        this.options.max = this.options.max || this.options.poolSize || 10;\n        this.options.maxUses = this.options.maxUses || Infinity;\n        this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;\n        this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;\n        this.log = this.options.log || function() {};\n        this.Client = this.options.Client || Client || (__webpack_require__(/*! pg */ \"(ssr)/./node_modules/pg/lib/index.js\").Client);\n        this.Promise = this.options.Promise || global.Promise;\n        if (typeof this.options.idleTimeoutMillis === \"undefined\") {\n            this.options.idleTimeoutMillis = 10000;\n        }\n        this._clients = [];\n        this._idle = [];\n        this._expired = new WeakSet();\n        this._pendingQueue = [];\n        this._endCallback = undefined;\n        this.ending = false;\n        this.ended = false;\n    }\n    _isFull() {\n        return this._clients.length >= this.options.max;\n    }\n    _pulseQueue() {\n        this.log(\"pulse queue\");\n        if (this.ended) {\n            this.log(\"pulse queue ended\");\n            return;\n        }\n        if (this.ending) {\n            this.log(\"pulse queue on ending\");\n            if (this._idle.length) {\n                this._idle.slice().map((item)=>{\n                    this._remove(item.client);\n                });\n            }\n            if (!this._clients.length) {\n                this.ended = true;\n                this._endCallback();\n            }\n            return;\n        }\n        // if we don't have any waiting, do nothing\n        if (!this._pendingQueue.length) {\n            this.log(\"no queued requests\");\n            return;\n        }\n        // if we don't have any idle clients and we have no more room do nothing\n        if (!this._idle.length && this._isFull()) {\n            return;\n        }\n        const pendingItem = this._pendingQueue.shift();\n        if (this._idle.length) {\n            const idleItem = this._idle.pop();\n            clearTimeout(idleItem.timeoutId);\n            const client = idleItem.client;\n            client.ref && client.ref();\n            const idleListener = idleItem.idleListener;\n            return this._acquireClient(client, pendingItem, idleListener, false);\n        }\n        if (!this._isFull()) {\n            return this.newClient(pendingItem);\n        }\n        throw new Error(\"unexpected condition\");\n    }\n    _remove(client) {\n        const removed = removeWhere(this._idle, (item)=>item.client === client);\n        if (removed !== undefined) {\n            clearTimeout(removed.timeoutId);\n        }\n        this._clients = this._clients.filter((c)=>c !== client);\n        client.end();\n        this.emit(\"remove\", client);\n    }\n    connect(cb) {\n        if (this.ending) {\n            const err = new Error(\"Cannot use a pool after calling end on the pool\");\n            return cb ? cb(err) : this.Promise.reject(err);\n        }\n        const response = promisify(this.Promise, cb);\n        const result = response.result;\n        // if we don't have to connect a new client, don't do so\n        if (this._isFull() || this._idle.length) {\n            // if we have idle clients schedule a pulse immediately\n            if (this._idle.length) {\n                process.nextTick(()=>this._pulseQueue());\n            }\n            if (!this.options.connectionTimeoutMillis) {\n                this._pendingQueue.push(new PendingItem(response.callback));\n                return result;\n            }\n            const queueCallback = (err, res, done)=>{\n                clearTimeout(tid);\n                response.callback(err, res, done);\n            };\n            const pendingItem = new PendingItem(queueCallback);\n            // set connection timeout on checking out an existing client\n            const tid = setTimeout(()=>{\n                // remove the callback from pending waiters because\n                // we're going to call it with a timeout error\n                removeWhere(this._pendingQueue, (i)=>i.callback === queueCallback);\n                pendingItem.timedOut = true;\n                response.callback(new Error(\"timeout exceeded when trying to connect\"));\n            }, this.options.connectionTimeoutMillis);\n            this._pendingQueue.push(pendingItem);\n            return result;\n        }\n        this.newClient(new PendingItem(response.callback));\n        return result;\n    }\n    newClient(pendingItem) {\n        const client = new this.Client(this.options);\n        this._clients.push(client);\n        const idleListener = makeIdleListener(this, client);\n        this.log(\"checking client timeout\");\n        // connection timeout logic\n        let tid;\n        let timeoutHit = false;\n        if (this.options.connectionTimeoutMillis) {\n            tid = setTimeout(()=>{\n                this.log(\"ending client due to timeout\");\n                timeoutHit = true;\n                // force kill the node driver, and let libpq do its teardown\n                client.connection ? client.connection.stream.destroy() : client.end();\n            }, this.options.connectionTimeoutMillis);\n        }\n        this.log(\"connecting new client\");\n        client.connect((err)=>{\n            if (tid) {\n                clearTimeout(tid);\n            }\n            client.on(\"error\", idleListener);\n            if (err) {\n                this.log(\"client failed to connect\", err);\n                // remove the dead client from our list of clients\n                this._clients = this._clients.filter((c)=>c !== client);\n                if (timeoutHit) {\n                    err.message = \"Connection terminated due to connection timeout\";\n                }\n                // this client wonâ€™t be released, so move on immediately\n                this._pulseQueue();\n                if (!pendingItem.timedOut) {\n                    pendingItem.callback(err, undefined, NOOP);\n                }\n            } else {\n                this.log(\"new client connected\");\n                if (this.options.maxLifetimeSeconds !== 0) {\n                    const maxLifetimeTimeout = setTimeout(()=>{\n                        this.log(\"ending client due to expired lifetime\");\n                        this._expired.add(client);\n                        const idleIndex = this._idle.findIndex((idleItem)=>idleItem.client === client);\n                        if (idleIndex !== -1) {\n                            this._acquireClient(client, new PendingItem((err, client, clientRelease)=>clientRelease()), idleListener, false);\n                        }\n                    }, this.options.maxLifetimeSeconds * 1000);\n                    maxLifetimeTimeout.unref();\n                    client.once(\"end\", ()=>clearTimeout(maxLifetimeTimeout));\n                }\n                return this._acquireClient(client, pendingItem, idleListener, true);\n            }\n        });\n    }\n    // acquire a client for a pending work item\n    _acquireClient(client, pendingItem, idleListener, isNew) {\n        if (isNew) {\n            this.emit(\"connect\", client);\n        }\n        this.emit(\"acquire\", client);\n        client.release = this._releaseOnce(client, idleListener);\n        client.removeListener(\"error\", idleListener);\n        if (!pendingItem.timedOut) {\n            if (isNew && this.options.verify) {\n                this.options.verify(client, (err)=>{\n                    if (err) {\n                        client.release(err);\n                        return pendingItem.callback(err, undefined, NOOP);\n                    }\n                    pendingItem.callback(undefined, client, client.release);\n                });\n            } else {\n                pendingItem.callback(undefined, client, client.release);\n            }\n        } else {\n            if (isNew && this.options.verify) {\n                this.options.verify(client, client.release);\n            } else {\n                client.release();\n            }\n        }\n    }\n    // returns a function that wraps _release and throws if called more than once\n    _releaseOnce(client, idleListener) {\n        let released = false;\n        return (err)=>{\n            if (released) {\n                throwOnDoubleRelease();\n            }\n            released = true;\n            this._release(client, idleListener, err);\n        };\n    }\n    // release a client back to the poll, include an error\n    // to remove it from the pool\n    _release(client, idleListener, err) {\n        client.on(\"error\", idleListener);\n        client._poolUseCount = (client._poolUseCount || 0) + 1;\n        this.emit(\"release\", err, client);\n        // TODO(bmc): expose a proper, public interface _queryable and _ending\n        if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {\n            if (client._poolUseCount >= this.options.maxUses) {\n                this.log(\"remove expended client\");\n            }\n            this._remove(client);\n            this._pulseQueue();\n            return;\n        }\n        const isExpired = this._expired.has(client);\n        if (isExpired) {\n            this.log(\"remove expired client\");\n            this._expired.delete(client);\n            this._remove(client);\n            this._pulseQueue();\n            return;\n        }\n        // idle timeout\n        let tid;\n        if (this.options.idleTimeoutMillis) {\n            tid = setTimeout(()=>{\n                this.log(\"remove idle client\");\n                this._remove(client);\n            }, this.options.idleTimeoutMillis);\n            if (this.options.allowExitOnIdle) {\n                // allow Node to exit if this is all that's left\n                tid.unref();\n            }\n        }\n        if (this.options.allowExitOnIdle) {\n            client.unref();\n        }\n        this._idle.push(new IdleItem(client, idleListener, tid));\n        this._pulseQueue();\n    }\n    query(text, values, cb) {\n        // guard clause against passing a function as the first parameter\n        if (typeof text === \"function\") {\n            const response = promisify(this.Promise, text);\n            setImmediate(function() {\n                return response.callback(new Error(\"Passing a function as the first parameter to pool.query is not supported\"));\n            });\n            return response.result;\n        }\n        // allow plain text query without values\n        if (typeof values === \"function\") {\n            cb = values;\n            values = undefined;\n        }\n        const response = promisify(this.Promise, cb);\n        cb = response.callback;\n        this.connect((err, client)=>{\n            if (err) {\n                return cb(err);\n            }\n            let clientReleased = false;\n            const onError = (err)=>{\n                if (clientReleased) {\n                    return;\n                }\n                clientReleased = true;\n                client.release(err);\n                cb(err);\n            };\n            client.once(\"error\", onError);\n            this.log(\"dispatching query\");\n            try {\n                client.query(text, values, (err, res)=>{\n                    this.log(\"query dispatched\");\n                    client.removeListener(\"error\", onError);\n                    if (clientReleased) {\n                        return;\n                    }\n                    clientReleased = true;\n                    client.release(err);\n                    if (err) {\n                        return cb(err);\n                    }\n                    return cb(undefined, res);\n                });\n            } catch (err) {\n                client.release(err);\n                return cb(err);\n            }\n        });\n        return response.result;\n    }\n    end(cb) {\n        this.log(\"ending\");\n        if (this.ending) {\n            const err = new Error(\"Called end on pool more than once\");\n            return cb ? cb(err) : this.Promise.reject(err);\n        }\n        this.ending = true;\n        const promised = promisify(this.Promise, cb);\n        this._endCallback = promised.callback;\n        this._pulseQueue();\n        return promised.result;\n    }\n    get waitingCount() {\n        return this._pendingQueue.length;\n    }\n    get idleCount() {\n        return this._idle.length;\n    }\n    get expiredCount() {\n        return this._clients.reduce((acc, client)=>acc + (this._expired.has(client) ? 1 : 0), 0);\n    }\n    get totalCount() {\n        return this._clients.length;\n    }\n}\nmodule.exports = Pool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFlBQVksR0FBRzZELFNBQVM1RyxRQUFRO1FBQ3JDLElBQUksQ0FBQ29ELFdBQVc7UUFDaEIsT0FBT3dELFNBQVN2RyxNQUFNO0lBQ3hCO0lBRUEsSUFBSXdHLGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUMvRCxhQUFhLENBQUNLLE1BQU07SUFDbEM7SUFFQSxJQUFJMkQsWUFBWTtRQUNkLE9BQU8sSUFBSSxDQUFDbkUsS0FBSyxDQUFDUSxNQUFNO0lBQzFCO0lBRUEsSUFBSTRELGVBQWU7UUFDakIsT0FBTyxJQUFJLENBQUNyRSxRQUFRLENBQUNzRSxNQUFNLENBQUMsQ0FBQ0MsS0FBS3JILFNBQVdxSCxNQUFPLEtBQUksQ0FBQ3JFLFFBQVEsQ0FBQ3dELEdBQUcsQ0FBQ3hHLFVBQVUsSUFBSSxJQUFJO0lBQzFGO0lBRUEsSUFBSXNILGFBQWE7UUFDZixPQUFPLElBQUksQ0FBQ3hFLFFBQVEsQ0FBQ1MsTUFBTTtJQUM3QjtBQUNGO0FBQ0FnRSxPQUFPQyxPQUFPLEdBQUcvRiIsInNvdXJjZXMiOlsid2VicGFjazovL2xpb25lei1uZXh0anMvLi9ub2RlX21vZHVsZXMvcGctcG9vbC9pbmRleC5qcz82OGU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5cbmNvbnN0IE5PT1AgPSBmdW5jdGlvbiAoKSB7fVxuXG5jb25zdCByZW1vdmVXaGVyZSA9IChsaXN0LCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgaSA9IGxpc3QuZmluZEluZGV4KHByZWRpY2F0ZSlcblxuICByZXR1cm4gaSA9PT0gLTEgPyB1bmRlZmluZWQgOiBsaXN0LnNwbGljZShpLCAxKVswXVxufVxuXG5jbGFzcyBJZGxlSXRlbSB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudCwgaWRsZUxpc3RlbmVyLCB0aW1lb3V0SWQpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIHRoaXMuaWRsZUxpc3RlbmVyID0gaWRsZUxpc3RlbmVyXG4gICAgdGhpcy50aW1lb3V0SWQgPSB0aW1lb3V0SWRcbiAgfVxufVxuXG5jbGFzcyBQZW5kaW5nSXRlbSB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrXG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dPbkRvdWJsZVJlbGVhc2UoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVsZWFzZSBjYWxsZWQgb24gY2xpZW50IHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gcmVsZWFzZWQgdG8gdGhlIHBvb2wuJylcbn1cblxuZnVuY3Rpb24gcHJvbWlzaWZ5KFByb21pc2UsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIHJldHVybiB7IGNhbGxiYWNrOiBjYWxsYmFjaywgcmVzdWx0OiB1bmRlZmluZWQgfVxuICB9XG4gIGxldCByZWpcbiAgbGV0IHJlc1xuICBjb25zdCBjYiA9IGZ1bmN0aW9uIChlcnIsIGNsaWVudCkge1xuICAgIGVyciA/IHJlaihlcnIpIDogcmVzKGNsaWVudClcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgLy8gcmVwbGFjZSB0aGUgc3RhY2sgdHJhY2UgdGhhdCBsZWFkcyB0byBgVENQLm9uU3RyZWFtUmVhZGAgd2l0aCBvbmUgdGhhdCBsZWFkcyBiYWNrIHRvIHRoZVxuICAgIC8vIGFwcGxpY2F0aW9uIHRoYXQgY3JlYXRlZCB0aGUgcXVlcnlcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIpXG4gICAgdGhyb3cgZXJyXG4gIH0pXG4gIHJldHVybiB7IGNhbGxiYWNrOiBjYiwgcmVzdWx0OiByZXN1bHQgfVxufVxuXG5mdW5jdGlvbiBtYWtlSWRsZUxpc3RlbmVyKHBvb2wsIGNsaWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gaWRsZUxpc3RlbmVyKGVycikge1xuICAgIGVyci5jbGllbnQgPSBjbGllbnRcblxuICAgIGNsaWVudC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG4gICAgY2xpZW50Lm9uKCdlcnJvcicsICgpID0+IHtcbiAgICAgIHBvb2wubG9nKCdhZGRpdGlvbmFsIGNsaWVudCBlcnJvciBhZnRlciBkaXNjb25uZWN0aW9uIGR1ZSB0byBlcnJvcicsIGVycilcbiAgICB9KVxuICAgIHBvb2wuX3JlbW92ZShjbGllbnQpXG4gICAgLy8gVE9ETyAtIGRvY3VtZW50IHRoYXQgb25jZSB0aGUgcG9vbCBlbWl0cyBhbiBlcnJvclxuICAgIC8vIHRoZSBjbGllbnQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgJiBwdXJnZWQgYW5kIGlzIHVudXNhYmxlXG4gICAgcG9vbC5lbWl0KCdlcnJvcicsIGVyciwgY2xpZW50KVxuICB9XG59XG5cbmNsYXNzIFBvb2wgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBDbGllbnQpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucylcblxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgJ3Bhc3N3b3JkJyBpbiBvcHRpb25zKSB7XG4gICAgICAvLyBcImhpZGluZ1wiIHRoZSBwYXNzd29yZCBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gICAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLCAncGFzc3dvcmQnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5zc2wgJiYgb3B0aW9ucy5zc2wua2V5KSB7XG4gICAgICAvLyBcImhpZGluZ1wiIHRoZSBzc2wtPmtleSBzbyBpdCBkb2Vzbid0IHNob3cgdXAgaW4gc3RhY2sgdHJhY2VzXG4gICAgICAvLyBvciBpZiB0aGUgY2xpZW50IGlzIGNvbnNvbGUubG9nZ2VkXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5vcHRpb25zLnNzbCwgJ2tleScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucy5tYXggPSB0aGlzLm9wdGlvbnMubWF4IHx8IHRoaXMub3B0aW9ucy5wb29sU2l6ZSB8fCAxMFxuICAgIHRoaXMub3B0aW9ucy5tYXhVc2VzID0gdGhpcy5vcHRpb25zLm1heFVzZXMgfHwgSW5maW5pdHlcbiAgICB0aGlzLm9wdGlvbnMuYWxsb3dFeGl0T25JZGxlID0gdGhpcy5vcHRpb25zLmFsbG93RXhpdE9uSWRsZSB8fCBmYWxzZVxuICAgIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgPSB0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzIHx8IDBcbiAgICB0aGlzLmxvZyA9IHRoaXMub3B0aW9ucy5sb2cgfHwgZnVuY3Rpb24gKCkge31cbiAgICB0aGlzLkNsaWVudCA9IHRoaXMub3B0aW9ucy5DbGllbnQgfHwgQ2xpZW50IHx8IHJlcXVpcmUoJ3BnJykuQ2xpZW50XG4gICAgdGhpcy5Qcm9taXNlID0gdGhpcy5vcHRpb25zLlByb21pc2UgfHwgZ2xvYmFsLlByb21pc2VcblxuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vcHRpb25zLmlkbGVUaW1lb3V0TWlsbGlzID0gMTAwMDBcbiAgICB9XG5cbiAgICB0aGlzLl9jbGllbnRzID0gW11cbiAgICB0aGlzLl9pZGxlID0gW11cbiAgICB0aGlzLl9leHBpcmVkID0gbmV3IFdlYWtTZXQoKVxuICAgIHRoaXMuX3BlbmRpbmdRdWV1ZSA9IFtdXG4gICAgdGhpcy5fZW5kQ2FsbGJhY2sgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5lbmRlZCA9IGZhbHNlXG4gIH1cblxuICBfaXNGdWxsKCkge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnRzLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMubWF4XG4gIH1cblxuICBfcHVsc2VRdWV1ZSgpIHtcbiAgICB0aGlzLmxvZygncHVsc2UgcXVldWUnKVxuICAgIGlmICh0aGlzLmVuZGVkKSB7XG4gICAgICB0aGlzLmxvZygncHVsc2UgcXVldWUgZW5kZWQnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmVuZGluZykge1xuICAgICAgdGhpcy5sb2coJ3B1bHNlIHF1ZXVlIG9uIGVuZGluZycpXG4gICAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faWRsZS5zbGljZSgpLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JlbW92ZShpdGVtLmNsaWVudClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fY2xpZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5lbmRlZCA9IHRydWVcbiAgICAgICAgdGhpcy5fZW5kQ2FsbGJhY2soKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgd2FpdGluZywgZG8gbm90aGluZ1xuICAgIGlmICghdGhpcy5fcGVuZGluZ1F1ZXVlLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2coJ25vIHF1ZXVlZCByZXF1ZXN0cycpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSBhbnkgaWRsZSBjbGllbnRzIGFuZCB3ZSBoYXZlIG5vIG1vcmUgcm9vbSBkbyBub3RoaW5nXG4gICAgaWYgKCF0aGlzLl9pZGxlLmxlbmd0aCAmJiB0aGlzLl9pc0Z1bGwoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHBlbmRpbmdJdGVtID0gdGhpcy5fcGVuZGluZ1F1ZXVlLnNoaWZ0KClcbiAgICBpZiAodGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGlkbGVJdGVtID0gdGhpcy5faWRsZS5wb3AoKVxuICAgICAgY2xlYXJUaW1lb3V0KGlkbGVJdGVtLnRpbWVvdXRJZClcbiAgICAgIGNvbnN0IGNsaWVudCA9IGlkbGVJdGVtLmNsaWVudFxuICAgICAgY2xpZW50LnJlZiAmJiBjbGllbnQucmVmKClcbiAgICAgIGNvbnN0IGlkbGVMaXN0ZW5lciA9IGlkbGVJdGVtLmlkbGVMaXN0ZW5lclxuXG4gICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIGZhbHNlKVxuICAgIH1cbiAgICBpZiAoIXRoaXMuX2lzRnVsbCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5uZXdDbGllbnQocGVuZGluZ0l0ZW0pXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBjb25kaXRpb24nKVxuICB9XG5cbiAgX3JlbW92ZShjbGllbnQpIHtcbiAgICBjb25zdCByZW1vdmVkID0gcmVtb3ZlV2hlcmUodGhpcy5faWRsZSwgKGl0ZW0pID0+IGl0ZW0uY2xpZW50ID09PSBjbGllbnQpXG5cbiAgICBpZiAocmVtb3ZlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVtb3ZlZC50aW1lb3V0SWQpXG4gICAgfVxuXG4gICAgdGhpcy5fY2xpZW50cyA9IHRoaXMuX2NsaWVudHMuZmlsdGVyKChjKSA9PiBjICE9PSBjbGllbnQpXG4gICAgY2xpZW50LmVuZCgpXG4gICAgdGhpcy5lbWl0KCdyZW1vdmUnLCBjbGllbnQpXG4gIH1cblxuICBjb25uZWN0KGNiKSB7XG4gICAgaWYgKHRoaXMuZW5kaW5nKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYSBwb29sIGFmdGVyIGNhbGxpbmcgZW5kIG9uIHRoZSBwb29sJylcbiAgICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB0aGlzLlByb21pc2UucmVqZWN0KGVycilcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlc3BvbnNlLnJlc3VsdFxuXG4gICAgLy8gaWYgd2UgZG9uJ3QgaGF2ZSB0byBjb25uZWN0IGEgbmV3IGNsaWVudCwgZG9uJ3QgZG8gc29cbiAgICBpZiAodGhpcy5faXNGdWxsKCkgfHwgdGhpcy5faWRsZS5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIHdlIGhhdmUgaWRsZSBjbGllbnRzIHNjaGVkdWxlIGEgcHVsc2UgaW1tZWRpYXRlbHlcbiAgICAgIGlmICh0aGlzLl9pZGxlLmxlbmd0aCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHRoaXMuX3B1bHNlUXVldWUoKSlcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpIHtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1F1ZXVlLnB1c2gobmV3IFBlbmRpbmdJdGVtKHJlc3BvbnNlLmNhbGxiYWNrKSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuXG4gICAgICBjb25zdCBxdWV1ZUNhbGxiYWNrID0gKGVyciwgcmVzLCBkb25lKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aWQpXG4gICAgICAgIHJlc3BvbnNlLmNhbGxiYWNrKGVyciwgcmVzLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwZW5kaW5nSXRlbSA9IG5ldyBQZW5kaW5nSXRlbShxdWV1ZUNhbGxiYWNrKVxuXG4gICAgICAvLyBzZXQgY29ubmVjdGlvbiB0aW1lb3V0IG9uIGNoZWNraW5nIG91dCBhbiBleGlzdGluZyBjbGllbnRcbiAgICAgIGNvbnN0IHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGNhbGxiYWNrIGZyb20gcGVuZGluZyB3YWl0ZXJzIGJlY2F1c2VcbiAgICAgICAgLy8gd2UncmUgZ29pbmcgdG8gY2FsbCBpdCB3aXRoIGEgdGltZW91dCBlcnJvclxuICAgICAgICByZW1vdmVXaGVyZSh0aGlzLl9wZW5kaW5nUXVldWUsIChpKSA9PiBpLmNhbGxiYWNrID09PSBxdWV1ZUNhbGxiYWNrKVxuICAgICAgICBwZW5kaW5nSXRlbS50aW1lZE91dCA9IHRydWVcbiAgICAgICAgcmVzcG9uc2UuY2FsbGJhY2sobmV3IEVycm9yKCd0aW1lb3V0IGV4Y2VlZGVkIHdoZW4gdHJ5aW5nIHRvIGNvbm5lY3QnKSlcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcylcblxuICAgICAgdGhpcy5fcGVuZGluZ1F1ZXVlLnB1c2gocGVuZGluZ0l0ZW0pXG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgdGhpcy5uZXdDbGllbnQobmV3IFBlbmRpbmdJdGVtKHJlc3BvbnNlLmNhbGxiYWNrKSlcblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIG5ld0NsaWVudChwZW5kaW5nSXRlbSkge1xuICAgIGNvbnN0IGNsaWVudCA9IG5ldyB0aGlzLkNsaWVudCh0aGlzLm9wdGlvbnMpXG4gICAgdGhpcy5fY2xpZW50cy5wdXNoKGNsaWVudClcbiAgICBjb25zdCBpZGxlTGlzdGVuZXIgPSBtYWtlSWRsZUxpc3RlbmVyKHRoaXMsIGNsaWVudClcblxuICAgIHRoaXMubG9nKCdjaGVja2luZyBjbGllbnQgdGltZW91dCcpXG5cbiAgICAvLyBjb25uZWN0aW9uIHRpbWVvdXQgbG9naWNcbiAgICBsZXQgdGlkXG4gICAgbGV0IHRpbWVvdXRIaXQgPSBmYWxzZVxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29ubmVjdGlvblRpbWVvdXRNaWxsaXMpIHtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygnZW5kaW5nIGNsaWVudCBkdWUgdG8gdGltZW91dCcpXG4gICAgICAgIHRpbWVvdXRIaXQgPSB0cnVlXG4gICAgICAgIC8vIGZvcmNlIGtpbGwgdGhlIG5vZGUgZHJpdmVyLCBhbmQgbGV0IGxpYnBxIGRvIGl0cyB0ZWFyZG93blxuICAgICAgICBjbGllbnQuY29ubmVjdGlvbiA/IGNsaWVudC5jb25uZWN0aW9uLnN0cmVhbS5kZXN0cm95KCkgOiBjbGllbnQuZW5kKClcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5jb25uZWN0aW9uVGltZW91dE1pbGxpcylcbiAgICB9XG5cbiAgICB0aGlzLmxvZygnY29ubmVjdGluZyBuZXcgY2xpZW50JylcbiAgICBjbGllbnQuY29ubmVjdCgoZXJyKSA9PiB7XG4gICAgICBpZiAodGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aWQpXG4gICAgICB9XG4gICAgICBjbGllbnQub24oJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmxvZygnY2xpZW50IGZhaWxlZCB0byBjb25uZWN0JywgZXJyKVxuICAgICAgICAvLyByZW1vdmUgdGhlIGRlYWQgY2xpZW50IGZyb20gb3VyIGxpc3Qgb2YgY2xpZW50c1xuICAgICAgICB0aGlzLl9jbGllbnRzID0gdGhpcy5fY2xpZW50cy5maWx0ZXIoKGMpID0+IGMgIT09IGNsaWVudClcbiAgICAgICAgaWYgKHRpbWVvdXRIaXQpIHtcbiAgICAgICAgICBlcnIubWVzc2FnZSA9ICdDb25uZWN0aW9uIHRlcm1pbmF0ZWQgZHVlIHRvIGNvbm5lY3Rpb24gdGltZW91dCdcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMgY2xpZW50IHdvbuKAmXQgYmUgcmVsZWFzZWQsIHNvIG1vdmUgb24gaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG5cbiAgICAgICAgaWYgKCFwZW5kaW5nSXRlbS50aW1lZE91dCkge1xuICAgICAgICAgIHBlbmRpbmdJdGVtLmNhbGxiYWNrKGVyciwgdW5kZWZpbmVkLCBOT09QKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZygnbmV3IGNsaWVudCBjb25uZWN0ZWQnKVxuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubWF4TGlmZXRpbWVTZWNvbmRzICE9PSAwKSB7XG4gICAgICAgICAgY29uc3QgbWF4TGlmZXRpbWVUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZygnZW5kaW5nIGNsaWVudCBkdWUgdG8gZXhwaXJlZCBsaWZldGltZScpXG4gICAgICAgICAgICB0aGlzLl9leHBpcmVkLmFkZChjbGllbnQpXG4gICAgICAgICAgICBjb25zdCBpZGxlSW5kZXggPSB0aGlzLl9pZGxlLmZpbmRJbmRleCgoaWRsZUl0ZW0pID0+IGlkbGVJdGVtLmNsaWVudCA9PT0gY2xpZW50KVxuICAgICAgICAgICAgaWYgKGlkbGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fYWNxdWlyZUNsaWVudChcbiAgICAgICAgICAgICAgICBjbGllbnQsXG4gICAgICAgICAgICAgICAgbmV3IFBlbmRpbmdJdGVtKChlcnIsIGNsaWVudCwgY2xpZW50UmVsZWFzZSkgPT4gY2xpZW50UmVsZWFzZSgpKSxcbiAgICAgICAgICAgICAgICBpZGxlTGlzdGVuZXIsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5tYXhMaWZldGltZVNlY29uZHMgKiAxMDAwKVxuXG4gICAgICAgICAgbWF4TGlmZXRpbWVUaW1lb3V0LnVucmVmKClcbiAgICAgICAgICBjbGllbnQub25jZSgnZW5kJywgKCkgPT4gY2xlYXJUaW1lb3V0KG1heExpZmV0aW1lVGltZW91dCkpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fYWNxdWlyZUNsaWVudChjbGllbnQsIHBlbmRpbmdJdGVtLCBpZGxlTGlzdGVuZXIsIHRydWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGFjcXVpcmUgYSBjbGllbnQgZm9yIGEgcGVuZGluZyB3b3JrIGl0ZW1cbiAgX2FjcXVpcmVDbGllbnQoY2xpZW50LCBwZW5kaW5nSXRlbSwgaWRsZUxpc3RlbmVyLCBpc05ldykge1xuICAgIGlmIChpc05ldykge1xuICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgY2xpZW50KVxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnYWNxdWlyZScsIGNsaWVudClcblxuICAgIGNsaWVudC5yZWxlYXNlID0gdGhpcy5fcmVsZWFzZU9uY2UoY2xpZW50LCBpZGxlTGlzdGVuZXIpXG5cbiAgICBjbGllbnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgaWRsZUxpc3RlbmVyKVxuXG4gICAgaWYgKCFwZW5kaW5nSXRlbS50aW1lZE91dCkge1xuICAgICAgaWYgKGlzTmV3ICYmIHRoaXMub3B0aW9ucy52ZXJpZnkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZlcmlmeShjbGllbnQsIChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgICAgICByZXR1cm4gcGVuZGluZ0l0ZW0uY2FsbGJhY2soZXJyLCB1bmRlZmluZWQsIE5PT1ApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2sodW5kZWZpbmVkLCBjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVuZGluZ0l0ZW0uY2FsbGJhY2sodW5kZWZpbmVkLCBjbGllbnQsIGNsaWVudC5yZWxlYXNlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOZXcgJiYgdGhpcy5vcHRpb25zLnZlcmlmeSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5KGNsaWVudCwgY2xpZW50LnJlbGVhc2UpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnQucmVsZWFzZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgX3JlbGVhc2UgYW5kIHRocm93cyBpZiBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgX3JlbGVhc2VPbmNlKGNsaWVudCwgaWRsZUxpc3RlbmVyKSB7XG4gICAgbGV0IHJlbGVhc2VkID0gZmFsc2VcblxuICAgIHJldHVybiAoZXJyKSA9PiB7XG4gICAgICBpZiAocmVsZWFzZWQpIHtcbiAgICAgICAgdGhyb3dPbkRvdWJsZVJlbGVhc2UoKVxuICAgICAgfVxuXG4gICAgICByZWxlYXNlZCA9IHRydWVcbiAgICAgIHRoaXMuX3JlbGVhc2UoY2xpZW50LCBpZGxlTGlzdGVuZXIsIGVycilcbiAgICB9XG4gIH1cblxuICAvLyByZWxlYXNlIGEgY2xpZW50IGJhY2sgdG8gdGhlIHBvbGwsIGluY2x1ZGUgYW4gZXJyb3JcbiAgLy8gdG8gcmVtb3ZlIGl0IGZyb20gdGhlIHBvb2xcbiAgX3JlbGVhc2UoY2xpZW50LCBpZGxlTGlzdGVuZXIsIGVycikge1xuICAgIGNsaWVudC5vbignZXJyb3InLCBpZGxlTGlzdGVuZXIpXG5cbiAgICBjbGllbnQuX3Bvb2xVc2VDb3VudCA9IChjbGllbnQuX3Bvb2xVc2VDb3VudCB8fCAwKSArIDFcblxuICAgIHRoaXMuZW1pdCgncmVsZWFzZScsIGVyciwgY2xpZW50KVxuXG4gICAgLy8gVE9ETyhibWMpOiBleHBvc2UgYSBwcm9wZXIsIHB1YmxpYyBpbnRlcmZhY2UgX3F1ZXJ5YWJsZSBhbmQgX2VuZGluZ1xuICAgIGlmIChlcnIgfHwgdGhpcy5lbmRpbmcgfHwgIWNsaWVudC5fcXVlcnlhYmxlIHx8IGNsaWVudC5fZW5kaW5nIHx8IGNsaWVudC5fcG9vbFVzZUNvdW50ID49IHRoaXMub3B0aW9ucy5tYXhVc2VzKSB7XG4gICAgICBpZiAoY2xpZW50Ll9wb29sVXNlQ291bnQgPj0gdGhpcy5vcHRpb25zLm1heFVzZXMpIHtcbiAgICAgICAgdGhpcy5sb2coJ3JlbW92ZSBleHBlbmRlZCBjbGllbnQnKVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudClcbiAgICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaXNFeHBpcmVkID0gdGhpcy5fZXhwaXJlZC5oYXMoY2xpZW50KVxuICAgIGlmIChpc0V4cGlyZWQpIHtcbiAgICAgIHRoaXMubG9nKCdyZW1vdmUgZXhwaXJlZCBjbGllbnQnKVxuICAgICAgdGhpcy5fZXhwaXJlZC5kZWxldGUoY2xpZW50KVxuICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudClcbiAgICAgIHRoaXMuX3B1bHNlUXVldWUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gaWRsZSB0aW1lb3V0XG4gICAgbGV0IHRpZFxuICAgIGlmICh0aGlzLm9wdGlvbnMuaWRsZVRpbWVvdXRNaWxsaXMpIHtcbiAgICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmxvZygncmVtb3ZlIGlkbGUgY2xpZW50JylcbiAgICAgICAgdGhpcy5fcmVtb3ZlKGNsaWVudClcbiAgICAgIH0sIHRoaXMub3B0aW9ucy5pZGxlVGltZW91dE1pbGxpcylcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUpIHtcbiAgICAgICAgLy8gYWxsb3cgTm9kZSB0byBleGl0IGlmIHRoaXMgaXMgYWxsIHRoYXQncyBsZWZ0XG4gICAgICAgIHRpZC51bnJlZigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbGxvd0V4aXRPbklkbGUpIHtcbiAgICAgIGNsaWVudC51bnJlZigpXG4gICAgfVxuXG4gICAgdGhpcy5faWRsZS5wdXNoKG5ldyBJZGxlSXRlbShjbGllbnQsIGlkbGVMaXN0ZW5lciwgdGlkKSlcbiAgICB0aGlzLl9wdWxzZVF1ZXVlKClcbiAgfVxuXG4gIHF1ZXJ5KHRleHQsIHZhbHVlcywgY2IpIHtcbiAgICAvLyBndWFyZCBjbGF1c2UgYWdhaW5zdCBwYXNzaW5nIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlclxuICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBwcm9taXNpZnkodGhpcy5Qcm9taXNlLCB0ZXh0KVxuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmNhbGxiYWNrKG5ldyBFcnJvcignUGFzc2luZyBhIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIgdG8gcG9vbC5xdWVyeSBpcyBub3Qgc3VwcG9ydGVkJykpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdFxuICAgIH1cblxuICAgIC8vIGFsbG93IHBsYWluIHRleHQgcXVlcnkgd2l0aG91dCB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIHZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSB2YWx1ZXNcbiAgICAgIHZhbHVlcyA9IHVuZGVmaW5lZFxuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHByb21pc2lmeSh0aGlzLlByb21pc2UsIGNiKVxuICAgIGNiID0gcmVzcG9uc2UuY2FsbGJhY2tcblxuICAgIHRoaXMuY29ubmVjdCgoZXJyLCBjbGllbnQpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGNiKGVycilcbiAgICAgIH1cblxuICAgICAgbGV0IGNsaWVudFJlbGVhc2VkID0gZmFsc2VcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChjbGllbnRSZWxlYXNlZCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNsaWVudFJlbGVhc2VkID0gdHJ1ZVxuICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgIGNiKGVycilcbiAgICAgIH1cblxuICAgICAgY2xpZW50Lm9uY2UoJ2Vycm9yJywgb25FcnJvcilcbiAgICAgIHRoaXMubG9nKCdkaXNwYXRjaGluZyBxdWVyeScpXG4gICAgICB0cnkge1xuICAgICAgICBjbGllbnQucXVlcnkodGV4dCwgdmFsdWVzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICB0aGlzLmxvZygncXVlcnkgZGlzcGF0Y2hlZCcpXG4gICAgICAgICAgY2xpZW50LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpXG4gICAgICAgICAgaWYgKGNsaWVudFJlbGVhc2VkKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgICAgY2xpZW50UmVsZWFzZWQgPSB0cnVlXG4gICAgICAgICAgY2xpZW50LnJlbGVhc2UoZXJyKVxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYih1bmRlZmluZWQsIHJlcylcbiAgICAgICAgfSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjbGllbnQucmVsZWFzZShlcnIpXG4gICAgICAgIHJldHVybiBjYihlcnIpXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0XG4gIH1cblxuICBlbmQoY2IpIHtcbiAgICB0aGlzLmxvZygnZW5kaW5nJylcbiAgICBpZiAodGhpcy5lbmRpbmcpIHtcbiAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignQ2FsbGVkIGVuZCBvbiBwb29sIG1vcmUgdGhhbiBvbmNlJylcbiAgICAgIHJldHVybiBjYiA/IGNiKGVycikgOiB0aGlzLlByb21pc2UucmVqZWN0KGVycilcbiAgICB9XG4gICAgdGhpcy5lbmRpbmcgPSB0cnVlXG4gICAgY29uc3QgcHJvbWlzZWQgPSBwcm9taXNpZnkodGhpcy5Qcm9taXNlLCBjYilcbiAgICB0aGlzLl9lbmRDYWxsYmFjayA9IHByb21pc2VkLmNhbGxiYWNrXG4gICAgdGhpcy5fcHVsc2VRdWV1ZSgpXG4gICAgcmV0dXJuIHByb21pc2VkLnJlc3VsdFxuICB9XG5cbiAgZ2V0IHdhaXRpbmdDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGVuZGluZ1F1ZXVlLmxlbmd0aFxuICB9XG5cbiAgZ2V0IGlkbGVDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5faWRsZS5sZW5ndGhcbiAgfVxuXG4gIGdldCBleHBpcmVkQ291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudHMucmVkdWNlKChhY2MsIGNsaWVudCkgPT4gYWNjICsgKHRoaXMuX2V4cGlyZWQuaGFzKGNsaWVudCkgPyAxIDogMCksIDApXG4gIH1cblxuICBnZXQgdG90YWxDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50cy5sZW5ndGhcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBQb29sXG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsIk5PT1AiLCJyZW1vdmVXaGVyZSIsImxpc3QiLCJwcmVkaWNhdGUiLCJpIiwiZmluZEluZGV4IiwidW5kZWZpbmVkIiwic3BsaWNlIiwiSWRsZUl0ZW0iLCJjb25zdHJ1Y3RvciIsImNsaWVudCIsImlkbGVMaXN0ZW5lciIsInRpbWVvdXRJZCIsIlBlbmRpbmdJdGVtIiwiY2FsbGJhY2siLCJ0aHJvd09uRG91YmxlUmVsZWFzZSIsIkVycm9yIiwicHJvbWlzaWZ5IiwiUHJvbWlzZSIsInJlc3VsdCIsInJlaiIsInJlcyIsImNiIiwiZXJyIiwicmVzb2x2ZSIsInJlamVjdCIsImNhdGNoIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJtYWtlSWRsZUxpc3RlbmVyIiwicG9vbCIsInJlbW92ZUxpc3RlbmVyIiwib24iLCJsb2ciLCJfcmVtb3ZlIiwiZW1pdCIsIlBvb2wiLCJvcHRpb25zIiwiQ2xpZW50IiwiT2JqZWN0IiwiYXNzaWduIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJ2YWx1ZSIsInBhc3N3b3JkIiwic3NsIiwia2V5IiwibWF4IiwicG9vbFNpemUiLCJtYXhVc2VzIiwiSW5maW5pdHkiLCJhbGxvd0V4aXRPbklkbGUiLCJtYXhMaWZldGltZVNlY29uZHMiLCJnbG9iYWwiLCJpZGxlVGltZW91dE1pbGxpcyIsIl9jbGllbnRzIiwiX2lkbGUiLCJfZXhwaXJlZCIsIldlYWtTZXQiLCJfcGVuZGluZ1F1ZXVlIiwiX2VuZENhbGxiYWNrIiwiZW5kaW5nIiwiZW5kZWQiLCJfaXNGdWxsIiwibGVuZ3RoIiwiX3B1bHNlUXVldWUiLCJzbGljZSIsIm1hcCIsIml0ZW0iLCJwZW5kaW5nSXRlbSIsInNoaWZ0IiwiaWRsZUl0ZW0iLCJwb3AiLCJjbGVhclRpbWVvdXQiLCJyZWYiLCJfYWNxdWlyZUNsaWVudCIsIm5ld0NsaWVudCIsInJlbW92ZWQiLCJmaWx0ZXIiLCJjIiwiZW5kIiwiY29ubmVjdCIsInJlc3BvbnNlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiY29ubmVjdGlvblRpbWVvdXRNaWxsaXMiLCJwdXNoIiwicXVldWVDYWxsYmFjayIsImRvbmUiLCJ0aWQiLCJzZXRUaW1lb3V0IiwidGltZWRPdXQiLCJ0aW1lb3V0SGl0IiwiY29ubmVjdGlvbiIsInN0cmVhbSIsImRlc3Ryb3kiLCJtZXNzYWdlIiwibWF4TGlmZXRpbWVUaW1lb3V0IiwiYWRkIiwiaWRsZUluZGV4IiwiY2xpZW50UmVsZWFzZSIsInVucmVmIiwib25jZSIsImlzTmV3IiwicmVsZWFzZSIsIl9yZWxlYXNlT25jZSIsInZlcmlmeSIsInJlbGVhc2VkIiwiX3JlbGVhc2UiLCJfcG9vbFVzZUNvdW50IiwiX3F1ZXJ5YWJsZSIsIl9lbmRpbmciLCJpc0V4cGlyZWQiLCJoYXMiLCJkZWxldGUiLCJxdWVyeSIsInRleHQiLCJ2YWx1ZXMiLCJzZXRJbW1lZGlhdGUiLCJjbGllbnRSZWxlYXNlZCIsIm9uRXJyb3IiLCJwcm9taXNlZCIsIndhaXRpbmdDb3VudCIsImlkbGVDb3VudCIsImV4cGlyZWRDb3VudCIsInJlZHVjZSIsImFjYyIsInRvdGFsQ291bnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/pg-pool/index.js\n");

/***/ })

};
;